<!DOCTYPE html>
<html>
    <head>
        <title>TWG Menu - Thunder Warrior: Genesis</title>
        <link rel="apple-touch-icon" sizes="180x180" href="favicon/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="favicon/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="favicon/favicon-16x16.png">
        <link rel="manifest" href="favicon/site.webmanifest">
        <link rel="mask-icon" href="favicon/safari-pinned-tab.svg" color="#041024">
        <link rel="shortcut icon" href="favicon/favicon.ico">
        <meta name="msapplication-TileColor" content="#2b5797">
        <meta name="msapplication-config" content="favicon/browserconfig.xml">
        <meta name="theme-color" content="#041024">    
    </head>
    <body style="background-color:#010105" onresize = "if(typeof setImages === 'function') {setImages();}">
        <style>
body
{
    background: #efefef;
    font-size: 1.6vmin;
    color: #777;
    font-family: sans-serif;
    font-weight: 300;
    cursor: default;
}

* {
    cursor: default;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}


html, body {
    overflow: hidden;
    margin: 0;
    padding: 0;
    height: 100%;
    width: 100%;
}
#totalPower {
    position: absolute;
    top: 16vmin;
    height: 3vmin;
    font-size: 3vmin;
    width:100%;
    text-align: center;
    margin: 0;
    color: #777777;
}
#characterBackground {
    background-color: #05051a;
    position: absolute;
}
.modCounter {
    left: 1vmin;
}

.modsAvailable {
    background-color: #079950;
    right: 1vmin;
}

.weaponModCounter {
    position: absolute;
    width: 4vmin;
    height: 4vmin;
    text-align: center;
    color: #ffffff;
    top: 1.5vmin;
    border-radius: 4vmin;
    line-height: 4vmin;
    vertical-align: middle;
    font-size: 2.666vmin;
}

#weaponModEquippedCounter {
    left: .5vmin;
}

#weaponModAvailableCounter {
    background-color: #079950;
    left: 5.125vmin;
}

.counter {
    position: absolute;
    width: 3vmin;
    height: 3vmin;
    text-align: center;
    color: #ffffff;
    top: 2vmin;
    border-radius: 2vmin;
    line-height: 3vmin;
    vertical-align: middle;
    font-size: 2vmin;
}

.smallCounter {
    position: absolute;
    width: 2vmin;
    height: 2vmin;
    text-align: center;
    color: #ffffff;
    top: 1vmin;
    border-radius: 2vmin;
    line-height: 2vmin;
    vertical-align: middle;
    font-size: 1.33333vmin;
}

#gameTitle {
    position: absolute;
    background-color: #eddd10;
    top: 80vmin;
    left: 30vmin;
    width: 40vmin;
    height: 10vmin;
    border-radius: 3vmin;    
    color: #1222EF;
    border-color: #fdec10;
    border-width: 0.5vmin;
    font-size: 4.5vmin;
    padding: 0;
    outline: none;
    cursor: pointer;
}

.smallModCounter {
    left: 0;
}

.smallModsAvailable {
    background-color: #079950;
    right: 0;
}

#weaponDescriptionImage {
    padding-top: 0.5vmin;
    padding-left: 1vmin;
    max-width: 2.5vmin;
    max-height: 2.5vmin;
}
#descriptionBackground {
    z-index: 2;
    visibility: hidden;
    position: absolute;
    background-color: #1a1a4a;
    width: 40vmin;
    height: auto;
    border-radius: 1vmin;
}
#descriptionBackgroundMinors {
    width: 100%;
    margin-top: 3vmin;
}
.minorModificationSpace {
    width: 1vmin;
    display: inline-block;
}
.minorModifications {
    font-size: 1.75vmin;
    width: 96%;
    margin: 0.5vmin 1% 0.5vmin 1%;
    display: inline-block;
    text-align: center;
}
#homeScreen {
    position: absolute;
    visibility: hidden;
    width: 100vmin;
    height: 100vmin;
    left: calc(50vw - 50vmin);
    top: calc(50vh - 50vmin);
    background-color: #111133;
    overflow: hidden;
}
#weaponImageDisplay {
    top: 27vmin;
    left: 15vmin;
}
#meleeImageDisplay {
    top: 41.5vmin;
    left: 15vmin;
}
#weaponDescriptionTitle {
    position: absolute;
    top: 0.8vmin;
    left: 0;
    width: 100%;
    padding: 0 1vmin;
    text-align: center;
    font-size: 2.5vmin;
    color: #ffffff;
}
#weaponDescriptionText {
    padding-left: 2vmin;
    padding-right: 2vmin;
    margin-top: 1.5vmin;
    margin-bottom: 0;
    font-size: 1.75vmin;
    color: #ffffff;
    text-align: justify;
}
#weaponDescriptionInstructions img {
    height: 1.5vmin;
    vertical-align: top;
}
#weaponDescriptionInstructions {
    padding-left: 1vmin;
    padding-right: 1vmin;
    margin-top: 1vmin;
    font-size: 1.25vmin;
    color: #ffffff;
    text-align: center;
    vertical-align: top;
    white-space: pre-wrap;
    line-height: 1.5vmin;
}
#checkoutScreen {
    width: 500px;
    height: 365.5px;
    border: none;
    margin-left: calc((93.5vmin - 500px) / 2);
}
#weaponDescriptionCategory {
    position: absolute;
    top: 0vmin;
    font-size: 1.25vmin;
    left: 0vmin;
    color: #ffffff;
    white-space: pre-wrap;
    text-align: justify;
    width: 85%;
    padding: 0 10%;
}
#descriptionCanvas {
    background-color: #111133;
    margin: 1vmin;
}

#abilityGameIconHolder {
    position: absolute;
    top: 72.5vmin;
    left: 1%;
    width: 98%;
    height: 10vmin;
    display: flex;
    align-items: center;
    justify-content:center;
}
#abilityGameInstructions {
    position: absolute;
    top: 82.5vmin;
}
#abilityAdviceButton {
    position: absolute;
    top: 86vmin;
    text-decoration: underline;
}
.abilityAdviceText {
    margin: unset;
    text-align: left;
}
.abilityAdviceTitle {
    font-size: 2.5vmin;
    margin: unset;
    margin-bottom: 0.5vmin;
    text-transform: capitalize;
}
.abilityAdviceBox {
    position: absolute;
    margin: 0.5vmin;
    padding: 1vmin;
    display: none;
    bottom: 7vmin;
    background-color: #041024;
    border-color: #061845;
    border-width: 0.2vmin;
    border-style: solid;
    border-radius: 1vmin;
    z-index: 4;
}
.abilityAdvicHolder:hover .abilityAdviceBox {
    display:block;
}
.abilityDescriptionSubtext {
    text-align: center;
    width: 100%;
    font-size: 1.9vmin;
    display: flex;
    align-items: center;
    justify-content: center;
    white-space: pre-wrap;
    -webkit-backdrop-filter: blur(7px);
    backdrop-filter: blur(7px);
}
.abilityInstructionsIcon {
    height: 1.9vmin;
    margin-left: 0.4vmin;
    margin-right: 0.4vmin;
}
.gameAbilities {
    position: relative;
    width: 7vmin;
    height: 7vmin;
    display: flex;
    align-items: center;
    justify-content: center;
    border: #ffffff solid 0.1vmin;
    border-radius: 1vmin;
    margin: 0 0.3vmin 0 0.3vmin;
    text-align: center;
}
.gameAbilities span {
    position: absolute;
    margin-right: 0.5vmin;
    margin-left: 0.5vmin;
    top: 0.1vmin;
    font-size: 1.3vmin;
    width: calc(100% - 1vmin);
}
.gameAbilities img {
    max-width: 4vmin;
    max-height: 4vmin;
}
#abilityPage {
    position: absolute;
    visibility: hidden;
    background-color: #010105;
    width: 100vmin;
    height: 94vmin;
    left: calc((100% - 100vmin) / 2);
    top: calc((100% - 100vmin) / 2 + 6vmin);
}
#abilitiesBackground {
    position: absolute;
    left: 0;
    width: 60vmin;
    height: 94vmin;
    top: 0;
    background-color: #010105;
}
#prerequisiteLines {
    position: absolute;
    top: 0;
    left: 0;
}

#unlockButton {
    position: absolute;
    top: 72.5vmin;
    width: 70%;
    left: 15%;
    font-size: 3vmin;
    height: 5vmin;
    visibility: hidden;
}
#classButton {
    position: absolute;
    top: 82.5vmin;
    width: 15vmin;
    left: 70vmin;
    font-size: 2.5vmin;
    color: #ffffff;
    height: 5vmin;
}

.coolButton {
    text-align: center;
    background-image: linear-gradient(#3d3da3, #0b0b36);
    border-radius: 100vmin;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
}

.coolButton * {
    cursor: pointer;
}
#classAffiliation {
    position: absolute;
    height: 10vmin;
    width: 10vmin;
    top: 69vmin;
    left: 72.5vmin;
}
#classPurchase {
    position: absolute;
    top: 82vmin;
    left: 9vmin;
    width: 43vmin;
    background-color: #2e2e4d;
    height: 11vmin;
    color: #978a8a;
    text-align: center;
    padding: 1vmin 0.5vmin;
    border-radius: 2.5vmin;
    cursor: pointer;
}
#classPurchase * {
    cursor: pointer;
}
#classPurchase:hover {
    background-color: #1e1e5d;
    color: #ffffff;
}
#classPurchase:hover * {
    opacity: 100%;
}

#classPurchase img {
    height: 2.5vmin;
    opacity: 80%;
    vertical-align: middle;
    padding-right: 1vmin;
}
#classPurchase :first-child {
    font-size: 2.5vmin;
    margin: unset;
}
#classPurchase :nth-child(3) {
    margin: 0 4vmin;
    font-size: 1.75vmin;
}
#classPurchase span {
    font-size: 1.5vmin;
    width: 15vmin;
    height: 3.5vmin;
    margin: 0.5vmin auto;
    opacity: 80%;
}

.unlockIcon {
    height: 3vmin;
}

.abilityBackground {
    position: absolute;
    top: 0;
    left: 0;
}

.abilityPageColor {
    position: absolute;
    width: 12vmin;
    height: 12vmin;
  /*background-image: radial-gradient(ellipse, #00000000 35%, #010105 35%, #00a400 40%, #00000000 65%);*/
    background-image: radial-gradient(ellipse, #00000000 35%, #010105 35%, #0000a4 40%, #00000000 65%);
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    transition: opacity 3s ease-in-out;
    -webkit-transition: opacity 3s ease-in-out;
    -o-transition: opacity 3s ease-in-out;
    -moz-transition: opacity 3s ease-in-out;
    z-index: 1;
}

.abilityPageOption {
    position: absolute;
    width: 12vmin;
    height: 12vmin;
    background-image: radial-gradient(ellipse, #00000000 35%, #000000 35%, #ffffff 40%, #00000000 65%);
    display: flex;
    align-items: center;
    justify-content: center;
}

.unlocked img{
    transition: filter 4s ease-in-out;
    -webkit-transition: filter 4s ease-in-out;
    -o-transition: filter 4s ease-in-out;
    -moz-transition: filter 4s ease-in-out;
    filter: invert(1);
}

.unlocked .abilityPageColor {
    /*
    background-image: radial-gradient(ellipse, #00000000 35%, #ffffff 35%, #00a400 40%, #00000000 65%);*/
    background-image: radial-gradient(ellipse, #00000000 35%, #ffffff 35%, #0000a4 40%, #00000000 65%);
}

.abilityUnlockedBackground {
    display: block;
    content: "";
    width: 6vmin;
    height: 6vmin;
    position: absolute;
    top: 3vmin;
    left: 3vmin;
    background-color:#000000;
    border-radius: 100%;
    z-index: 3;
    cursor: pointer;
}

.abilityPulse {
    position: absolute;
    left: -2vmin;
    top: -2vmin;
    width: 16vmin;
    height: 16vmin;
    /*background-image: radial-gradient(ellipse, #ffea8070 40%, #ffea8040 55%,#00000000 65%);*/
    background-image: radial-gradient(ellipse, #ffea80e0 0%,#00000000 65%);
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    border-radius: 100%;
    z-index: 2;
}

@keyframes pulseAnimation {
    50%  {
        opacity: 0.2;
    }
}

@-moz-keyframes pulseAnimation {
    50%  {
        opacity: 0.2;
    }
}

@-webkit-keyframes pulseAnimation {
    50%  {
        opacity: 0.2;
    }
}

@keyframes pulseAnimationBrighter {
    50%  {
        opacity: 1;
    }
}

@-moz-keyframes pulseAnimationBrighter {
    50%  {
        opacity: 1;
    }
}

@-webkit-keyframes pulseAnimationBrighter {
    50%  {
        opacity: 1;
    }
}

.unlocked {
  /*background-image: radial-gradient(ellipse, #00000000 35%, #ffffff 35%, #0000a4 40%, #00000000 65%);*/
    background-image: radial-gradient(ellipse, #ffffff 40%, #ffffff 40%, #00000000 65%);
}

.unlocked .abilityUnlockedBackground {
    transition: background-color 4s ease-in-out;
    -webkit-transition: background-color 4s ease-in-out;
    -o-transition: background-color 4s ease-in-out;
    -moz-transition: background-color 4s ease-in-out;
    background-color: #ffffff;
}

.unClickedOption {
    opacity: 0 !important;
}

.clickedOption {
    opacity: 1 !important;
    border: 0 ! important;
}

.preRequisitesMet {
    -moz-animation: pulseAnimationBrighter 1.75s ease-in-out infinite;
    -webkit-animation: pulseAnimationBrighter 1.75s ease-in-out infinite;
    animation: pulseAnimationBrighter 1.75s ease-in-out infinite;
}

.preRequisitesNeeded {
    
    -moz-animation: pulseAnimation 3s ease-in-out infinite;
    -webkit-animation: pulseAnimation 3s ease-in-out infinite;
    animation: pulseAnimation 3s ease-in-out infinite;
}

.abilityPageIcon {
    max-height: 4.2vmin;
    max-width: 4.2vmin;
    margin: 0;
    padding: 0;
    border: 0;
    z-index: 4;
    cursor: pointer;
}

#healPageOption {
    left: 54vmin;
    top: 53vmin;
}
#fastFirePageOption {
    left: 40vmin;
    top: 61.75vmin;
}
#annihilationPageOption {
    left: 24.5vmin;
    top: 66vmin;
}
#burstShotPageOption {
    left: 22vmin;
    top: 81vmin;
}
#snipeShotPageOption {
    left: 11.5vmin;
    top: 70vmin;
}
#tripleShotPageOption {
    left: 37vmin;
    top: 74.75vmin;
}

#healOverTimePageOption {
    left: 70.75vmin;
    top: 60vmin;
}
#onenessPageOption {
    left: 54vmin;
    top: 66vmin;
}
#preparationPageOption {
    left: 54vmin;
    top: 79vmin;
}
#defensivePageOption {
    left: 76.76vmin;
    top: 72vmin;
}
#shieldPageOption {
    left: 83.25vmin;
    top: 82.875vmin;
}
#boundPageOption {
    left: 60.75vmin;
    top: 29.75vmin;
}
#sprintPageOption {
    left: 68vmin;
    top: 18vmin;
}
#changeWeaponPageOption {
    left: 41vmin;
    top: 40vmin;
}
#flurryOfBlowsPageOption {
    left: 31.25vmin;
    top: 28vmin;
}
#powerStrikePageOption {
    left: 21vmin;
    top: 19vmin;
}
#bleedStrikePageOption {
    left: 19.5vmin;
    top: 1vmin;
}
#criticalStrikePageOption {
    left: 8.75vmin;
    top: 14vmin;
}
#swiftStrikePageOption {
    left: 3.25vmin;
    top: 30vmin;
}
#traditionalBlockPageOption {
    left: 29.25vmin;
    top: 46vmin;
}
#thaumaturgyBlockPageOption {
    left: 16.5vmin;
    top: 50vmin;
}
#parryingThaumaturgyBlockPageOption {
    left: 3.75vmin;
    top: 54vmin;
}
#launchPageOption {
    left: 54vmin;
    top: 14vmin;
}
#leapPageOption {
    left: 54vmin;
    top: 1vmin;
}
#acceleratingDartPageOption {
    left: 87.5vmin;
    top: 0.25vmin;
}
#expeditiouseRetreatPageOption {
    left: 77.25vmin;
    top: 9.25vmin;
}
#speedPageOption {
    left: 78.25vmin;
    top: 31vmin;
}
#dashPageOption {
    left: 88.5vmin;
    top: 22vmin;
}




/* thaum time */
#hoverPageOption {
    left: 54vmin;
    top: 53vmin;
}
#fortificationPageOption {
    left: 40vmin;
    top: 61.75vmin;
}
#groupPreparationPageOption {
    left: 24.5vmin;
    top: 66vmin;
}
#healAuraPageOption {
    left: 11.5vmin;
    top: 70vmin;
}
#coolPageOption {
    left: 22vmin;
    top: 81vmin;
}
#recoveryPageOption {
    left: 37vmin;
    top: 74.75vmin;
}
#speedAuraPageOption {
    left: 61vmin;
    top: 64.5vmin;
}
#jumpBoostPageOption {
    left: 54vmin;
    top: 79vmin;
}
#swiftnessPageOption {
    left: 76.76vmin;
    top: 72vmin;
}
#tetherPageOption {
    left: 60.75vmin;
    top: 29.75vmin;
}
#reversalPageOption {
    left: 68vmin;
    top: 18vmin;
}
#pushPageOption {
    left: 41vmin;
    top: 40vmin;
}
#weakenPageOption {
    left: 31.25vmin;
    top: 28vmin;
}
#punishPageOption {
    left: 21vmin;
    top: 19vmin;
}
#exposePageOption {
    left: 19.5vmin;
    top: 1vmin;
}
#damageAuraPageOption {
    left: 3.25vmin;
    top: 30vmin;
}
#pullPageOption {
    left: 29.25vmin;
    top: 46vmin;
}
#lifeDrainPageOption {
    left: 16.5vmin;
    top: 50vmin;
}
#repulsePageOption {
    left: 3.75vmin;
    top: 54vmin;
}
#holdPageOption {
    left: 54vmin;
    top: 14vmin;
}
#chokePageOption {
    left: 54vmin;
    top: 1vmin;
}
#mindControlPageOption {
    left: 87.5vmin;
    top: 0.25vmin;
}
#confusionPageOption {
    left: 67.5vmin;
    top: 3.5vmin;
}
#inspireFearPageOption {
    left: 77.25vmin;
    top: 9.25vmin;
}
#overheatPageOption {
    left: 78.25vmin;
    top: 31vmin;
}
#freezePageOption {
    left: 88.5vmin;
    top: 22vmin;
}




#abilityDescription {
    position: absolute;
    left: 60vmin;
    width: 40vmin;
    height: 94vmin;
    top: 0;
    background-color: #13131df0;
    color: #ffffff;
    z-index: 7;
}
#abilityCloseIcon {
    position: absolute;
    top: 1.5vmin;
    left: 2.5vmin;
    height: 4vmin;
    cursor: pointer;
}
#abilityInfoIcon {
    position: absolute;
    top: 1.5vmin;
    left: 18vmin;
    height: 4vmin;
    cursor: pointer;
}

#abilityTypeIcon {
    position: absolute;
    top: 1.5vmin;
    left: 8vmin;
    height: 4vmin;
    cursor: pointer;
}

#abilitySwap {
    font-size: 3vmin;
    vertical-align: middle;
    position: absolute;
    right: 2.5vmin;
    top: 1.5vmin;
}
.abilitySwapIcon {
    height: 3vmin;
    margin-right: 1vmin;
    cursor: pointer;
}

#abilityTitleIcon {
    height: 4vmin;
    margin-right: 0.5vmin;
}

#abilityTitle {
    position: absolute;
    top: 10vmin;
    font-size: 4vmin;
    text-align: center;
    display: block;
    width: 100%;
}
#abilityText br {
    content: "";
    display: block;
    height: 0.75vmin;
}
#abilityText {
    position: absolute;
    top: 22vmin;
    font-size: 1.75vmin;
    width: 90%;
    padding: 0 5% 0 5%;
    text-align: justify;
    color: #ffffff;
}
#weaponPage {
    visibility: hidden;
    position: absolute;

}
#weaponIcon {
    position: absolute;
    max-width: 6vmin;
    max-height: 6vmin;
}
#weaponPageTitle {
    color: #ffffff;
    font-size: 4vmin;
}
#weaponPageTitleHolder {
    position: absolute;
    width: 37.5vmin;
    left: 15vmin;
    top: 6.75vmin;
    height:10vmin;
    display: flex;
    align-items: center;
}
#weaponPageDescription {
    color: #ffffff;
    position: absolute;
    top: 15vmin;
    left: 2.5vmin;
    width: 49vmin;
    height: 10vmin; 
    font-size: 2vmin;
    white-space:pre-wrap;
    text-align: justify;
}
#weaponIconBackground {
    position: absolute;
    display: flex;
    align-items: center;
    justify-content: center;
    top: 6.75vmin;
    left: 2.5vmin;
    width: 10vmin;
    height: 10vmin;
    border-radius: 50vmin;    
    background-color: #222266;
}

#weaponStatsCanvas {
    position: absolute;
    bottom: -51vmin;
    left: 5vmin;
    background-color: #606087;
}
#equipmentCount {
    position: absolute;
    bottom: -55vmin;
    left: 5vmin;
    font-size: 1.8vmin;
    white-space: pre;
    text-transform: capitalize;
}

#infoButton {
    position: absolute;
    width: 2.5vmin;
    height: 2.5vmin;
    cursor: pointer;
}

#statsScreen {
    color: #ffffff;
}

#statsList {
    position:absolute;
    top: 21.75vmin;
    left: 1.25vmin;
    background-color: #494970e7;
    width: 95vmin;
    overflow:hidden;
    z-index: 10;
    border-radius: 2vmin;
}

#statScroller {
    position: absolute;
    width: 97.5vmin;
    left: 1.25vmin;
    overflow-y: auto;
    overflow-x: hidden;
}

::-webkit-scrollbar {
  width: 1.5vmin;
}

#statScroller::-webkit-scrollbar-track {
  background: #363652e7; 
  border-radius: 2vmin;
}
 
#statScroller::-webkit-scrollbar-thumb {
    background: #345c5a;
    border-radius: 2vmin;
}

#statScroller::-webkit-scrollbar-thumb:hover {
  background: #578583; 
}

#statsTitle {
    position: absolute;
    left: 0;
    top: 0;
    text-align: center;
    width: 85vmin;
    font-size: 2vmin;
}

#statsUnitTitle {
    font-weight: bold;
    position: absolute;
    left: 0;
    bottom: 1.25vmin;
    text-align: center;
    width: 95vmin;
    font-size: 1.1vmin;
}

#statsUnit {
    white-space: pre;
    position: absolute;
    left: 0;
    bottom: 0;
    text-align: center;
    width: 95vmin;
    font-size: 1vmin;
}


#statsTable {
    position:absolute;
    border-collapse: collapse;
    color: #ffffff;
    top: 4.75vmin;
    left: 1.25vmin;
    width: 92.5vmin;
    table-layout: fixed;
    font-size: 1vmin;

}

#statsTable tr{
    font-size: 1.5vmin;
}

#statsTable td{
    padding: 0.5vmin;
}

#innerTable {
    top: 4.75vmin;
    left: 1.25vmin;
    width: 37.5vmin;
    height: 54vmin;
}

#statsExitButton {
    position:absolute;
    height: 2.5vmin;
    top: 1vmin;
    right: 1vmin;
}

#weaponPageWeapon {
    position: absolute;
}
#modHolder1 {
    position:absolute;
    height: 25%;
    top: 0;
}
#modHolder2 {
    height: 25%;
    top: 25%;
}
.modHolder {
    width: calc(100%);
    position: absolute;
    top: 0;
    left: 0;
    display: flex;
    justify-content: center;
    flex-wrap: wrap;   
}

#weaponPageWeaponBackground {
    position: absolute;
    left: 52.5vmin;
    top: 16.5vmin;
    width: 45vmin;
    height: 37.5vmin;
    background-color: #606087;
}

#flipToModsIcon {
    position: absolute;
    top: 1.5vmin;
    right: 1.5vmin;
    width: 5vmin;
    cursor: pointer;
    z-index:1;
}
#weaponPageMods {
    overflow: hidden;
    position: absolute;
    background-color: #606087;
    top: 56.5vmin;
    width: 100vmin;
    height: 43.5vmin
}
.modBackground {
    width: 7.5vmin;
    height: 7.5vmin;
    margin: 1vmin 0.7vmin;
    background-color: #444464aa;
    border-radius: 50vmin;
    position: relative;
}
.modImageClass {
    border-radius: 100%;
    position: absolute;
}

.homeImage {
    position: absolute;
    left: 0.5vmin;
    top: 0.5vmin;
    width: 5vmin;
    height: 5vmin;
    cursor: pointer;
    z-index:8;
}

#abilityHomeImage {
    top: -5.5vmin;
}
.armourImage {
    position: absolute;
}
#helmetImageDisplay {
    top: 66vmin;
    left: 15.5vmin;
}

#bodyImageDisplay {
    top: 66vmin;
    left: 30vmin;
}
#legsImageDisplay {
    top: 66vmin;
    left: 44.5vmin;
}
#rightArmImageDisplay {
    top: 66vmin;
    left: 59vmin;
}
.abilityImageDisplay {
    position: relative;
    visibility: visible;
    left: 68vmin;
    top: 20vmin;
}
.classAbilityImageDisplay {
    left: 62.5vmin;
    top: 22.25vmin;
    cursor: default !important;
}

.classAbilityImageDisplay * {
    cursor: default !important;
}
.traitDisplay {
    position: absolute;
    left: 0vmin;
    height: 9vmin;;
    width: 30vmin;
    background-color: #0b0b1f;
    color: #777777;
    border-radius: 1vmin;
    padding: 1vmin 0;

}
.traitDisplay:hover {
    background-color: #222244;
    color: #eeeeee;
}
#staminaImageDisplay {
    top: 0vmin;
    cursor: pointer;
}
#staminaImageDisplay * {
    cursor: pointer;
}
.abilityIconImage {
    max-width: 4vmin;
    max-height: 4vmin;
}
/*

*/
.abilityIcon {
    width: 5vmin;
    height: 5vmin;
    border-radius: 0.71428571428vmin;
    border: #ffffff solid 0.071428571428vmin;
    margin: 0 0.225vmin;
    /*background-color: #0000ff40;*/
    display: none;
    justify-content: center;
    align-items: center;
}
#abilityIconHolder {
    width: 90%;
    margin: 12.5% 5% 0% 5%;
    display: inline-flex;
    align-items: center;
    justify-content:space-evenly;
}
.traitImage {
    width: 2vmin;
    height: 2vmin;
    margin-right: 0.75vmin;
}
.traitTitle {
    text-align: center;
    font-size: 2vmin;
    margin: 0.5vmin 0;
    line-height: 2vmin;
    align-items:center;
}
.traitAspect {
    margin: 0.4vmin 0.4vmin;
    width: 13.9vmin;
    display: inline-block;
    padding: 0;
}
.traitValue {
    float: right;
}
#thaumaturgyImageDisplay {
    top: 12.3333333333vmin;
    cursor: pointer;
}
#thaumaturgyImageDisplay * {
    cursor: pointer;
}
#healthImageDisplay {
    top: 24.6666666667vmin;
    height: 7vmin;
}
#physicalImageDisplay {
    top: 35vmin;
    height: 7vmin;
}
#leftArmImageDisplay {
    top: 66vmin;
    left: 73.5vmin;
}
#modConstructionButton {
    color: #ffffff;
    position: absolute;
    left: 55vmin;
    top: 8vmin;
    width: 40vmin;
    height: 5vmin;
    background-color: #222266;
    outline:none;
    font-size: 2vmin;
    border-radius: 1.5vmin;
    border-color: #222266;
    border-width: 0.25vmin;
    cursor: pointer;
}
#informationBar {
    position: absolute;
    top: 0vmin;
    width: 100vmin;
    height: 6vmin;
    background-color: #05051a;
    z-index: 7;
}
.resourceDisplay {
    border-radius: 50vmin;
    position: absolute;
    height: 5vmin;
    width: 12vmin;
    top: .5vmin;
    background-color: #05051a;
}
.resourceDisplay:not(#experienceDisplay) {
    cursor: pointer;
}
.resourceDisplay:not(#experienceDisplay) * {
    cursor: pointer;
}
#levelCount {
    left: 2.11vmin;
    top: 1.495vmin;
    width: 1.823vmin;
    height: 2.0vmin;
    font-size: 1.25vmin;
    display: flex;
    align-items: center;
    justify-content: center;
    position:absolute;
}

#levelCountText {
    color: #ffffff;
    display:block;
    -webkit-transform:scale(0.7, 1);
    -moz-transform:scale(0.7, 1);
    -ms-transform:scale(0.7, 1);
    -o-transform:scale(0.7, 1);
    transform:scale(0.7, 1);
}

#classPointsDisplay{
    left: calc(0vmin + (83vmin * 4.85 / 7));
    visibility: hidden;
}

#experienceDisplay{
    left: calc(0vmin + (90vmin * 2 / 7));
}
#skillPointsDisplay {
    left: calc(0vmin + (90vmin * 2.95 / 7));
}
#creditsDisplay{
    left: calc(0vmin + (90vmin * 3.9 / 7));
}
#metalDisplay{
    left: calc(0vmin + (90vmin * 4.85 / 7));  
}
#crystalDisplay{
    left: calc(-0vmin + (90vmin * 5.8 / 7));  
}
#shopIcon {
    position: absolute;
    left: calc(15vmin + (74.5vmin * 5.8 / 6));
    height: 5vmin;
    width: 5vmin;
    top: .5vmin;
    cursor: pointer;
}
#fullScreenIcon {
    position: absolute;
    left: 94.5vmin;
    height: 3.5vmin;
    width: 3.5vmin;
    top: 1.25vmin;
    cursor: pointer;
}
#playerName {
    position: absolute;
    height: 5vmin;
    width: 14vmin;
    overflow: hidden;
    text-overflow: ellipsis;
    top: 0vmin;
    font-size: 2vmin;
    color: #cccccc;
    left: 14vmin;
}
#settingsIcon{
    position: absolute;
    height: 5vmin;
    width: 5vmin;
    top: .5vmin;
    left: calc(10.5vmin + 5vmin - (74.5vmin * 1 / 5));
    cursor: pointer;
}
#affiliationIcon {
    position: absolute;
    height: 5vmin;
    width: 5vmin;
    top: .5vmin;
    left: 8vmin;
}
.resourceImage {
    position: absolute;
    width: 4vmin;
    height: 4vmin;
    top: 0.5vmin;
    left: 1vmin;
}
.resourceCounter {
    position: absolute;
    font-size: 2vmin;
    color: #cccccc;
    top: -0.5vmin;
    left: 5.5vmin;
    
    /*   left: 0vmin*/
}
.imageDisplay {
    position: absolute;           
    border-radius: 50vmin;
    background-color: #05051a;
    width: 10vmin;
    height: 10vmin;
    cursor: pointer;
}
.imageDisplay * {
    cursor: pointer;
}
#shopScreen {
    visibility: hidden;
}
.purchaseOptions {
    position: absolute;
    top: 21vmin;
    cursor: pointer;
}

#purchaseOption0 {
    left: 5vmin;
}
#purchaseOption1 {
    left: calc((85vmin / 3) + 7.5vmin);
}
#purchaseOption2 {
    left: calc((85vmin / 3 * 2) + 10vmin);
}
.purchaseHeaders {
    position: absolute;
    padding: 1vmin 0.5vmin 0 0.5vmin;
    width: 7.75vmin;
    height: 4vmin;
    border-radius: 1vmin 1vmin 0 0;
    top: 15vmin;
    text-align: center;
    color: #ffffff;
    font-size: 1.4vmin;
    cursor: pointer;
    background-color: #606087
    /*   94 inner page height */
}
.purchaseHeaders:not(.clickedPurchaseHeader):hover {
    background-color: #4e4e6d
}
.purchaseHeaders.clickedPurchaseHeader {
    cursor: default;
    background-color: #222266
}

#shopBackground {
    position: absolute;
    top: 20vmin;
    left: 3vmin;
    height: 70.9vmin;
    width: calc((9.065vmin * 9) + 12vmin);
    background-color: #222266;
    border-radius: 2vmin;
}
#purchaseHeader0{
    left: 4.75vmin;
}
#purchaseHeader1 {
    left: calc((89.9vmin / 10) + 4.75vmin);
}
#purchaseHeader2 {
    left: calc((89.9vmin / 10 * 2) + 4.75vmin);
}
#purchaseHeader3 {
    left: calc((89.9vmin / 10 * 3) + 4.75vmin);
}
#purchaseHeader4 {
    left: calc((89.9vmin / 10 * 4) + 4.75vmin);
}
#purchaseHeader5 {
    left: calc((89.9vmin / 10 * 5) + 4.75vmin);
}
#purchaseHeader6 {
    left: calc((89.9vmin / 10 * 6) + 4.75vmin);
}
#purchaseHeader7 {
    left: calc((89.9vmin / 10 * 7) + 4.75vmin);
}
#purchaseHeader8 {
    left: calc((89.9vmin / 10 * 8) + 4.75vmin);
}
#purchaseHeader9 {
    left: calc((89.9vmin / 10 * 9) + 4.75vmin);
}

#settingsScreen {
    color: #ffffff;
    font-size: 3vmin;
}
#rewardsScreen {
    color: #ffffff;
    display: flex;
    flex-wrap: wrap;
    justify-content:space-evenly;
    align-items:center;
    z-index: 50;
}
#rewardBackground {
    background-color: #66669aca;
    width: 70vmin;
    border-radius: 1vmin;
}
#rewardTitle {
    font-size: 3vmin;
    margin: 1vmin 0 0.5vmin 0;
    text-align: center;
}
#rewardHolder {
    display: flex;
    flex-wrap: wrap;
    justify-content:space-evenly;
    align-items:center;
    padding: 2vmin 0.5vmin;
}
.rewardText {
    line-height:10vmin;
    text-align: center;
    font-size: 1.75vmin;
    position: absolute;
    width: 10vmin;
    margin:0;
    left: 0.3vmin;
    -webkit-transform:scale(0.7, 1);
    -moz-transform:scale(0.7, 1);
    -ms-transform:scale(0.7, 1);
    -o-transform:scale(0.7, 1);
    transform:scale(0.7, 1);
}
#rewardsCloseButton {
    position: absolute;
    font-size: 2vmin;
    text-align: center;
    background-color: #444464aa;
    border-radius:15vmin;
    width: 20vmin;
    height: 2vmin;
    padding: 1vmin 0;
    left: 42.5vmin;
    cursor: pointer;
}
.rewardBox {
    width: 10vmin;
    height: 10vmin;
    background-color: #444464aa;
    position: relative;
    border-radius: 10vmin;
    margin: .5vmin 1.5vmin;
}

.rewardImage {
    position: absolute;
}

.abilityDamage {
    color: #cf3333;
}

.abilityDuration {
    color: #9111ca;
}

.settingsSubButton {
    line-height: 5vmin;
    width: 20vmin;
    margin-top: 10vmin;
    background-color: #11113383;
    text-align:center;
    margin:auto;
    margin-top: 4.25vmin;
    width: 45vmin;
    border-radius: 10vmin;    
    border: 0.025vmin solid #ffffff;
    display: block;
    text-decoration: none;
    color: #ffffff;
    cursor: pointer;
}

.settingsSubButton:first-child {
    margin-top: 8vmin;
}

#tellBackground {
    position: absolute;
    background-color: #05051a;
    width: 25vmin;
    height: auto;
    left: calc((100vmin - 25vmin) / 2);
    top: calc((100vmin - 15vmin) / 2);
    color: #ffffff;
    border-radius:1.5vmin;
}
#tellTitle {
    padding: 1vmin 1vmin 0vmin 1vmin;
    margin: 0;
    font-size: 1.75vmin;
    text-align: center;
}
#tellText {
    left: 0;
    padding: 1vmin 1vmin 0 1vmin;
    text-align: justify;
    margin: 0;
    font-size: 1.5vmin;
}
#confirmationButton {
    left: 1vmin;
}
#dontShowAgainButton {
    left: 13vmin;
}
.tellButton {
    text-align: center;
    width: 11vmin;
    height: 3vmin;
    font-size: 1.25vmin;
    background-color: #000088;
    color: #ffffff;
    padding-top: 1.5vmin;
    display: inline-block;
    margin: 1vmin 0.63vmin 1vmin 0.63vmin;
    border-radius: 0.75vmin;
}
.purchaseScreen {
    visibility: visible !important;
}
.crystalPurchaseScreen {
    display: flex;
    align-items: center;
    justify-content: center;
}
.coverScreen {
    z-index: 100;
    position: absolute;
    visibility: hidden;
    background-color: #9a9a9a83;
    width: 100vmin;
    height: 100vmin;
    left: calc((100% - 100vmin) / 2);
    top: calc((100% - 100vmin) / 2);
}
#tellScreen {
    z-index: 100000000000000;
}
#gameModeSelectionTab {
    position: absolute;
    background-color: #212121d3;
    width: 90vmin;
    left: 5vmin;
    height: 60vmin;
    top: 100vmin;
}
.gameModeOption {
    position: absolute;
    width: 40vmin;
    cursor: pointer;
}
#oneVersusOneSelection {
    left: 4.5vmin;
    top: 4.5vmin;
}
#tenVersusTenSelection {
    left: 45.5vmin;
    top: 4.5vmin;

}
#twoVersusTwoSelection{
    left: 4.5vmin;
    top: 30.5vmin;
}
#freeForAllSelection {
    left: 45.5vmin;
    top: 30.5vmin;
}
#gameModeSelectionX {
    position: absolute;
    right: 1vmin;
    top: 1vmin;
    width: 3vmin;
    height: 3vmin;
}
#classOptionHolder {
    position: absolute;
    left: 7.5vmin;
    top: 21vmin;
}
#classSelectionScreen {
    padding-top: 10vmin;
    visibility: hidden;
    position: absolute;
    width: 100vmin;
    height: 100vmin;
    left: calc((100% - 100vmin) / 2);
    top: calc((100% - 100vmin) / 2);
    background-color: #111133;
}
#classText {
    color: #ffffff;
    text-align: center;
    font-size: 1.5vmin;
    margin: 0 7.5vmin;    
}
#classText::first-line {
    font-size: 2.5vmin;
}

.loadingIcon {
    position: absolute;
    border: 2vmin solid #c0c0ff;
    border-radius: 100%;
    border-top: 2vmin solid #24a9d2;
    width: 15vmin;
    height: 15vmin;
    -webkit-animation: spin 1.06s linear infinite;
    animation: spin 1.06s linear infinite;
    position: absolute;
    left: calc((100vw - 19vmin) / 2);
    top: calc((100vh - 19vmin) / 2);
}

.loadingIconSmall {
    position: absolute;
    border: 1vmin solid #c0c0ff;
    border-radius: 100%;
    border-top: 1vmin solid #24a9d2;
    width: 7.5vmin;
    height: 7.5vmin;
    -webkit-animation: spin 4.37s linear infinite;
    animation: spin 4.37s linear infinite;
    position: absolute;
    left: calc((100vw - 9.5vmin) / 2);
    top: calc((100vh - 9.5vmin) / 2);
    animation-direction: reverse;
}

#loadStatus {
  position: absolute;
  top: 60vh;
  left: 0;
  width: 100vw;
  font-size: 4vmin;
  text-align: center;
  color: #ffffff;
}

@-webkit-keyframes spin {
    0% { -webkit-transform: rotate(0def); }
    100% { -webkit-transform: rotate(360def); }
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

#title {
    text-align: center;
    font-size: 4vmin;
    color: #000000;
    margin-top: 0;
    margin-bottom: 1vmin;
}

#loadingPage {
    z-index: 4;
    visibility: visible;
    position: absolute;
    left: 0;
    top: 0;
    width: 100vw;
    height: 100vh;
    background-color: #111133
}

#helpfulText {
    text-align: center;
    color: #111133;
    padding: 18vmin 2vmin 0 2vmin;
}
.checkoutBackground {
    height: auto !important;
    overflow: hidden;
    min-height: 42.5vmin;
    max-height: 80vmin;
    position: unset !important;
}
.upgradeAbilityBackground {
    position: absolute;
    width: 93.5vmin;
    height: 42.5vmin;
    top: 28.75vmin;
    left: 3.25vmin;
    background-color: #66669aca;
    border-radius: 2vmin;
}
.purchaseUpgradeTitle {
    font-size: 2.5vmin;
    text-align: center;
    color: #ffffff;
    margin: 3.6vmin 1vmin 0 1vmin;
}
.closePurchaseButton {
    width: 3vmin;
    height: 3vmin;
    position: absolute;
    top: 1vmin;
    right: 1vmin;
    cursor: pointer;
}
#closeCrystalPurchaseButton {
    width: 3vmin;
    height: 3vmin;
    position: unset;
    margin: 1vmin 1vmin 0 0;
    cursor: pointer;
    float: right;
}
#upgradeLaterButton {
    width: 10vmin;
    height: 2.5vmin;
    position: absolute;
    right: 1vmin;
    top: 1vmin;
    color: #c3c3c3;
    font-size: 1.25vmin;
    cursor: pointer;
}
.purchaseUpgradeText {
    font-size: 1.5vmin;
    text-align: center;
    color: #dedede;
}
.purchaseHolder {
    display: flex;
    flex-wrap: nowrap;
    justify-content: space-evenly;
    flex-direction: row;
}
.upgradePurchaseHolderHolder {
    display: flex;
    flex: 1;
    overflow: auto;
}
.upgradePurchaseHolder {
    bottom: 2vmin;
    position: absolute;
    height: 28vmin;
    width: 100%;
}

.purchaseUpgradeOption {
    margin: 0 1.1vmin 0 1.1vmin;
    width: 20.83vmin;
    min-width: 20.83vmin;
    height: 100%;
    background-color: #6a6aa1ca;
    display: inline-block;
    position: relative;
    border-radius: 3vmin;
}
.upgradePurchaseImage {
    width: 10vmin;
    height: 10vmin;
    left: 5.415vmin;
    top: 3.75vmin;
    position: absolute;
}
.crystalText {
    height: 1.7vmin;
    vertical-align: middle;
}
#crystalOptionText {
    height: 5vmin;
    vertical-align: middle;
    margin: -0.675vmin 0 0 -0.5vmin;
}
.upgradeAbilityOptionText {
    font-size: 1.25vmin;
    color: #e7e7e7;
    position: absolute;
    top: 15vmin;
    width: 18.83vmin;
    text-align: center;
    padding: 0 1vmin 0 1vmin
}

#abilityOptionTable {
    display: none;
}

.upgradeAbilityOptionButton {
    width: 17vmin;
    height: 3.75vmin;
    font-size: 1.25vmin;
    left: 1.915vmin;
    top: 21.75vmin;
    position: absolute;
    color: #ffffff;
}

.upgradeAbilityInfoButton{
    position: absolute;
    width: 2.5vmin;
    height: 2.5vmin;
    right: 1vmin;
    top: 1vmin;
    cursor: pointer;
}
.numCounter {
    height: 3vmin;
    color: #ffffff;
    text-align: center;
    font-size: 1vmin;
    padding-top: 2vmin;
    width: 2vmin;
    margin: 0 0.5vmin;
    background-color: #008643;
    border-radius: 0.75vmin;
    display: inline-block;
    vertical-align: top;
}
.classOption .classMath, .classBox{
    height: 5vmin;
    display: inline-block;
    vertical-align: top;
}
.classAddition {
    background-Image: url("/image/addButton");
    background-size: 100%;
    width: 5vmin;
    background-color: #00ff80;
    cursor: pointer;
}
.classSubtraction {
    background-Image: url("/image/subtractButton");
    background-size: 100%;
    background-color: rgb(228, 0, 57);
}
.classMath {
    cursor: pointer;
    width: 5vmin;
    border-radius: 1vmin;
}
.classOption {
    padding: 1.25vmin;
}
.clickedClassOption {
    background-color: #3bff9d;
    color: #000000;
}
.classSubtraction.cantClick {
    background-color: rgb(151, 47, 73);
    cursor: default;
}
.classAddition.cantClick {
    background-color: #3c7c5c;
    cursor: default;
}
.classTitle {
    display: inline-block;
    text-transform: capitalize;
    font-size: 0.875vmin;
    margin-top: 1.875vmin;
    margin-bottom: 1.875vmin;
}
.classDescription {
    color: #ffffff;
    position: relative;
    height: 0;
    width: 0;
    margin-right: 5vmin;
}
.classDescriptionBox {
    width: 30vmin;
    bottom: 0vmin;
}
.classSellectionBoxTitle {
    text-align: center;
    width: 100%;
    font-size: 1.25vmin;
    text-transform: capitalize;
}
.classSelectionBoxText {
    text-align: center;
    width: 100%;
    font-size: 1vmin;
}

        </style>
<div id = "loadingPage">
    <div class = loadingIcon></div>
    <div class = loadingIconSmall></div>
    <p id = loadStatus>Fetching Thunder Warrior Data</p>
</div>
<div id = "classSelectionScreen">
    <p id = classText>Welcome to the Attributes Selector!<br>Select Attributes to build your Thunder Warrior. A thunder Warrior has four Stats: Stamina, Thaumaturgy, Health, and Physicality. Attributes are a simplified way to set your Thunder Warrior's starting Traits for the different Stats. The attributes cannot be changed easilly later, so choose wisely.</p>
    <div id = classOptionHolder></div>
    <template id = classOptionTemplate>
        <div class = "classOption" data-classType = "hp">
            <div class = "classBox">
                <div class = "abilityAdvicHolder classDescription">
                    <p class = classTitle>Strength</p>
                    <div class = "abilityAdviceBox classDescriptionBox">
                        <p class = "classSellectionBoxTitle">Strength</p>
                        <p class = "classSelectionBoxText">Temp text that fully describes strength in it's entire entireity because it is so full and complete</p>
                    </div>
                </div>
            </div>
            <div class = "classMath classSubtraction" onclick = "modifyClassOption(this,-1)"></div>
            <div class = "numCounter"></div>
            <div class = "numCounter"></div>
            <div class = "numCounter"></div>
            <div class = "numCounter"></div>
            <div class = "numCounter"></div>
            <div class = "numCounter"></div>
            <div class = "numCounter"></div>
            <div class = "classMath classAddition" onclick = "modifyClassOption(this,1)"></div>
            <div class = "classBox">
                <div class = "abilityAdvicHolder classDescription">
                    <p class = classTitle>Strength</p>
                    <div class = "abilityAdviceBox classDescriptionBox">
                        <p class = "classSellectionBoxTitle">Strength</p>
                        <p class = "classSelectionBoxText">Temp text that fully describes strength in it's entire entireity because it is so full and complete</p>
                    </div>
                </div>
            </div>
        </div>
        </div>
    </template>
    <div id = classPurchase onclick = showClassPurchaseOption()>
        <p><img src = "/image/attributesPointsIcon">Purchase More Attribute Points</p>
        <span class = coolButton>Go to Shop</span>
        <p>Power up your Thunder Warrior with more Attribute Points to enhance their skills!</p>
    </div>
    <span class = coolButton id = classButton onclick = selectClass();>Continue</span>
    <img id = classAffiliation src = "/image/rebellionIconColored">
</div>
<div id = "homeScreen">
    <div id = "informationBar">
        <img id = "settingsIcon"  onclick = "viewSettings();" src = "/image/settingsIcon">
        <img id = "affiliationIcon">
        <p id = "playerName"></p>
        <div id = "experienceDisplay" class = "resourceDisplay">
            <img class = "resourceImage" src = "/image/experienceIcon">
            <div id = "levelCount">
                <span id = levelCountText></span>
            </div>
            <p id = "experienceCount" class = "resourceCounter"></p>
        </div>
        <div id = "creditsDisplay" class = "resourceDisplay" onclick = purchaseCredits()>
            <img class = "resourceImage" src = "/image/creditsIcon">
            <p id = "creditCount" class = "resourceCounter"></p>
        </div>
        <div id = "metalDisplay" class = "resourceDisplay" onclick = purchaseMetals()>
            <img class = "resourceImage" src = "/image/metalIcon">
            <p id = "metalCount" class = "resourceCounter"></p>
        </div>
        <div id = "skillPointsDisplay" class = "resourceDisplay" onclick = purchaseSkillPoints()>
            <img class = "resourceImage" src = "/image/skillPointsIcon">
            <p id = "skillPointsCount" class = "resourceCounter"></p>
        </div>
        <div id = "classPointsDisplay" class = "resourceDisplay" onclick = showClassPurchaseOption()>
            <img class = "resourceImage" src = "/image/attributesPointsIcon">
            <p id = "classPointsCount" class = "resourceCounter"></p>
        </div>
        <div id = "crystalDisplay" class = "resourceDisplay" onclick = purchaseCrystals()>
            <img class = "resourceImage" src = "/image/CrystalIcon">
            <p id = "crystalCount" class = "resourceCounter"></p>
        </div>
        <img id = "shopIcon" onclick = "showShopScreen('equipment')" src = "/image/shopIcon">
        <img status = "window" id = fullScreenIcon onclick = "stFullScreen(this)" src = "/image/fullScreenEnterButton">
    </div>
    <div id = "characterScreen">
        <button id = "gameTitle" onclick = "showGameModeSelection()">Enter the Arena</button>
        <p id = 'totalPower'></p>
        <canvas id="characterBackground" width = "1000" height = "600"></canvas>
        <div id = "weaponImageDisplay" class = "imageDisplay" onclick="showWeaponScreen(troop.rangedWeapon, troop.unlockedRangedWeapons, troop.rangedWeapon.mods)" onmouseover="showWeaponDescription(weaponImageDisplay, troop.rangedWeapon)" onmouseout="hideWeaponDescription()">
            <img id = "weaponImage" class = "armourImage">
        </div>
        <div id = "meleeImageDisplay" class = "imageDisplay" onclick="showWeaponScreen(troop.meleeWeapon, troop.unlockedMeleeWeapons, troop.meleeWeapon.mods)" onmouseover="showWeaponDescription(meleeImageDisplay, troop.meleeWeapon)" onmouseout="hideWeaponDescription()">
            <img id = "meleeImage" class = "armourImage">
        </div>
        <div id = "helmetImageDisplay" class = "imageDisplay" onclick="showWeaponScreen(troop.playerImage.head, troop.unlockedHelmets, troop.playerImage.head.mods)" onmouseover="showWeaponDescription(helmetImageDisplay, troop.playerImage.head)" onmouseout="hideWeaponDescription()">
            <img id = "helmetImage" class = "armourImage">
        </div>
        <div id = "bodyImageDisplay" class = "imageDisplay" onclick="showWeaponScreen(troop.playerImage.body, troop.unlockedBodies, troop.playerImage.body.mods)" onmouseover="showWeaponDescription(bodyImageDisplay, troop.playerImage.body)" onmouseout="hideWeaponDescription()">
            <img id = "bodyImage" class = "armourImage">
        </div>
        <div id = "legsImageDisplay" class = "imageDisplay" onclick="showWeaponScreen(troop.playerImage.legs, troop.unlockedLegs, troop.playerImage.legs.mods)" onmouseover="showWeaponDescription(legsImageDisplay, troop.playerImage.legs)" onmouseout="hideWeaponDescription()">
            <img id = "legsImage" class = "armourImage">
        </div>
        <div id = "leftArmImageDisplay" class = "imageDisplay" onclick="showWeaponScreen(troop.playerImage.leftArm, troop.unlockedLeftArms, troop.playerImage.leftArm.mods)" onmouseover="showWeaponDescription(leftArmImageDisplay, troop.playerImage.leftArm)" onmouseout="hideWeaponDescription()">
            <img id = "leftArmImage" class = "armourImage">
        </div>
        <div id = "rightArmImageDisplay" class = "imageDisplay" onclick="showWeaponScreen(troop.playerImage.rightArm, troop.unlockedRightArms, troop.playerImage.rightArm.mods)" onmouseover="showWeaponDescription(rightArmImageDisplay, troop.playerImage.rightArm)" onmouseout="hideWeaponDescription()">
            <img id = "rightArmImage" class = "armourImage">
        </div>
        <div class = abilityImageDisplay>
            <div id = "staminaImageDisplay" class = "traitDisplay" onclick="showAbilityPage('stamina')" onmouseover="showAbilityDescription(staminaImageDisplay, troop.stamina, 'staminaIcon')" onmouseout="hideWeaponDescription()">
                <p class = traitTitle><img class = "traitImage" src = "/image/staminaIcon">Stamina</p>
                <p class = traitAspect>Maximum:<span class = traitValue>132</span></p>
                <p class = traitAspect>Recovery:<span class = traitValue>132</span></p>
                <P class = traitAspect>Damage:<span class = traitValue>132</span></P>
                <P class = traitAspect>Defense:<span class = traitValue>132</span></P>
            </div>
            <div id = "thaumaturgyImageDisplay" class = "traitDisplay" onclick="showAbilityPage('force')" onmouseover="showAbilityDescription(thaumaturgyImageDisplay, troop.force, 'thaumaturgyIcon')" onmouseout="hideWeaponDescription()">
                <p class = traitTitle><img class = "traitImage" src = "/image/thaumaturgyIcon">Thaumaturgy</p>
                <p class = traitAspect>Maximum:<span class = traitValue>132</span></p>
                <p class = traitAspect>Recovery:<span class = traitValue>132</span></p>
                <P class = traitAspect>Damage:<span class = traitValue>132</span></P>
                <P class = traitAspect>Defense:<span class = traitValue>132</span></P>
            </div>
            <div id = "healthImageDisplay" class = "traitDisplay" onmouseover="showAbilityDescription(healthImageDisplay, troop.hp, 'hitpointIcon')" onmouseout="hideWeaponDescription()">
                <p class = traitTitle><img class = "traitImage" src = "/image/hitpointIcon">Health</p>
                <p class = traitAspect>Maximum:<span class = traitValue>132</span></p>
                <p class = traitAspect>Recovery:<span class = traitValue>132</span></p>
            </div>
            <div id = "physicalImageDisplay" class = "traitDisplay" onmouseover="showAbilityDescription(physicalImageDisplay, troop.physical, 'physicalIcon')" onmouseout="hideWeaponDescription()">
                <p class = traitTitle><img class = "traitImage" src = "/image/physicalIcon">Physicality</p>
                <P class = traitAspect>Damage:<span class = traitValue>132</span></P>
                <P class = traitAspect>Defense:<span class = traitValue>132</span></P>
            </div>
        </div>

    </div>
    <div id = 'weaponPage'>
        <div id = "weaponPageMods">
            <p id = 'helpfulText'></p>
        </div>
        <button id = "modConstructionButton"></button>
        <div id = "weaponIconBackground">
            <img id = "weaponIcon">
        </div>
        <div id = weaponPageTitleHolder>
            <p id = "weaponPageTitle">Weapon Name</p>
        </div>
        <p id = "weaponPageDescription">Weapon Description</p>
        <canvas id = "weaponStatsCanvas"></canvas>
        <span id = equipmentCount>Ranged Weapons Unlocked: 100</span>
        <img id = "infoButton" onclick = "showStats(selectedEquipment)" src = "/image/infoIcon">
        <div id = "weaponPageWeaponBackground">
            <img id = flipToModsIcon onclick = "displayOrHideModOptions(event)" src = "/image/flipIcon">
            <div class = 'weaponModCounter' id = weaponModEquippedCounter></div>
            <div class = 'weaponModCounter' id = 'weaponModAvailableCounter'></div>
            <img id = "weaponPageWeapon">
            <div id = modHolder1 class = 'modHolder'></div>
            <div id = modHolder2 class = 'modHolder'></div>
        </div>
        <img class = "homeImage" onclick="showHomeScreen(); hideWeaponScreen();" src = "/image/homeIcon">
    </div>
    <div id = 'abilityPage'>
        <div id = "abilitiesBackground" onclick = resetAbilities(false,event)>
            <svg width = "100vmin" height = "100vmin" onclick = resetAbilities(false,event)>
                <circle cx="60vmin" cy="46vmin" r="13vmin" stroke="#555555" stroke-width="0.25vmin" fill="none"></circle>
                <circle cx="60vmin" cy="46vmin" r="26vmin" stroke="#555555" stroke-width="0.25vmin" fill="none"></circle>
                <circle cx="60vmin" cy="46vmin" r="39vmin" stroke="#555555" stroke-width="0.25vmin" fill="none"></circle>
                <circle cx="60vmin" cy="46vmin" r="52vmin" stroke="#555555" stroke-width="0.25vmin" fill="none"></circle>
            </svg>
            <svg id = prerequisiteLines width = 100vmin height = 100vmin onclick = resetAbilities(false,event)></svg>
            <div id = staminaAbilities class = abilityBackground>
            </div>
            <div id = thaumaturgyAbilities class = abilityBackground></div>
        </div>
        <div id = "abilityDescription">
            <img id = abilityCloseIcon onclick = hideAbilityDescription(true) src = "/image/exitButton">
            <img id = abilityInfoIcon src = "/image/infoIcon">
            <img id = abilityTypeIcon onclick = resetAbilities(false,event)> 
            <span id = abilitySwap><img class = abilitySwapIcon><img class = abilitySwapIcon></span>
            <p id = abilityTitle><img id = abilityTitleIcon>Stamina</p>
            <p id = abilityText></p>
            <span class = coolButton id = unlockButton></span>
            <div id = abilityGameIconHolder></div>
            <p id = abilityGameInstructions class = abilityDescriptionSubtext>Insturctions</p>
            <div id = abilityAdvicHolder class = abilityAdvicHolder>
                <p id = abilityAdviceButton class = abilityDescriptionSubtext>View Ability Recomendations</p>
                <div class = abilityAdviceBox>
                <p class = "abilityDescriptionSubtext abilityAdviceTitle">Ability Recomendations</p>
                <p id = abilityAdviceText class = "abilityDescriptionSubtext abilityAdviceText"></p>
                </div>
            </div>
        </div>
        <img id = "abilityHomeImage" class = "homeImage" onclick="showHomeScreen(); hideAbilityPage();" src = "/image/homeIcon">
    </div>
    <div id = "shopScreen"> 
        <img class = "homeImage" onclick="showHomeScreen(); hideShopScreen();" src = "/image/homeIcon">
        <div id = "purchaseHeader0" class = "purchaseHeaders" onclick="weaponsShopScreen()">Weapons</div>
        <div id = "purchaseHeader1" class = "purchaseHeaders" onclick="armourShopScreen()">Armor</div>
        <div id = "purchaseHeader2" class = "purchaseHeaders" onclick="equipmentShopScreen()">Equipment</div>
        <div id = "purchaseHeader3" class = "purchaseHeaders" onclick="weaponModsShopScreen()">Weapon Mods</div>
        <div id = "purchaseHeader4" class = "purchaseHeaders" onclick="armourModsShopScreen()">Armour Mods</div>
        <div id = "purchaseHeader5" class = "purchaseHeaders" onclick="allModsShopScreen()">Any Mods</div>
        <div id = "purchaseHeader6" class = "purchaseHeaders" onclick="purchaseSkillPoints()">Skill Points</div>
        <div id = "purchaseHeader7" class = "purchaseHeaders" onclick="purchaseCredits()">Credits</div>
        <div id = "purchaseHeader8" class = "purchaseHeaders" onclick="purchaseMetals()">Metals</div>
        <div id = "purchaseHeader9" class = "purchaseHeaders" onclick="purchaseCrystals()">Crystals</div>
        <div id = shopBackground></div>
        <canvas id = "purchaseOption0" class = "purchaseOptions"></canvas>
        <canvas id = "purchaseOption1" class = "purchaseOptions"> </canvas>
        <canvas id = "purchaseOption2" class = "purchaseOptions"></canvas>
    </div>
    <div id = "settingsScreen" onclick = "closeSettings(event)" class = "coverScreen">
        <a class = "settingsSubButton" href = "https://thunderwarrior.org/home" onclick = "return returnToHome()" target = "_self">Return Home</a>
        <a class = "settingsSubButton" href = "https://thunderwarrior.org/manage" target = "_blank">Manage Account</a>
        <a class = "settingsSubButton" href = "https://thunderwarrior.org/news" target = "_blank">Check News</a>
        <a class = "settingsSubButton" href = "https://thunderwarrior.org/feedback" target = "_blank">Leave Feedback</a>
        <a class = "settingsSubButton" href = "https://thunderwarrior.org/credits" target = "_blank">View Credits</a>
        <a class = "settingsSubButton" onclick = "totalRedirect('signOut')">Log Out</a>
        <a id = selectAbilityUpgradeSettingsOption class = "settingsSubButton" onclick = "selectAbilityUpgrade(event)">Select Ability Upgrade</a>
        <a id = resetAttributesPointsOption class = "settingsSubButton" onclick = "resetAttributesPoints(event)">Reset Attribute Points 50 <img id = crystalOptionText src = '/image/CrystalIcon'></a>
        <a class = "settingsSubButton" onclick = "closeSettings(event)">Close</a>
    </div>
    <div id = 'rewardsScreen' class = 'coverScreen' onclick = accpetRewards(event)>
        <div id = rewardBackground>
            <p id = rewardTitle>Rewards</p>
            <div id = rewardHolder></div>
            <div id = rewardsCloseButton onclick = 'accpetRewards(event)'>Accept Rewards</div>
        </div>
    </div>
    <template id = purchaseTemplate>
        <div class = "purchaseScreen coverScreen" onclick = closePurchase(event,this)>
            <div class = upgradeAbilityBackground>
                <img class = closePurchaseButton src = "image/exitButton" onclick = closePurchase(event,this.parentElement.parentElement)>
                <p class = purchaseUpgradeTitle></p>
                <p class = purchaseUpgradeText></p>
                <div class = upgradePurchaseHolderHolder> 
                    <div class = "upgradePurchaseHolder purchaseHolder"></div>
                </div>
            </div>
        </div>
    </template>
    <template id = paymentScreenTemplate>
        <div class = "purchaseScreen coverScreen crystalPurchaseScreen" onclick = closePurchase(event,this)>
            <div class = "upgradeAbilityBackground checkoutBackground">
                <img id = closeCrystalPurchaseButton src = "image/exitButton" onclick = closePurchase(event,this.parentElement.parentElement)>
                <p class = purchaseUpgradeTitle></p>
                <p class = purchaseUpgradeText></p>
                <iframe id = checkoutScreen src = 'https://genesis.thunderwarrior.org/checkout'></iframe>
                    
            </div>
        </div>
    </template>
    <template id = classPointPurchase>
        <div class = purchaseUpgradeOption> 
            <img class = upgradePurchaseImage src = "/image/attributesPointsIcon">
            <p class = upgradeAbilityOptionText></p>
            <span class = "coolButton upgradeAbilityOptionButton" onclick = ""></span>
        </div>
    </template>
    <div id = "upgradeAbilityScreen" class = coverScreen onclick = 'upgradeLater(event)'>
        <div class = upgradeAbilityBackground>
            <div id = upgradeLaterButton class = coolButton onclick = 'upgradeLater(event)'>Upgrade Later</div>
            <p id = upgradeAbilityTitle clss = purchaseUpgradeTitle></p>
            <p id = upgradeAbilityText class = purchaseUpgradeText></p>
            <div class = upgradePurchaseHolder>
                <div class = purchaseUpgradeOption>
                    <img class = upgradePurchaseImage src = "/image/hitpointIcon">
                    <p class = upgradeAbilityOptionText>Increase your Thunder Warrior's Survivability</p>
                    <span class = "coolButton upgradeAbilityOptionButton" onclick = "selectedUpgradeAbility('hp')">Upgrade Health</span>
                    <img class = upgradeAbilityInfoButton onclick = "getAbilityInfo('hp')" src = "/image/infoIcon">
                </div>
                <div class = purchaseUpgradeOption>
                    <img class = upgradePurchaseImage src = "/image/staminaIcon">
                    <p class = upgradeAbilityOptionText>Make your Thunder Warrior's Stamina abilities more effective</p>
                    <span class = "coolButton upgradeAbilityOptionButton" onclick = "selectedUpgradeAbility('stamina')">Upgrade Stamina</span>
                    <img class = upgradeAbilityInfoButton onclick = "getAbilityInfo('stamina')" src = "/image/infoIcon">
                </div>
                    <div class = purchaseUpgradeOption>
                    <img class = upgradePurchaseImage src = "/image/thaumaturgyIcon">
                    <p class = upgradeAbilityOptionText>Make your Thunder Warrior's Thaumaturgy abilities more effective</p>
                    <span class = "coolButton upgradeAbilityOptionButton" onclick = "selectedUpgradeAbility('force')">Upgrade Thaumaturgy</span>
                    <img class = upgradeAbilityInfoButton onclick = "getAbilityInfo('force')" src = "/image/infoIcon">
                </div>
                <div class = purchaseUpgradeOption>
                    <img class = upgradePurchaseImage src = "/image/physicalIcon">
                    <p class = upgradeAbilityOptionText>Increase your Thunder Warrior's Physical Prowess</p>
                    <span class = "coolButton upgradeAbilityOptionButton" onclick = "selectedUpgradeAbility('physical')">Upgrade Physicality</span>
                    <img class = upgradeAbilityInfoButton onclick = "getAbilityInfo('physical')" src = "/image/infoIcon">
                </div>
            </div>
        </div>
    </div>
    <div id = "statsScreen" class = "coverScreen" onclick = "hideStats(false, event)">
        <div id = "statScroller" onclick = "hideStats(false, event)">
            <div id = statsList>
                <p id = "statsTitle"></p>
                <img id = "statsExitButton" onclick = "hideStats(false, event)" src = "/image/exitButton">
                <table id = "statsTable">
                    <tbody id = "innerTable">
                        <tr id = "headerTable">
                            <th style = "width: 7.5vmin"></th>
                            <th style = "width: 4vmin"></th>
                            <th style = "width: 4vmin"></th>
                            <th style = "width: 4vmin"></th>
                            <th style = "width: 4vmin"></th>
                            <th style = "width: 20vmin"></th>
                        </tr>
                    </tbody>
                </table>
                <p id = "statsUnitTitle"> Units</p>
                <p id = "statsUnit">U  Game Distance Units        H  Heat        HP  Health        S  Stamina        Th  Thaumaturgy        &deg  Degrees        %  Percent        T  Time in Seconds        D  Defense        -  No Applicable Modifications</p>
            </div>
        </div>
    </div>
    <div id = "gameModeSelectionBackground" class = "coverScreen" onclick = "hideGameModeSelection(event)"> 
        <div id = "gameModeSelectionTab">
            <img id = "oneVersusOneSelection" class = "gameModeOption" onclick="startGame('sandbox')" src = "/image/SinglePlayerSandbox">
            <img id = "twoVersusTwoSelection" class = "gameModeOption" onclick="startGame('solo')" src = "/image/OneVsOneDuel">
            <img id = "tenVersusTenSelection" class = "gameModeOption" onclick="startGame('duo')" src = "/image/TwoVsTwoDeathmatch">
            <img id = "freeForAllSelection" class = "gameModeOption" onclick="startGame('squad')" src = "/image/FourVsFourSquadBattle">
            <img id = "gameModeSelectionX" onclick = "hideGameModeSelection(event)" src = "/image/exitButton">
        </div>
    </div>
    <div id = "tellScreen" class = "coverScreen" onclick = "hideTell(event)">
        <div id = "tellBackground">
            <p id = "tellTitle">Title</p>
            <p id = "tellText">text</p>
            <div id = "confirmationButton" class = "tellButton" onclick = "hideTell(event)">Accept</div>
            <div id = "dontShowAgainButton" class = "tellButton" onclick = "dontShowAgain()">Don't Show Again</div>
        </div> 
    </div>
</div>
<div id = "descriptionBackground" >
    <img id = "weaponDescriptionImage">
    <p id = "weaponDescriptionCategory"></p>
    <br>
    <p id = "weaponDescriptionTitle"></p>
    <div id = 'abilityIconHolder'></div>
    <div id = 'descriptionBackgroundMinors'></div>
    <canvas id = "descriptionCanvas"></canvas>
    <p id = "weaponDescriptionText"></p>
    <p id = "weaponDescriptionInstructions"></p>
</div> 
<form id = startForm method = post>
    <input type = hidden name = signUpOrIn value = enterGame>
</form>
        <iframe id = iframe src = 'https://thunderwarrior.org/iframe'></iframe>
        <script id = wsScript type = "text/javascript" src = "clientWebsocket"></script>
        <script>
'use strict'

//variables for homescreen
var inGame = false;
var testing = false;
var weaponHovering = false;
var ctx2 = document.getElementById("characterBackground").getContext("2d");
var ctx3 = document.getElementById("descriptionCanvas").getContext("2d");
var ctx4 = document.getElementById("weaponStatsCanvas").getContext("2d");
var ctx5 = document.getElementById("purchaseOption0").getContext("2d");
var ctx6 = document.getElementById("purchaseOption1").getContext("2d");
var ctx7 = document.getElementById("purchaseOption2").getContext("2d");
var sizeUnits = 1;
var classOptions = {
    strength: {
        start: 0,
    }, dexterity: {
        start: 0,
    }, constitution: {
        start: 0,
    }, intelligence: {
        start: 0,
    }, wisdom: {
        start: 0,
    }, light: {
        start: 4,
        backTitle: "dark",
    }, rebellion: {
        start: 4,
        backTitle: "empire",
    }, slight: {
        start: 4,
        backTitle: "heavy",
    },

}
var onPage = "homeScreen";
var purchaseType;
var selectedEquipment;
var selectedEquipmentArray = [];
var fullEquipmentArray;
var equipmentSelections = [];
var equipmentArrayForModifications;
var equipmentForModifications;
var hoveredEquipment;
var hoveredDisplay;
var moreInfo = false;
var modsShowing = false;
var gameModeSelectionShowing = false;
var pageLoaded = false;
var selectedItem = "none";
var shopDescription = "";
var shopNames = "";
var shopItems = [];
var shopCost = {};
var shopNumber = [];
var currentRewards = [];
var moveSelectionUp;
var moveSelectionDown;
var abilityProperty;
var viewingAbility = 'none';
var homePixelRatio = window.devicePixelRatio;
var troop;
var staminaAbilities;
var thaumaturgyAbilities;
const increaseBase = 1.1;
const decreaseBase = 0.9;
const majorIncreaseBase = 1.5;
var stamina, force, hitpoints, physical;

//variables for mods

var levelBonus = 0.02;
var weaponMultipliers = [
    {type: 'Damage', increase: 0.015, slot: 'Weapon Mod', src: "damageMod", description: 'Increases weapon damage by INCREASE'},
    {type: 'Quick Fire', decrease: 0.025, slot: 'Weapon Mod', src: "QuickFireMod", description: 'Decreases the delay before using the weapon after equipping it, blocking, or attacking and and decreases the delay before the weapon is fired once shooting begins by DECREASE'},
];
var meleeMultipliers = [
    {type: 'Power', increase: 0.025, slot: 'Melee Mod', src: "powerMod", description: 'Increases the radius of attacks and the ammount hit enmies are knocked back by INCREASE'},
    {type: 'Deflection', increase: 0.025, slot: 'Melee Mod', src: "deflectionMod", description: 'Enhances the weapon\'s ability to deflect Plasmablade strikes. Increases the defelction angle and the knockback, stun, and stamina drain of blocked enemies by INCREASE'},
    {type: 'Reflection', increase: 0.025, slot: 'Melee Mod', src: "reflectionMod", description: 'Enhances the weapon\'s ability to reflect projectiles. Increases the reflection angle,accuracy, and range of reflecting by INCREASE'},
    {type: 'Usage Speed', increase: 0.025, slot: 'Melee Mod', src: "usageSPeedMod", description: 'Reduces the wait time after blocking or striking by INCREASE and reduces the minimum time that must be spent blocking'},
    {type: 'Slightness', increase: 0.25, slot: 'Melee Mod', src: "slightnessMod", description: "Increases the slightness of the weapon, decreasing the cost to use it by INCREASE"},
    {type: 'Parry', increase: 0.025, slot: 'Melee Mod', src: "parryMod", description: 'Increases the time in which parrying is possible at the start of blocking by INCREASE'},
];
var rangedMultipliers = [
    {type: 'Firing Speed', decrease: 0.025, slot: 'Ranged Mod', src: "firingSpeedMod", description: 'Decreases the delay between firing by DECREASE'},
    {type: 'Maximum Spread', decrease: 0.025, slot: 'Ranged Mod', src: "spreadMod", description: 'Decreases weapon spread by DECREASE'},
    {type: 'Projectile Speed', increase: 0.025, slot: 'Ranged Mod', src: "projectileSpeedMod", description: 'Increases weapon range by INCREASE'},
    {type: 'Cooling Power', increase: 0.025, slot: 'Ranged Mod', src: "coolingPowerMod", description: 'Increases the speed at which the weapon cools'},
    {type: 'Maximum Heat', increase: 0.025, slot: 'Ranged Mod', src: "maxHeatMod", description: 'Increases the weapon\'s maximum heat by INCREASE'},
    {type: 'Range', increase: 0.025, slot: 'Ranged Mod', src: "rangeMod", description: 'Increases weapon range by INCREASE'},
];
var armourMultipliers = [
    {type: 'Defense', increase: 0.015, slot: 'Armour Mod', src: "defenseMod", description: 'Increases the defense of armour by INCREASE'},
    {type: 'Weight', decrease: 0.025, slot: 'Armour Mod', src: "weightMod", description: 'Decreases the weight of armour by DECREASE'}, 
    {type: 'Stamina Recovery', increase: 0.015, slot: 'Armour Mod', src: "chargeMod", description: 'Increases the Stamina recovery of armour by INCREASE'},
    {type: 'Thaumaturgy Recovery', increase: 0.015, slot: 'Armour Mod', src: "chargeMod", description: 'Increases the Thaumaturgy recovery of armour by INCREASE'},
    {type: 'Health Recovery', increase: 0.015, slot: 'Armour Mod', src: "chargeMod", description: 'Increases the Health recovery of armour by INCREASE'},           
];
var allMods = [].concat(armourMultipliers, rangedMultipliers, meleeMultipliers, weaponMultipliers);
var modTraits = [
    {
        chance: 2, options: [
            {id: 'Thaumaturgy Critical Chance', increase: 0.05, available: 'Weapon Mod', description: 'Increases chance to score a critical hit with a Thaumaturgy attack by INCREASE'},
            {id: 'Thaumaturgy Critical Damage', increase: 0.1, available: 'Weapon Mod', description: 'Increases damage dealt upon landing a critical hit with a Thaumaturgy attack by INCREASE'},
            {id: 'Thaumaturgy Critical Resistance', increase: 0.05, available: 'Armour Mod', description: 'Decresased chance of taking a critical hit from a Thaumaturgy attack by INCREASE'},
            {id: 'Thaumaturgy Critical Defense', increase: 0.1, available: 'Armour Mod', description: 'Decreases extra damage taken on a critical hit from a Thaumaturgy attack by INCREASE'},
            {id: 'Thaumaturgy Evasion Chance', increase: 0.05, available: 'Armour Mod', description: 'Increases chance to evade Thaumaturgy attacks and take less damage from them by INCREASE'},
            {id: 'Thaumaturgy Evasion Defense', increase: 0.1, available: 'Armour Mod', description: 'Increases damage avoided upon avading Thaumaturgy attacks by INCREASE'},
            {id: 'Thaumaturgy Accuracy', increase: 0.05, available: 'Weapon Mod', description: 'Decreases chance of Thaumaturgy attacks being evaded by enemies by INCREASE'},
            {id: 'Thaumaturgy Accuracy Damage', increase: 0.1, available: 'Weapon Mod', description: 'Increases damage dealt by INCREASE when Thaumaturgy attacks are evaded'},
            {id: 'Thaumaturgy Precision', increase: 0.15, available: 'Weapon Mod', description: 'Decreases the effectiveness of enemy armour by INCREASE when taking damage from Thaumaturgy attacks'},
            {id: 'Stamina Critical Chance', increase: 0.05, available: 'Weapon Mod', description: 'Increases chance to score a critical hit with a Stamina attack by INCREASE'},
            {id: 'Stamina Critical Damage', increase: 0.1, available: 'Weapon Mod', description: 'Increases damage dealt upon landing a critical hit by INCREASE with a Stamina attack'},
            {id: 'Stamina Critical Resistance', increase: 0.05, available: 'Armour Mod', description: 'Decresases chance of taking a critical hit from a Stamina attack by INCREASE'},
            {id: 'Stamina Critical Defense', increase: 0.1, available: 'Armour Mod', description: 'Decreases extra damage taken on a critical hit from a Stamina attack by INCREASE'},
            {id: 'Stamina Evasion Chance', increase: 0.05, available: 'Armour Mod', description: 'Increases chance to evade Stamina attacks and take less damage from them by INCREASE'},
            {id: 'Stamina Evasion Defense', increase: 0.1, available: 'Armour Mod', description: 'Increases damage avoided upon avading Stamina attacks by INCREASE'},
            {id: 'Stamina Accuracy', increase: 0.05, available: 'Weapon Mod', description: 'Decreases chance of Stamina attacks being evaded by enemies by INCREASE'},
            {id: 'Stamina Accuracy Damage', increase: 0.1, available: 'Weapon Mod', description: 'Increases damage dealt by INCREASE when Stamina attacks are evaded'},
            {id: 'Stamina Precision', increase: 0.15, available: 'Weapon Mod', description: 'Decreases the effectiveness of enemy armour by INCREASE when taking damage from Stamina attacks'},
            {id: 'Physical Critical Chance', increase: 0.05, available: 'Weapon Mod', description: 'Increases chance to score a critical hit by INCREASE with a ranged or melee attack'},
            {id: 'Physical Critical Damage', increase: 0.1, available: 'Weapon Mod', description: 'Increases damage dealt upon landing a critical hit by INCREASE with a ranged or melee attack'},
            {id: 'Physical Critical Resistance', increase: 0.05, available: 'Armour Mod', description: 'Decresased chance of taking a critical hit by INCREASE from a ranged or melee attack'},
            {id: 'Physical Critical Defense', increase: 0.1, available: 'Armour Mod', description: 'Decreases extra damage taken on a critical hit by INCREASE from a ranged or melee attack'},
            {id: 'Physical Evasion Chance', increase: 0.05, available: 'Armour Mod', description: 'Increases chance to evade ranged and melee attacks and take less damage from them by INCREASE'},
            {id: 'Physical Evasion Defense', increase: 0.1, available: 'Armour Mod', description: 'Increases damage avoided upon evading ranged and melee attacks by INCREASE'},
            {id: 'Physical Accuracy', increase: 0.05, available: 'Weapon Mod', description: 'Decreases chance of ranged and melee attacks being evaded by enemies by INCREASE'},
            {id: 'Physical Accuracy Damage', increase: 0.1, available: 'Weapon Mod', description: 'Increases damage dealt when ranged and melee attacks are evaded by INCREASE'},
            {id: 'Physical Precision', increase: 0.15, available: 'Weapon Mod', description: 'Decreases the effectiveness of enemy armour by INCREASE when taking damage from ranged and melee attacks'},
            {id: 'Ranged Defense', increase: 0.1, available: 'Armour Mod', description: 'Increases defense against Raged Weapons by INCREASE'},
            {id: 'Melee Defense', increase: 0.1, available: 'Armour Mod', description: 'Increases defense against Melee Weapons by INCREASE'},
        ]
    },
    {
        chance: 5, options: [
            {id: 'Max Health', increase: 0.1, available: 'any', description: 'Increases Maximum Health by INCREASE'},
            {id: 'Max Stamina', increase: 0.1, available: 'any', description: 'Increases Maximum Stamina by INCREASE'},
            {id: 'Max Thaumaturgy', increase: 0.1, available: 'any', description: 'Increases Maximum Thaumaturgy by INCREASE'},
            {id: 'Health Recovery', increase: 0.025, available: 'any', description: 'Increases speed of Health Recovery by INCREASE'},
            {id: 'Stamina Recovery', increase: 0.025, available: 'any', description: 'Increases speed of Stamina Recovery by INCREASE'},
            {id: 'Thaumaturgy Recovery', increase: 0.025, available: 'any', description: 'Increases speed of Health Recovery by INCREASE'},
            {id: 'Health Delay', decrease: 0.15, available: 'any', description: 'Decreases delay before Health Recovery by DECREASE'},
            {id: 'Stamina Delay', decrease: 0.15, available: 'any', description: 'Decreases delay before Stamina Recovery by DECREASE'},
            {id: 'Thaumaturgy Delay', decrease: 0.15, available: 'any', description: 'Decreases delay before Health Recovery by DECREASE'},
        ]
    },
    {
        chance: 3, options: [               
            {id: 'Stamina Defense', increase: 0.1, available: 'Armour Mod', description: 'Increases defense by INCREASE against Stamina attacks'},
            {id: 'Thaumaturgy Defense', increase: 0.1, available: 'Armour Mod', description: 'Increases defense by INCREASE against Thaumaturgy attacks'},
            {id: 'Physical Defense', increase: 0.1, available: 'Armour Mod', description: 'Increases defense by INCREASE against Physical attacks'},
            {id: 'Stamina Damage', increase: 0.1, available: 'Weapon Mod', description: 'Increases damage of Stamina attacks by INCREASE'},
            {id: 'Thaumaturgy Damage', increase: 0.1, available: 'Weapon Mod', description: 'Increases damage of Thaumaturgy attacks by INCREASE'},
            {id: 'Physical Damage', increase: 0.1, available: 'Weapon Mod', description: 'Increases damge of Physical attacks by INCREASE'},   
            {id: 'Stamina Activation Time', increase: 0.1, available: 'Weapon Mod', description: 'Increases the decrease to the activation time of Stamina effects by INCREASE'},
            {id: 'Thaumaturgy Activation Time', increase: 0.1, available: 'Weapon Mod', description: 'Increases the decrease to the activation time of Thaumaturgy effects by INCREASE'},
            {id: 'Stamina Duration', increase: 0.1, available: 'Weapon Mod', description: 'Increases the duration of Stamina effects by INCREASE'},
            {id: 'Thaumaturgy Duration', increase: 0.1, available: 'Weapon Mod', description: 'Increases the duration of Thaumaturgy effects by INCREASE'},
            {id: 'Stamina Cooldown', increase: 0.1, available: 'Weapon Mod', description: 'Increases the decrease to the cooldown of Stamina effects by INCREASE'},
            {id: 'Thaumaturgy Cooldown', increase: 0.1, available: 'Weapon Mod', description: 'Increases the decrease to the cooldown of Thaumaturgy effects by INCREASE'},
            {id: 'Stamina Tenacity', increase: 0.1, available: 'Armour Mod', description: 'Decreases the duration of enemy Stamina effects by INCREASE'},
            {id: 'Thaumaturgy Tenacity', increase: 0.1, available: 'Armour Mod', description: 'Decreases the duration of enemy Thaumaturgy effects by INCREASE'},
        ]
    },
    {
        chance: 1, options: [
            {id: 'Stealth Radius', decrease: 0.2, available: 'Armour Mod', description: 'Decreases radius in which stealth is visible to enemies by DECREASE'},
            {id: 'Stealth Detection', increase: 0.2, available: 'Armour Mod', description: 'Increases  radius of revealing stealthed enemies by INCREASE'},
            {id: 'Movement Speed', increase: 0.03, available: 'any', description: 'Increases movement speed by INCREASE'},
            {id: 'Health on Damage', increase: 0.05, available: 'Weapon Mod', description: 'Increases Health gained as a percent of damage dealt by INCREASE'},
            {id: 'Stamina on Damage', increase: 0.05, available: 'Weapon Mod', description: 'Increases Stamina gained as a percent of damage dealt by INCREASE'},
            {id: 'Thaumaturgy on Damage', increase: 0.05, available: 'Weapon Mod', description: 'Increases Thaumaturgy gained as a percent of damage dealt by INCREASE'},
            {id: 'Health on Kill', increase: 0.05, available: 'Weapon Mod', description: 'Increases Health upon killing by INCREASE'},
            {id: 'Stamina on Kill', increase: 0.05, available: 'Weapon Mod', description: 'Increases Stamina upon killing by INCREASE'},
            {id: 'Thaumaturgy on Kill', increase: 0.05, available: 'Weapon Mod', description: 'Increases Thaumaturgy upon killing by INCREASE'},
            {id: 'Stamina Drain', increase: 0.05, available: 'Weapon Mod', description: 'Increases Stamina lost by enemies upon damaging them by INCREASE'},
            {id: 'Thaumaturgy Drain', increase: 0.05, available: 'Weapon Mod', description: 'Increases Thaumaturgy lost by enemies upon damaging them by INCREASE'},
            {id: 'Health Drain', increase: 0.05, available: 'Weapon Mod', description: 'Increases damage dealt based on a percent of the enemy\'s health by INCREASE'},
            {id: 'Knockback Resistance', increase: 0.1, available: 'any', description: 'Increases Knockback Resistance by INCREASE'},
            {id: 'Acceleration', decrease: 0.1, available: 'any', description: 'Decreases time needed to fully accelerate by DECREASE'},
            {id: 'Deceleration', decrease: 0.1, available: 'any', description: 'Decreases time needed to fully decelerate by DECREASE'},
        ]
    },
]
//armour variables
var helmets = [];
var bodies = [];
var legs = [];
var rightArms = [];
var leftArms = [];
var armour = [];

//weapon variables;
var rangedWeapons = [];
var meleeWeapons = [];

//variables for client's character
var username;
var password;
var pageLocation = "https://thunderwarrior.org";
var signOutOther = false;
var equipment;

runGame();

function runGame() {
    window.onload = () => loadGame();
    window.onunload = () => unloadGame();
}

function loadGame() {
    let win = document.getElementById("iframe").contentWindow;
    win.postMessage('getAccount', 'https://thunderwarrior.org');
    window.onmessage = (event) => {
        if(event.origin != "https://thunderwarrior.org") return;
        let message = JSON.parse(event.data);
        username = message.username;
        password = message.password;
        pageLocation = message.pageLocation || pageLocation;
        signOutOther = message.signOutOther || signOutOther;
        sessionStorage.setItem("username", username);
        sessionStorage.setItem("password", password);
        if(username == "" || username == undefined || password == "" || password == undefined) {
            totalRedirect('noAccountFound');
        } else {
            document.getElementById("iframe").remove();
            load();
        }
    }
}


function unloadGame() {
    totalRedirect('disconnection');
}

function load() {
    if (!window.WebSocket) {
        let msg = ("This browser does not support this game. Try updaing your browser.")
        console.error(msg);
        alert(msg);
        return;
    } else {
        createWebSocket("gameMenu");
    }
}

function loadAll(user, options, other) {
    troop = user;
    troop.password = password;
    rejoinGame(other.inGame);
    document.getElementById("loadStatus").innerText = "Loading Game";
    setOptions(options);
    setDefaultTrooperValues();
    loadEquipment();
    setImageDisplays();
    constructAbilities();
    createAllImages();
}

function constructAbilities (){
    let staminaCostMult = 20;
    let thaumaturgyCostMult = 10;
    let damageMult = 20;
    staminaAbilities = [
        {name: 'Bound', refrence: "Jump", activationTime: 0.2, duration: 0, cooldown: 2, solo: false, staminaCost: 25, thaumaturgyCost: 0, ultimate: false, class: "Mobility", subclass: "Jump", unlockCost: 1, creditCost: 2500, prerequisites: [], abilityType: "stamina", description: 'Propell into the air to travel great distances both vertically and horizontally'},
            {name: 'Sprint', refrence: "Run", activationTime: 0.15, duration: "Until Released", cooldown: 1, solo: false, staminaCost: 15, staminaDrain: 7.5, thaumaturgyCost: 0, ultimate: false, class: "Mobility", subclass: "Run", unlockCost: 1, creditCost: 3000, prerequisites: ["Bound"], abilityType: "stamina", description: 'Double movement speed for as long as the ability is being activated. Drains stamina over time.'},
                {name: 'Expeditiouse Retreat', refrence: "ExpeditiouseRetreat", activationTime: 0.15, duration: "Until Released", cooldown: 7, solo: false, staminaCost: 20, staminaDrain: 25, thaumaturgyCost: 0, ultimate: false, class: "Mobility", subclass: "Run", unlockCost: 1, creditCost: 3500, prerequisites: ["Sprint"], abilityType: "stamina", description: 'Increase movement speed by 150% and defense by 25% for as long as the ability is being activated. Drains stamina over time.'},
                    {name: 'Accelerating Dart', refrence: "SpeedRun", activationTime: 1, duration: "Until Released", cooldown: 3, solo: false, staminaCost: 10, staminaDrain: 2.5, thaumaturgyCost: 0, ultimate: false, class: "Mobility", subclass: "Run", unlockCost: 2, creditCost: 4000, prerequisites: ["Expeditiouse Retreat"], abilityType: "stamina", description: 'Increase movement speed by for long as the ability is being activated. Initially increase movement speed by 25%. Over the course of 12 seconds, this changes to increasing the movement speed by 400%. Drains stamina over time.'},
                {name: 'Speed', refrence: "Speed", activationTime: 1, duration: 5, cooldown: 15, solo: false, staminaCost: 17.5, thaumaturgyCost: 0, ultimate: false, class: "Mobility", subclass: "Boost", unlockCost: 2, creditCost: 3500, prerequisites: ["Bound"], abilityType: "stamina", description: 'Increase movement speed by 100% for <prop>duration</prop> seconds'},
                    {name: 'Dash', refrence: "Dash", activationTime: 0.1, duration: 0.75, cooldown: 10, solo: false, staminaCost: 12.5, thaumaturgyCost: 7.5, ultimate: false, class: "Mobility", subclass: "Boost", unlockCost: 2, creditCost: 4500, prerequisites: ["Speed", "Sprint"], abilityType: "stamina", description: 'Gain a brief burst of speed. Increase movement speed by 600% for <prop>duration</prop> seconds'},
                {name: 'Launch', refrence: "Launch", activationTime: 1.5, duration: 0, cooldown: 25, solo: false, staminaCost: 35, thaumaturgyCost: 5, ultimate: false, class: "Mobility", subclass: "Jump", unlockCost: 2, creditCost: 4000, prerequisites: ["Bound"], abilityType: "stamina", description: 'Launch upwards into the air. '},
                    {name: 'Leap', refrence: "Leap", activationTime: 0.5, duration: 0, cooldown: 20, solo: false, staminaCost: 30, thaumaturgyCost: 0, ultimate: false, class: "Mobility", subclass: "Jump", unlockCost: 2, creditCost: 5000, prerequisites: ["Launch", "Sprint"], abilityType: "stamina", description: 'Leap forwards, quickly travelling massive distances'},
        {name: 'Change Weapon', refrence: "ChangeWeapon", activationTime: 0, duration: 0, cooldown: 10, solo: false, staminaCost: 22, thaumaturgyCost: 0, ultimate: false, class: "Saber", subclass: "Utility", unlockCost: 1, creditCost: 2000, prerequisites: [], abilityType: "stamina", description: 'Switch weapons between a ranged weapon and a melee weapon'},
            {name: 'Flurry Of Blows', refrence: "FlurryOfBlows", activationTime: 0.8, duration: 8.5, cooldown: 29, solo: false, staminaCost: 27, thaumaturgyCost: 2.5, ultimate: false, class: "Saber", subclass: "Offense", unlockCost: 1, creditCost: 3000, prerequisites: ["Change Weapon"], abilityType: "stamina", description: 'Increase melee speed by 75% for <prop>duration</prop> seconds'},
                {name: 'Power Strike', refrence: "PowerStrike", activationTime: 0.3, duration: "Melee Speed", cooldown: 17.5, effectDuration: 3.5, solo: false, staminaCost: 26, thaumaturgyCost: 0, staminaDamage: 10, strikeCount: 1, damageMult: 1.25, radiusMult: 1.4, knockbackMult: 1.6, cooldownMult: 0.85, critChanceMult: 0.8, critDamageMult: 1.6, accuracyChanceMult: 0.9, accuracyDamageMult: 0.3, precisionMult: 0.7, costMult: 1.5, ultimate: false, class: "Saber", subclass: "Strike", unlockCost: 1, creditCost: 4000, prerequisites: ["Flurry Of Blows"], abilityType: "stamina", description: 'Make a powerful strike that deals increased damage and slows enemies for <prop>effectDuration</prop> seconds'}, 
                    {name: 'Bleed Strike', refrence: "BleedStrike", activationTime: 0.5, duration: "Melee Speed", effectDamage: 100, effectDuration: 4, cooldown: 20, solo: false, staminaCost: 24, thaumaturgyCost: 0, staminaDamage: 5, strikeCount: 2, damageMult: 1.3, radiusMult: 1.2, knockbackMult: 0.8, cooldownMult: 0.9, critChanceMult: 1.1, critDamageMult: 1.15, accuracyChanceMult: 1.1, accuracyDamageMult: 1.05, precisionMult: 1.75, costMult: 1.1, ultimate: false, class: "Saber", subclass: "Strike", unlockCost: 2, creditCost: 4500, prerequisites: ["Power Strike"], abilityType: "stamina", description: 'Make two deadly strikes that cause an enemy thunder warrior to take <prop>effectDamage</prop> damage each second for <prop>effectDuration</prop> seconds'}, 
                    {name: 'Critical Strike', refrence: "CriticalStrike", activationTime: 0.2, duration: "Melee Speed", cooldown: 15, effectDuration: 7, solo: false, staminaCost: 22, thaumaturgyCost: 0, staminaDamage: 7.5, strikeCount: 2, damageMult: 1.2, radiusMult: 1.15, knockbackMult: 0.9, cooldownMult: 0.8, critChanceMult: 1.9, critDamageMult: 1.4, accuracyChanceMult: 1.4, accuracyDamageMult: 1.6, precisionMult: 1.1, costMult: 0.8, ultimate: false, class: "Saber", subclass: "Strike", unlockCost: 2, creditCost: 4750, prerequisites: ["Power Strike"], abilityType: "stamina", description: 'Make a series of two strikes that expose enemies by 67% for <prop>effectDuration</prop> seconds and have increased critical capabilities'}, 
                    {name: 'Swift Strike', refrence: "SwiftStrike", activationTime: 0.25, duration: "Melee Speed", cooldown: 25, effectDuration: 3, solo: false, staminaCost: 28, thaumaturgyCost: 0, staminaDamage: 2.5, strikeCount: 4, damageMult: 0.6, radiusMult: 0.9, knockbackMult: 0.5, cooldownMult: 0.5, critChanceMult: 0.9, critDamageMult: 0.85, accuracyChanceMult: 0.95, accuracyDamageMult: 0.75, precisionMult: 0.95, costMult: 0.6, ultimate: false, class: "Saber", subclass: "Strike", unlockCost: 2, creditCost: 5000, prerequisites: ["Power Strike"], abilityType: "stamina",description: 'Make an extensive combo of four strikes that weaken enemies by 70% for <prop>effectDuration</prop> seconds'}, 
            {name: 'Traditional Block', refrence: "SimpleBlock", activationTime: 0, duration: "Until Released", cooldown: 10, solo: false, staminaCost: 0, thaumaturgyCost: 0, costMult: 1, drainMult: 1, parryTotalTimeMult: 1, canBlockThaum: false, ultimate: false, class: "Saber", subclass: "Block", unlockCost: 1, creditCost: 3500, prerequisites: ["Change Weapon"], abilityType: "stamina", description: 'Block incoming projectiles and strikes, with the option to parry, redirecting attacks at their source.'},
                {name: 'Thaumaturgy Block', refrence: "ThaumBlock", activationTime: 0, duration: "Until Released", cooldown: 5, solo: false, staminaCost: 0, thaumaturgyCost: 3, costMult: 1.25, drainMult: 1.5, parryTotalTimeMult: 0, canBlockThaum: true, ultimate: false, class: "Saber", subclass: "Block", unlockCost: 2, creditCost: 4500, prerequisites: ["Traditional Block"], abilityType: "stamina", description: 'Block incoming projectiles and strikes as well as thaumaturgy attacks, but unable to parry'},
                    {name: 'Parrying Thaumaturgy Block', refrence: "ThaumBlockParry", activationTime: 0, duration: "Until Released", cooldown: 30, solo: false, staminaCost: 0, costMult: 1.5, drainMult: 2, parryTotalTimeMult: 0.5, canBlockThaum: true, thaumaturgyCost: 12, ultimate: false, class: "Saber", subclass: "Block", unlockCost: 3, creditCost: 5500, prerequisites: ["Thaumaturgy Block", "Swift Strike"], abilityType: "stamina", description: 'Block incoming projectiles and strikes as well as thaumaturgy attacks, with the possibility to parry, redirecting attacks at their source'},
        {name: 'Heal', refrence: "Heal", activationTime: 2, duration: 0, cooldown: 90, solo: false, staminaCost: 50, thaumaturgyCost: 5, ultimate: false, class: "Combat", subclass: "Heal", unlockCost: 1, creditCost: 5000, prerequisites: [], abilityType: "stamina", description: 'Heal your thunder warrior for 100 health'},
                {name: 'Oneness', refrence: "Oneness", activationTime: 6, duration: 24, cooldown: 52, solo: false, staminaCost: 40, thaumaturgyCost: 1, ultimate: false, class: "Combat", subclass: "Buff", unlockCost: 1, creditCost: 3500, prerequisites: ["Heal"], abilityType: "stamina", description: 'Attain oneness with the universe and reduce weight by 50%'},
                        {name: 'Preparation', refrence: "Preparation", activationTime: 15, duration: 10, cooldown: 38, solo: false, staminaCost: 45, thaumaturgyCost: 1.5, ultimate: false, class: "Combat", subclass: "Buff", unlockCost: 2, creditCost: 4250, prerequisites: ["Oneness"], abilityType: "stamina", description: 'Prepare for the oncoming battle, gaining massive boosts in every area after a large activation time'},
            {name: 'Heal Over Time', refrence: "HealOverTime", activationTime: 2, duration: 10, cooldown: 75, solo: false, staminaCost: 35, thaumaturgyCost: 3.5, ultimate: false, class: "Combat", subclass: "Heal", unlockCost: 2, creditCost: 4500, prerequisites: ["Heal"], abilityType: "stamina", description: 'Heal for 25 health every second for <prop>duration</prop> seconds'},
                {name: 'Defensive', refrence: "Defensive", activationTime: 0.6, duration: 8, cooldown: 17, solo: false, staminaCost: 30, thaumaturgyCost: 0, ultimate: false, class: "Combat", subclass: "Defense", unlockCost: 1, creditCost: 4000, prerequisites: ["Heal Over Time", "Oneness"], abilityType: "stamina", description: 'Increase defense by 50% for <prop>duration</prop> seconds'},
                    {name: 'Shield', refrence: "Shield", activationTime: 0, duration: 2, cooldown: 23, solo: false, staminaCost: 28, thaumaturgyCost: 0, ultimate: false, class: "Combat", subclass: "Defense", unlockCost: 3, creditCost: 5500, prerequisites: ["Defensive"], abilityType: "stamina", description: 'Gain a frief, eyt massive boost to durability. Increase defense by 200% for <prop>duration</prop> seconds'},
            {name: 'Fast Fire', refrence: "FastFire", activationTime: 4, duration: 12, cooldown: 32, solo: false, staminaCost: 26, thaumaturgyCost: 1.5, ultimate: false, class: "Combat", subclass: "Offense", unlockCost: 1, creditCost: 3000, prerequisites: ["Heal"], abilityType: "stamina", description: 'Increase firing speed of ranged weapons by 100% for <prop>duration</prop> seconds'},
                {name: 'Annihilation', refrence: "Annihilation", activationTime: 0.5, duration: 7, cooldown: 35, solo: false, staminaCost: 32, thaumaturgyCost: 0, ultimate: false, class: "Combat", subclass: "Offense", unlockCost: 3, creditCost: 6000, prerequisites: ["Fast Fire"], abilityType: "stamina", description: 'Increase damage output by 30% for <prop>duration</prop> seconds'},    
                    {name: 'Snipe Shot', refrence: "SnipeShot", activationTime: 0.25, duration: 0, cooldown: 32, solo: false, staminaCost: 19, thaumaturgyCost: 0, staminaDamage: 8, shotCount: 1, damageMult: 1.5, critChanceMult: 1.5, critDamageMult: 1.35, accuracyChanceMult: 1.4, accuracyDamageMult: 1.6, precisionMult: 1.2, rangeMult: 2, speedMult: 1.6, spreadMult: 0.7, costMult: 2, firingSpeedMult: 1.45, ultimate: false, class: "Combat", subclass: "Shot", unlockCost: 2, creditCost: 4500, prerequisites: ["Annihilation"], abilityType: "stamina", description: 'Take an enhanced shot dealing increased damage and with increased range'},
                {name: 'Triple Shot', refrence: "TripleShot", activationTime: 0.35, duration: 0, cooldown: 23, solo: false, staminaCost: 21.5, thaumaturgyCost: 0, staminaDamage: 4, shotCount: 3, damageMult: 1.25, critChanceMult: 1.75, critDamageMult: 1.9, accuracyChanceMult: 1.2, accuracyDamageMult: 1.1, precisionMult: 1.3, rangeMult: 1.15, speedMult: 1.4, spreadMult: 0.8, costMult: 0.7, firingSpeedMult: 0.7, ultimate: false, class: "Combat", subclass: "Shot", unlockCost: 2, creditCost: 4000, prerequisites: ["Fast Fire"], abilityType: "stamina", description: 'Take a set of three shots with greatly enhanced criticality'},
                    {name: 'Burst Shot', refrence: "BurstShot", activationTime: 0.15, duration: 0, cooldown: 27, solo: false, staminaCost: 23, thaumaturgyCost: 0, staminaDamage: 2, shotCount: 10, damageMult: 0.25, critChanceMult: 0.8, critDamageMult: 0.6, accuracyChanceMult: 0.9, accuracyDamageMult: 0.3, precisionMult: 0.7, rangeMult: 0.6, speedMult: 0.65, spreadMult: 1.2, costMult: 0.2, firingSpeedMult: 0.25, ultimate: false, class: "Combat", subclass: "Shot", unlockCost: 2, creditCost: 4250, prerequisites: ["Triple Shot", "Annihilation"], abilityType: "stamina", description: 'Take a burst of 10 shots with higher firing speed and decreased heat build, but with decreased damage'},

    ]
    for(var i = 0; i < staminaAbilities.length; i ++) {
        staminaAbilities[i].staminaCost *= staminaCostMult;
    }
    for(var i = 0; i < staminaAbilities.length; i ++) {
        staminaAbilities[i].thaumaturgyCost *= thaumaturgyCostMult;
    }
thaumaturgyAbilities = [
    {name: 'Hover', refrence: "Hover", angle: 90, range: 14.5, activationTime: 0.5, duration: 0, effectDuration: 11, cooldown: 23, solo: false, staminaCost: 7, thaumaturgyCost: 4, ultimate: false, class: "Buff", subclass: "Movement", unlockCost: 1, creditCost: 2000, prerequisites: [], abilityType: "force", description: 'Decreases the weight by 50% and the fall speed by 75% of all allies within a <prop>angle</prop>&deg cone for <prop>effectDuration</prop> seconds'},
        {name: 'Speed Aura', refrence: "SpeedAura", angle: 360, range: 12.5, activationTime: 0.3, duration: 8, cooldown: 22, solo: false, staminaCost: 10, thaumaturgyCost: 6.5, ultimate: false, class: "Buff", subclass: "Movement", unlockCost: 1, creditCost: 3000, prerequisites: ["Hover"], abilityType: "force", description: 'Increases the swiftness of all allies within a <prop>angle</prop>&deg cone for <prop>duration</prop> seconds. THe movement speed, melee speed, and firing speed of all targets is increased by 50%.'},
            {name: 'Jump Boost', refrence: "JumpBoost", angle: 75, range: 13.5, activationTime: 0.3, duration: 0, effectDuration: 8, cooldown: 16, solo: false, staminaCost: 8.5, thaumaturgyCost: 4.5, ultimate: false, class: "Buff", subclass: "Movement", unlockCost: 1, creditCost: 4000, prerequisites: ["Speed Aura"], abilityType: "force", description: 'Increases the jump height by 50% of all allies within a <prop>angle</prop>&deg cone for <prop>effectDuration</prop> seconds'},
            {name: 'Swiftness', refrence: "Swiftness", angle: 75, range: 9.5, activationTime: 0.2, duration: 0, effectDuration: 6, cooldown: 15, solo: false, staminaCost: 15, thaumaturgyCost: 7, ultimate: false, class: "Buff", subclass: "Movement", unlockCost: 1, creditCost: 5000, prerequisites: ["Speed Aura"], abilityType: "force", description: 'Increases the movement speed of all allies within <prop>range</prop> U b 75% for <prop>effectDuration</prop> seconds.'},
        {name: 'Fortification', refrence: "Fortification", angle: 90, range: 11.5, activationTime: 0.9, duration: 0, effectDuration: 7, cooldown: 22.5, solo: false, staminaCost: 0, thaumaturgyCost: 9.5, ultimate: false, class: "Buff", subclass: "Defense", unlockCost: 2, creditCost: 3500, prerequisites: ["Hover"], abilityType: "force", description: 'Increases the defense of all allies within a <prop>angle</prop>&deg cone by 50% for <prop>effectDuration</prop> seconds.'},
            {name: 'Recovery', refrence: "Recovery", activationTime: 5, duration: 0, cooldown: 20, solo: false, staminaCost: 0, thaumaturgyCost: 7, ultimate: false, class: "Buff", subclass: "Support", unlockCost: 2, creditCost: 4500, prerequisites: ["Fortification"], abilityType: "force", description: 'Recover 500 stamina'},
                {name: 'Cool', refrence: "Cool", angle: 360, range: 11, activationTime: 0.25, duration: 0, cooldown: 28, effectDuration: 9.5, solo: false, staminaCost: 0, thaumaturgyCost: 11, ultimate: true, class: "Buff", subclass: "Support", unlockCost: 3, creditCost: 6000, prerequisites: ["Recovery"], abilityType: "force", description: 'Removes the heat from the weapons of allies within <prop>range</prop> U and decreases their heat build by by 75% for <prop>duration</prop> seconds.'},
            {name: 'Group Preparation', refrence: "GroupPrep", angle: 60, range: 9, activationTime: 8, duration: 0, effectDuration: 5, cooldown: 17.5, solo: false, staminaCost: 0, thaumaturgyCost: 12.5, ultimate: false, class: "Buff", subclass: "Support", unlockCost: 2, creditCost: 5000, prerequisites: ["Fortification"], abilityType: "force", description: 'Prepares all allies within a <prop>angle</prop>&deg cone, granting a massive boost in every area for <prop>effectDuration</prop> seconds.'},
                {name: 'HealAura', refrence: "HealAura", angle: 360, range: 9, activationTime: 1.25, duration: 9, cooldown: 26, solo: false, staminaCost: 0, thaumaturgyCost: 10.5, ultimate: false, class: "Buff", subclass: "Heal", unlockCost: 2, creditCost: 5500, prerequisites: ["Group Preparation"], abilityType: "force", description: 'Heals all allies within <prop>range</prop> U'},
    {name: 'Push', refrence: "Push", damage: 18, angle: 75, range: 7, activationTime: 0.3, duration: 0, cooldown: 13, solo: false, staminaCost: 6, thaumaturgyCost: 9.5, ultimate: false, class: "Combat", subclass: "Transpose", unlockCost: 1, creditCost: 2000, prerequisites: [], abilityType: "force", description: 'Pushes all opponents within a <prop>angle</prop>&deg cone, causing them to be knocked away.'},
        {name: 'Pull', refrence: "Pull", damage: 12, angle: 60, range: 9, activationTime: 0.2, duration: 0, cooldown: 15, solo: false, staminaCost: 8, thaumaturgyCost: 11.5, ultimate: false, class: "Combat", subclass: "Transpose", unlockCost: 1, creditCost: 3000, prerequisites: ["Push"], abilityType: "force", description: 'Pulls all opponents within a <prop>angle</prop>&deg cone, causing them to be knocked closer.'},
            {name: 'Life Drain', refrence: "LifeDrain", damage: 25, angle: 90, range: 12.5, activationTime: 0.3, duration: 0, cooldown: 24, solo: true, staminaCost: 0, thaumaturgyCost: 8, ultimate: false, class: "Combat", subclass: "Heal", unlockCost: 2, creditCost: 3500, prerequisites: ["Pull"], abilityType: "force", description: 'Drain the life of all opponets within a <prop>angle</prop>&deg cone, dealing damage and healing for 50% of the damage dealt.'},
                {name: 'Repulse', refrence: "Repulse", damage: 35, angle: 360, range: 14, activationTime: 0.175, duration: 2.5, cooldown: 32, solo: true, staminaCost: 12, thaumaturgyCost: 13, ultimate: true, class: "Combat", subclass: "Transpose", unlockCost: 3, creditCost: 5000, prerequisites: ["Life Drain"], abilityType: "force", description: 'Pulls enemies within <prop>range</prop> U closer, and then sends them flying away.'},
        {name: 'Weaken', refrence: "Weaken", damage: 22.5, angle: 75, range: 9, activationTime: 0.3, duration: 0, effectDuration: 7.5, cooldown: 21, solo: false, staminaCost: 0, thaumaturgyCost: 7.5, ultimate: false, class: "Control", subclass: "Debuff", unlockCost: 1, creditCost: 3000, prerequisites: ["Push"], abilityType: "force", description: 'Weaken all opponets within a <prop>angle</prop>&deg cone for <prop>effectDuration</prop> seconds. Each target deals  40% less damage.'}, 
            {name: 'Punish', refrence: "Punish", damage: 18, angle: 60, range: 10.5, activationTime: 0.65, duration: 0, effectDuration: 0, cooldown: 14, solo: true, staminaCost: 0, thaumaturgyCost: 7.5, ultimate: false, class: "Combat", subclass: "Damage", unlockCost: 1, creditCost: 4000, prerequisites: ["Weaken"], abilityType: "force", description: 'Deals <prop>damage</prop> to all enemies within a <prop>angle</prop>&deg cone.'},
                {name: 'Damage Aura', refrence: "DamageAura", effectDamage: 6, angle: 360, range: 12, activationTime: 1.5, duration: 10, cooldown: 40, solo: true, staminaCost: 0, thaumaturgyCost: 30, ultimate: true, class: "Combat", subclass: "Damage", unlockCost: 3, creditCost: 6000, prerequisites: ["Punish"], abilityType: "force", description: 'Deals <prop>effectDamage</prop> to and slows down by 70% all enemies within <prop>range</prop> U every second.'},
                {name: 'Expose', refrence: "Expose", damage: 20, angle: 45, range: 7.5, activationTime: 0.6, duration: 0, effectDuration: 6, cooldown: 22, solo: true, staminaCost: 0, thaumaturgyCost: 8, ultimate: false, class: "Combat", subclass: "Debuff", unlockCost: 2, creditCost: 5000, prerequisites: ["Punish"], abilityType: "force", description: 'Expose all opponets within a <prop>angle</prop>&deg cone for <prop>effectDuration</prop> seconds. Each target takes 30% more damage.'},
    {name: 'Tether', refrence: "Tether", damage: 17.5,  angle: 90, range: 12, activationTime: 0.4, duration: 0, effectDuration: 7, cooldown: 20, solo: false, staminaCost: 5, thaumaturgyCost: 5, ultimate: false, class: "Control", subclass: "Immobalize", unlockCost: 1, creditCost: 2000, prerequisites: [], abilityType: "force", description: 'Tether all opponets within a <prop>angle</prop>&deg cone for <prop>effectDuration</prop> seconds. The weight of each target is increased by 100% and their speed is decreased by an aditional 30%, decreasing their mobility.'},
        {name: 'Hold', refrence: "Hold", damage: 14, effectDamage: 1.5, angle: 90, range: 13, activationTime: 0.55, duration: 11, cooldown: 24, solo: true, staminaCost: 0, thaumaturgyCost: 12, ultimate: false, class: "Control", subclass: "Transpose", unlockCost: 2, creditCost: 3500, prerequisites: ["Tether"], abilityType: "force", description: 'Hold all opponets within a <prop>angle</prop>&deg cone for <prop>duration</prop> seconds. All targets are lifted off of the ground and can be moved around. Targets take <prop>effectDamage</prop> damage every second'},
            {name: 'Choke', refrence: "Choke", damage: 16, effectDamage: 3.5, angle: 75, range: 11, activationTime: 0.45, duration: 13, cooldown: 26, solo: true, staminaCost: 0, thaumaturgyCost: 13, ultimate: true, class: "Control", subclass: "Transpose", unlockCost: 3, creditCost: 5500, prerequisites: ["Hold"], abilityType: "force", description: 'Choke all opponets within a <prop>angle</prop>&deg cone for <prop>duration</prop> seconds. All choked targets are lifted off of the ground and pulled closer. Targets take <prop>effectDamage</prop> damage every second'},
        {name: 'Reversal', refrence: "Reversal", damage: 12,  angle: 360, range: 15, activationTime: 0.5, duration: 0, effectDuration: 6.5, cooldown: 35, solo: false, staminaCost: 0, thaumaturgyCost: 7, ultimate: false, class: "Control", subclass: "Immobalize", unlockCost: 1, creditCost: 2500, prerequisites: ["Tether"], abilityType: "force", description: 'Reverse all opponets within a <prop>range</prop> U for <prop>effectDuration</prop> seconds. The movement controls of each target are reversed'},
            {name: 'Confusion', refrence: "Confusion", damage: 10, angle: 75, range: 13, activationTime: 1, duration: 0, effectDuration: 4, cooldown: 23.5, solo: true, staminaCost: 0, thaumaturgyCost: 11 , ultimate: false, class: "Control", subclass: "Immobalize", unlockCost: 1, creditCost: 3500, prerequisites: ["Reversal"], abilityType: "force", description: 'Confuse all opponets within a <prop>angle</prop>&deg cone for <prop>effectDuration</prop> seconds. The movement controls of each target are randomly switched'},
            {name: 'Inspire Fear', refrence: "InspireFear", damage: 15,  angle: 90, range: 14, activationTime: 0.75, duration: 0, effectDuration: 5, cooldown: 26, solo: false, staminaCost: 0, thaumaturgyCost: 9, ultimate: false, class: "Control", subclass: "Immobalize", unlockCost: 1, creditCost: 3000, prerequisites: ["Reversal"], abilityType: "force", description: 'Inspire fear in all opponets within a <prop>angle</prop>&deg cone for <prop>effectDuration</prop> seconds. Each target moves runs backwards with 35% increased movement speed.'},
                {name: 'Mind Control', refrence: "MindControl", damage: 12.5, angle: 60, range: 23, activationTime: 0.25, duration: 16, cooldown: 60, solo: true, staminaCost: 0, thaumaturgyCost: 50, ultimate: true, class: "Control", subclass: "Domminance", unlockCost: 5, creditCost: 15000, prerequisites: ["Confusion", "Inspire Fear"], abilityType: "force", description: 'Take control of the minds of all opponets within a <prop>angle</prop>&deg cone for <prop>duration</prop> seconds. Control each of the targets: control their movement, attacks, and abilities, turning them on their allies!'},
        {name: 'Overheat', refrence: "Overheat", damage: 3, angle: 360, range: 8, activationTime: 0.75, duration: 0, effectDuration: 0, cooldown: 30, solo: true, staminaCost: 0, thaumaturgyCost: 10, ultimate: false, class: "Control", subclass: "Debuff", unlockCost: 2, creditCost: 4500, prerequisites: ["Tether"], abilityType: "force", description: 'Overheats the weapons of all enemies within <prop>range</prop> U.'},
            {name: 'Freeze', refrence: "Freeze", damage: 3.5, angle: 45, range: 6.5, activationTime: 0.6, duration: 0, effectDuration: 3, cooldown: 29, solo: true, staminaCost: 0, thaumaturgyCost: 12, ultimate: false, class: "Control", subclass: "Immobalize", unlockCost: 3, creditCost: 6500, prerequisites: ["Overheat"], abilityType: "force", description: 'Freezes in place all enemies within a <prop>angle</prop>&deg cone, preventing them from doing anything for <prop>effectDuration</prop> seconds.'},
];

    for(var i = 0; i < thaumaturgyAbilities.length; i ++) {
        thaumaturgyAbilities[i].staminaCost *= staminaCostMult;
    }
    for(var i = 0; i < thaumaturgyAbilities.length; i ++) {
        thaumaturgyAbilities[i].thaumaturgyCost *= thaumaturgyCostMult;
    }
    for(var i = 0; i < thaumaturgyAbilities.length; i ++) {
        if(thaumaturgyAbilities[i].damage != undefined) thaumaturgyAbilities[i].damage *= damageMult;
    }

}
function createAbilityOptions() {
    for(var i = 0; i < staminaAbilities.length; i ++) {
        createAbilityOption(staminaAbilities[i]);
    }
    for(var i = 0; i < thaumaturgyAbilities.length; i ++) {
        createAbilityOption(thaumaturgyAbilities[i]);
    }
}


//must be in new function for the onclick event to work
function createAbilityOption(ability) {
        let abilityOption = document.createElement("DIV");
        let abilityIcon = document.createElement("IMG");
        let abilityColor = document.createElement("DIV");
        let background = document.createElement("DIV");
        let pulse = document.createElement("DIV");
        background.classList.add("abilityUnlockedBackground");
        pulse.classList.add("abilityPulse");
        abilityOption.classList.add("abilityPageOption");
        abilityOption.id = getPageOptionName(ability.name);
        background.onclick = function() {
            setAbilities(ability, abilityOption, abilityIcon, abilityColor, false);
        }
        abilityIcon.onclick = function() {
            setAbilities(ability, abilityOption, abilityIcon, abilityColor, false);
        }
        pulse.onclick = function(e) {
            resetAbilities(false, e);
        }
        abilityColor.classList.add("abilityPageColor");
        if(unlocked(ability)) abilityOption.classList.add("unlocked");
        abilityIcon.classList.add("abilityPageIcon");
        abilityIcon.src = getSrc(ability);
        abilityOption.appendChild(abilityColor);
        abilityOption.appendChild(background);
        abilityOption.appendChild(pulse);
        abilityOption.appendChild(abilityIcon);
        if(ability.abilityType == "stamina") {
            document.getElementById('staminaAbilities').appendChild(abilityOption);
        } else {
            document.getElementById('thaumaturgyAbilities').appendChild(abilityOption);
       }
}
function setAllAbilityOptions() {
    let abilities = staminaAbilities.concat(thaumaturgyAbilities);
    let abilityOptions = document.getElementsByClassName("abilityPageOption");
    for(var i = 0; i < abilities.length; i ++) {
        if(unlocked(abilities[i])) abilityOptions[i].classList.add("unlocked");
    }
}
function purchaseSkillPoints() {
    purchaseResource(6, "skillPoints", [1, 5, 25], [50, 125, 250], ["skillPointsSmall", "skillPointsRegular", "skillPointsUltimate"], "Skill Points");
}
function purchaseCredits() {
    purchaseResource(7, "credits", [1000, 5000, 25000], [10, 25, 50], ["creditsSmall", "creditsRegular", "creditsUltimate"], "Credits");
}
function purchaseMetals() {
    purchaseResource(8, "metals", [5, 25, 125], [20, 50, 100], ["metalsSmall", "metalsRegular", "metalsUltimate"], "Metals");
}
function purchaseCrystals() {
    if(onPage == "classScreen") {

    } else {
        purchaseResource(9, "crystals", [100, 500, 100000], [1.99, 4.99, 9.99], ["crystalsSmall", "crystalsRegular", "crystalsUltimate"], "Crystals");
    }
}
function purchaseResource(idNumber, resource, values, costs, srcs, name) {
    showPurchasePage();
    setPurchaseHeaders(idNumber);
    showShopImages(resource, values, costs, srcs, name);
    setShopScreen();
}
function hidePage(){
    if(onPage == "weaponPage") {
        hideWeaponScreen();
    } else if(onPage == "abilityPage") {
        hideAbilityPage();
    } else if(onPage == "homeScreen") {
        hideHomeScreen();
    } else if (onPage == "shopScreen") {
        hideShopScreen();
    }
}
function showPurchasePage() {
    if(onPage != "shopScreen") {
        hidePage();
        onPage = "shopScreen";
        equipmentShopScreen();
    }
}

function showShopImages(resource, values, costs, srcs, name) {
    let shopCanvases = document.getElementsByClassName("purchaseOptions");
    setResourceOptionCursors(costs);
    shopDescription = "";
    shopItems = srcs;
    shopNames = name;
    shopCost = {crystals: costs};
    shopNumber = values;
    for(var i = 0; i < shopCanvases.length; i ++) {
        shopCanvases[i].style.visibility = "visible"; //"hidden"
        let cost = costs[i];
        let val = values[i];
        let purchaseName = ["Small Purchase", "Regular Purchase", "Ultimate Purchase"][i];
        shopCanvases[i].onclick = () => {
            if(resource == "crystals") {
                crystalPurchase(purchaseName, 100, "1.99");
            } else if(troop.resources.crystals >= cost) {
                troop.resources[resource] += val;
                troop.resources.crystals -= cost;
                updateResources();
                saveTraitToServer("resources");
                setResourceOptionCursors(costs);
                setShopScreen();
            } else {
                purchaseCrystals();
                tell(19, "Necessary Crystals Unavailable", "You do not have the Crystals necessary to make this transaction. Purchase more Crystals first.");
            }
        }
    }
}
function setShopOptionVisibility(shopCanvasVisibility) {
    let shopCanvases = document.getElementsByClassName("purchaseOptions");
    for(var i = 0; i < shopCanvases.length; i ++) {
        shopCanvases[i].style.visibility = shopCanvasVisibility;
    }
}

function unlocked(ability) {
    let abilities;
    if(troop.stamina == undefined || troop.force == undefined) return false;
    abilities = troop.stamina.abilities.concat(troop.force.abilities)
    for(var e = 0; e < abilities.length; e ++) {
        if(abilities[e].name == ability.name) {
            return true;
        }
    }
    return false;
}

function setImageDisplays() {
    var modCounter;
    var modsAvailable;
    let imageDisplays = document.getElementsByClassName('imageDisplay');
    for(var i = 0; i < imageDisplays.length; i ++) {
        modCounter = document.createElement("DIV");
        modsAvailable = document.createElement("DIV");
        imageDisplays[i].appendChild(modCounter);
        imageDisplays[i].appendChild(modsAvailable);
        modCounter.classList.add('smallModCounter');
        modCounter.classList.add('smallCounter');
        modsAvailable.classList.add('smallModsAvailable');
        modsAvailable.classList.add('smallCounter');
    }
}

function setOptions(options) {
    homePixelRatio = options.menuQuality || homePixelRatio;
}

function loadEquipment() { 
    var thunderWarriorHead = {defense: 2.5, weight: 9, class: "Defensive", set: 'Thunder Warrior', type: 'Thunder Warrior Helmet', description: 'Description', slot: 'Helmet', src: "basicHelmet", playerImage: true, refrence: "head",
        Stamina: {
            criticalResistance: 2.5,
            criticalDefense: 5,
            evasionChance: 5,
            evasionDefense: 15,
            defense: 5,
            tenacity: 7.5,
            regen: 2.5,
        },
        Thaumaturgy: {
            criticalResistance: 2,
            criticalDefense: 4,
            evasionChance: 4,
            evasionDefense: 12,
            defense: 4,
            tenacity: 6,
            regen: 2,
        },
        Health: {
            regen: 15,
        },
        Physical: {
            criticalResistance: 3.5,
            criticalDefense: 7,
            evasionChance: 7,
            evasionDefense: 14,
            defense: 7
        },
        rangedDefense: 3.5,
        meleeDefense: 2.5,
        stealthRadius: 2.5,
        stealthDetection: 1.75,
    };
    var thunderWarriorBody = { defense: 3, weight: 15, class: "Defensive", set: 'Thunder Warrior',  type: 'Thunder Warrior Torso', description: 'Decription', slot: 'Torso', src: "basicTorso", playerImage: true, refrence: "body",                Stamina: { criticalResistance: 2.5, criticalDefense: 5, evasionChance: 5, evasionDefense: 15, defense: 5, tenacity: 7.5, regen: 2.5, }, Thaumaturgy: { criticalResistance: 2, criticalDefense: 4, evasionChance: 4, evasionDefense: 12, defense: 4, tenacity: 6, regen: 2, }, Health: { regen: 15, }, Physical: { criticalResistance: 3.5, criticalDefense: 7, evasionChance: 7, evasionDefense: 14, defense: 15, }, rangedDefense: 3.5, meleeDefense: 2.5, stealthRadius: 2.5, stealthDetection: 1.75, };
    var thunderWarriorLegs = { defense: 2.5, weight: 12, class: "Defensive", set: 'Thunder Warrior', type: 'Thunder Warrior Legs', description: 'Description', slot: 'Legs', src: "basicLegs", playerImage: true, refrence: "legs",                 Stamina: { criticalResistance: 2.5, criticalDefense: 5, evasionChance: 5, evasionDefense: 15, defense: 5, tenacity: 7.5, regen: 2.5, }, Thaumaturgy: { criticalResistance: 2, criticalDefense: 4, evasionChance: 4, evasionDefense: 12, defense: 4, tenacity: 6, regen: 2, }, Health: { regen: 15, }, Physical: { criticalResistance: 3.5, criticalDefense: 7, evasionChance: 7, evasionDefense: 14, defense: 15, }, rangedDefense: 3.5, meleeDefense: 2.5, stealthRadius: 2.5, stealthDetection: 1.75, };
    var thunderWarriorRightArm = { defense: 2, weight: 7, class: "Defensive", set: 'Thunder Warrior', type: 'Thunder Warrior Right', description: 'Description', slot: 'Right Arm', src: "basicRightArm", playerImage: true, refrence: "rightArm",  Stamina: { criticalResistance: 2.5, criticalDefense: 5, evasionChance: 5, evasionDefense: 15, defense: 5, tenacity: 7.5, regen: 2.5, }, Thaumaturgy: { criticalResistance: 2, criticalDefense: 4, evasionChance: 4, evasionDefense: 12, defense: 4, tenacity: 6, regen: 2, }, Health: { regen: 15, }, Physical: { criticalResistance: 3.5, criticalDefense: 7, evasionChance: 7, evasionDefense: 14, defense: 15, }, rangedDefense: 3.5, meleeDefense: 2.5, stealthRadius: 2.5, stealthDetection: 1.75, };
    var thunderWarriorLeftArm = { defense: 2, weight: 7, class: "Defensive", set: 'Thunder Warrior', type: 'Thunder Warrior Left', description: 'Description', slot: 'Left Arm', src: "basicLeftArm", playerImage: true, refrence: "leftArm",       Stamina: { criticalResistance: 2.5, criticalDefense: 5, evasionChance: 5, evasionDefense: 15, defense: 5, tenacity: 7.5, regen: 2.5, }, Thaumaturgy: { criticalResistance: 2, criticalDefense: 4, evasionChance: 4, evasionDefense: 12, defense: 4, tenacity: 6, regen: 2, }, Health: { regen: 15, }, Physical: { criticalResistance: 3.5, criticalDefense: 7, evasionChance: 7, evasionDefense: 14, defense: 15, }, rangedDefense: 3.5, meleeDefense: 2.5, stealthRadius: 2.5, stealthDetection: 1.75, };

    var sithHead = {defense: 2.083, weight: 13.5, class: "Defensive", set: 'Sith', type: 'Sith Helmet', description: 'Description', slot: 'Helmet', src: "sithHelmet", playerImage: true, refrence: "head",                                         Stamina: { criticalResistance: 4, criticalDefense: 10, evasionChance: 3, evasionDefense: 7, defense: 3, tenacity: 3, regen: 0.5, }, Thaumaturgy: { criticalResistance: 8, criticalDefense: 18, evasionChance: 5, evasionDefense: 12, defense: 7, tenacity: 10, regen: 15, }, Health: { regen: 1.25, }, Physical: { criticalResistance: 5, criticalDefense: 12, evasionChance: 2, evasionDefense: 5, defense: 4, }, rangedDefense: 1.5, meleeDefense: 3, stealthRadius: 2, stealthDetection: 2.25};
    var sithBody = {defense: 2.5, weight: 22.5,class: "Defensive", set: 'Sith', type: 'Sith Torso', description: 'Decription', slot: 'Torso', src: "sithTorso", playerImage: true, refrence: "body",                                                Stamina: { criticalResistance: 4, criticalDefense: 10, evasionChance: 3, evasionDefense: 7, defense: 3, tenacity: 3, regen: 0.5, }, Thaumaturgy: { criticalResistance: 8, criticalDefense: 18, evasionChance: 5, evasionDefense: 12, defense: 7, tenacity: 10, regen: 15, }, Health: { regen: 1.25, }, Physical: { criticalResistance: 5, criticalDefense: 12, evasionChance: 2, evasionDefense: 5, defense: 4, }, rangedDefense: 1.5, meleeDefense: 3, stealthRadius: 2, stealthDetection: 2.25};
    var sithLegs = {defense: 2.083, weight: 18, class: "Defensive", set: 'Sith', type: 'Sith Legs', description: 'Description', slot: 'Legs', src: "sithLegs", playerImage: true, refrence: "legs",                                                 Stamina: { criticalResistance: 4, criticalDefense: 10, evasionChance: 3, evasionDefense: 7, defense: 3, tenacity: 3, regen: 0.5, }, Thaumaturgy: { criticalResistance: 8, criticalDefense: 18, evasionChance: 5, evasionDefense: 12, defense: 7, tenacity: 10, regen: 15, }, Health: { regen: 1.25, }, Physical: { criticalResistance: 5, criticalDefense: 12, evasionChance: 2, evasionDefense: 5, defense: 4, }, rangedDefense: 1.5, meleeDefense: 3, stealthRadius: 2, stealthDetection: 2.25};
    var sithRightArm = {defense: 1.667, weight: 10.5, class: "Defensive", set: 'Sith',  type: 'Sith Right', description: 'Description', slot: 'Right Arm', src: "sithRightArm", playerImage: true, refrence: "rightArm",                            Stamina: { criticalResistance: 4, criticalDefense: 10, evasionChance: 3, evasionDefense: 7, defense: 3, tenacity: 3, regen: 0.5, }, Thaumaturgy: { criticalResistance: 8, criticalDefense: 18, evasionChance: 5, evasionDefense: 12, defense: 7, tenacity: 10, regen: 15, }, Health: { regen: 1.25, }, Physical: { criticalResistance: 5, criticalDefense: 12, evasionChance: 2, evasionDefense: 5, defense: 4, }, rangedDefense: 1.5, meleeDefense: 3, stealthRadius: 2, stealthDetection: 2.25};
    var sithLeftArm = {defense: 1.667, weight: 10.5, class: "Defensive", set: 'Sith',  type: 'Sith Left', description: 'Description', slot: 'Left Arm', src: "sithLeftArm", playerImage: true, refrence: "leftArm",                                 Stamina: { criticalResistance: 4, criticalDefense: 10, evasionChance: 3, evasionDefense: 7, defense: 3, tenacity: 3, regen: 0.5, }, Thaumaturgy: { criticalResistance: 8, criticalDefense: 18, evasionChance: 5, evasionDefense: 12, defense: 7, tenacity: 10, regen: 15, }, Health: { regen: 1.25, }, Physical: { criticalResistance: 5, criticalDefense: 12, evasionChance: 2, evasionDefense: 5, defense: 4, }, rangedDefense: 1.5, meleeDefense: 3, stealthRadius: 2, stealthDetection: 2.25};

    var shadowHead = {defense: 1.25, weight: 5.4, class: "Defensive", set: 'Shadow', type: 'Shadow Helmet', description: 'Description', slot: 'Helmet', src: "shadowHelmet", playerImage: true, refrence: "head",                                   Stamina: { criticalResistance: 6, criticalDefense: 9, evasionChance: 15, evasionDefense: 25, defense: 6, tenacity: 8, regen: 15, }, Thaumaturgy: { criticalResistance: 2.5, criticalDefense: 3.5, evasionChance: 12.5, evasionDefense: 20, defense: 3, tenacity: 3, regen: 1.5, }, Health: { regen: 2, }, Physical: { criticalResistance: 5.5, criticalDefense: 9, evasionChance: 13.75, evasionDefense: 22.5, defense: 7, }, rangedDefense: 4, meleeDefense: 1.5, stealthRadius: 4.5, stealthDetection: 1.5, };
    var shadowBody = {defense: 1.5, weight: 9, class: "Defensive", set: 'Shadow', type: 'Shadow Torso', description: 'Decription', slot: 'Torso', src: "shadowTorso", playerImage: true, refrence: "body",                                          Stamina: { criticalResistance: 6, criticalDefense: 9, evasionChance: 15, evasionDefense: 25, defense: 6, tenacity: 8, regen: 15, }, Thaumaturgy: { criticalResistance: 2.5, criticalDefense: 3.5, evasionChance: 12.5, evasionDefense: 20, defense: 3, tenacity: 3, regen: 1.5, }, Health: { regen: 2, }, Physical: { criticalResistance: 5.5, criticalDefense: 9, evasionChance: 13.75, evasionDefense: 22.5, defense: 7, }, rangedDefense: 4, meleeDefense: 1.5, stealthRadius: 4.5, stealthDetection: 1.5, };
    var shadowLegs = {defense: 1.25, weight: 7.2, class: "Defensive", set: 'Shadow', type: 'Shadow Legs', description: 'Description', slot: 'Legs', src: "shadowLegs", playerImage: true, refrence: "legs",                                         Stamina: { criticalResistance: 6, criticalDefense: 9, evasionChance: 15, evasionDefense: 25, defense: 6, tenacity: 8, regen: 15, }, Thaumaturgy: { criticalResistance: 2.5, criticalDefense: 3.5, evasionChance: 12.5, evasionDefense: 20, defense: 3, tenacity: 3, regen: 1.5, }, Health: { regen: 2, }, Physical: { criticalResistance: 5.5, criticalDefense: 9, evasionChance: 13.75, evasionDefense: 22.5, defense: 7, }, rangedDefense: 4, meleeDefense: 1.5, stealthRadius: 4.5, stealthDetection: 1.5, };
    var shadowRightArm = {defense: 1, weight: 4.2, class: "Defensive", set: 'Shadow', type: 'Shadow Right', description: 'Description', slot: 'Right Arm', src: "shadowRightArm", playerImage: true, refrence: "rightArm",                          Stamina: { criticalResistance: 6, criticalDefense: 9, evasionChance: 15, evasionDefense: 25, defense: 6, tenacity: 8, regen: 15, }, Thaumaturgy: { criticalResistance: 2.5, criticalDefense: 3.5, evasionChance: 12.5, evasionDefense: 20, defense: 3, tenacity: 3, regen: 1.5, }, Health: { regen: 2, }, Physical: { criticalResistance: 5.5, criticalDefense: 9, evasionChance: 13.75, evasionDefense: 22.5, defense: 7, }, rangedDefense: 4, meleeDefense: 1.5, stealthRadius: 4.5, stealthDetection: 1.5, };
    var shadowLeftArm = {defense: 1, weight: 4.2, class: "Defensive", set: 'Shadow', type: 'Shadow Left', description: 'Description', slot: 'Left Arm', src: "shadowLeftArm", playerImage: true, refrence: "leftArm",                               Stamina: { criticalResistance: 6, criticalDefense: 9, evasionChance: 15, evasionDefense: 25, defense: 6, tenacity: 8, regen: 15, }, Thaumaturgy: { criticalResistance: 2.5, criticalDefense: 3.5, evasionChance: 12.5, evasionDefense: 20, defense: 3, tenacity: 3, regen: 1.5, }, Health: { regen: 2, }, Physical: { criticalResistance: 5.5, criticalDefense: 9, evasionChance: 13.75, evasionDefense: 22.5, defense: 7, }, rangedDefense: 4, meleeDefense: 1.5, stealthRadius: 4.5, stealthDetection: 1.5, };

    var festiveHead = {defense: 1.0415, weight: 7.65, class: "Defensive", set: 'Festive', type: 'Festive Helmet', description: 'Description', slot: 'Helmet', src: "festiveHelmet", playerImage: true, refrence: "head",                            Stamina: { criticalResistance: 1.5, criticalDefense: 2, evasionChance: 1.75, evasionDefense: 2.5, defense: 2, tenacity: 3, regen: 10, }, Thaumaturgy: { criticalResistance: 1.5, criticalDefense: 2, evasionChance: 1.75, evasionDefense: 2.5, defense: 2, tenacity: 3, regen: 10, }, Health: { regen: 10, }, Physical: { criticalResistance: 1.5, criticalDefense: 2, evasionChance: 1.75, evasionDefense: 2.5, defense: 2, }, rangedDefense: 1.25, meleeDefense: 1.25, stealthRadius: 1.25, stealthDetection: 1.25, };
    var festiveBody = {defense: 1.25, weight: 12.75, class: "Defensive", set: 'Festive',  type: 'Festive Torso', description: 'Decription', slot: 'Torso', src: "festiveTorso", playerImage: true, refrence: "body",                                Stamina: { criticalResistance: 1.5, criticalDefense: 2, evasionChance: 1.75, evasionDefense: 2.5, defense: 2, tenacity: 3, regen: 10, }, Thaumaturgy: { criticalResistance: 1.5, criticalDefense: 2, evasionChance: 1.75, evasionDefense: 2.5, defense: 2, tenacity: 3, regen: 10, }, Health: { regen: 10, }, Physical: { criticalResistance: 1.5, criticalDefense: 2, evasionChance: 1.75, evasionDefense: 2.5, defense: 2, }, rangedDefense: 1.25, meleeDefense: 1.25, stealthRadius: 1.25, stealthDetection: 1.25, };
    var festiveLegs = {defense: 1.0415, weight: 10.2, class: "Defensive", set: 'Festive', type: 'Festive Legs', description: 'Description', slot: 'Legs', src: "festiveLegs", playerImage: true, refrence: "legs",                                  Stamina: { criticalResistance: 1.5, criticalDefense: 2, evasionChance: 1.75, evasionDefense: 2.5, defense: 2, tenacity: 3, regen: 10, }, Thaumaturgy: { criticalResistance: 1.5, criticalDefense: 2, evasionChance: 1.75, evasionDefense: 2.5, defense: 2, tenacity: 3, regen: 10, }, Health: { regen: 10, }, Physical: { criticalResistance: 1.5, criticalDefense: 2, evasionChance: 1.75, evasionDefense: 2.5, defense: 2, }, rangedDefense: 1.25, meleeDefense: 1.25, stealthRadius: 1.25, stealthDetection: 1.25, };
    var festiveRightArm = {defense: 0.8335, weight: 5.95, class: "Defensive", set: 'Festive', type: 'Festive Right', description: 'Description', slot: 'Right Arm', src: "festiveRightArm", playerImage: true, refrence: "rightArm",                Stamina: { criticalResistance: 1.5, criticalDefense: 2, evasionChance: 1.75, evasionDefense: 2.5, defense: 2, tenacity: 3, regen: 10, }, Thaumaturgy: { criticalResistance: 1.5, criticalDefense: 2, evasionChance: 1.75, evasionDefense: 2.5, defense: 2, tenacity: 3, regen: 10, }, Health: { regen: 10, }, Physical: { criticalResistance: 1.5, criticalDefense: 2, evasionChance: 1.75, evasionDefense: 2.5, defense: 2, }, rangedDefense: 1.25, meleeDefense: 1.25, stealthRadius: 1.25, stealthDetection: 1.25, };
    var festiveLeftArm = {defense: 0.8335, weight: 5.95, class: "Defensive", set: 'Festive', type: 'Festive Left', description: 'Description', slot: 'Left Arm', src: "festiveLeftArm", playerImage: true, refrence: "leftArm",                     Stamina: { criticalResistance: 1.5, criticalDefense: 2, evasionChance: 1.75, evasionDefense: 2.5, defense: 2, tenacity: 3, regen: 10, }, Thaumaturgy: { criticalResistance: 1.5, criticalDefense: 2, evasionChance: 1.75, evasionDefense: 2.5, defense: 2, tenacity: 3, regen: 10, }, Health: { regen: 10, }, Physical: { criticalResistance: 1.5, criticalDefense: 2, evasionChance: 1.75, evasionDefense: 2.5, defense: 2, }, rangedDefense: 1.25, meleeDefense: 1.25, stealthRadius: 1.25, stealthDetection: 1.25, };
    let traits = ["Stamina", "Thaumaturgy", "Health", "Physical"];
    let traitMults = [stamina, force, hitpoints, physical]
    armour = [thunderWarriorHead, thunderWarriorBody, thunderWarriorLegs, thunderWarriorRightArm, thunderWarriorLeftArm, festiveHead, festiveBody, festiveLegs, festiveRightArm, festiveLeftArm, shadowHead, shadowBody, shadowLegs, shadowRightArm, shadowLeftArm, sithHead, sithBody, sithLegs, sithRightArm, sithLeftArm];
    for(var i = 0; i < armour.length; i ++) {
        armour[i].mods = {equipped: [], slotCount: 3, available: ['armourMultipliers']}
        armour[i].rangedDefense /= 2.5;
        armour[i].meleeDefense /= 2.5;
        armour[i].id = armour[i].type;
        if(armour[i].slot == "Helmet") {
            helmets.push(armour[i]);
        } else if(armour[i].slot == "Torso") {
            bodies.push(armour[i]);
        } else if(armour[i].slot == "Legs") {
            legs.push(armour[i]);
        } else if(armour[i].slot == "Right Arm") {
            rightArms.push(armour[i]);
        } else if(armour[i].slot == "Left Arm") {
            leftArms.push(armour[i]);
        }
        for(var e = 0; e < traits.length; e ++) {
            for(let prop in armour[i][traits[e]]) {
                let prop2 = prop == "regen" ? "regenPerSecond" : prop;
                armour[i][traits[e]][prop] = (armour[i][traits[e]][prop] / 100) * traitMults[e][prop2]; 
            }
        }
    }
    var e11Twilight = {
        initTime: 0.5, // the time it takes before the weapon can be used
        damage: 100, // how much damage is when blaster hits
        range: 10, // how many pixels a blaster bolt can travel 
        firingSpeed: 0.5 * 1000, // how many seconds times 1000 that must be waited between shots
        projectileSpeed: 5, // how many pixels the projectiles travel
        heat: {
            max: 2.5 * 1000, // maximum heat times 1000 and seconds it will take to cool down from max heat
            increase: 0.25 * 1000, // amount of heat it increases by for each shot, then multiplied by 1000
            coolWaitTime: 3 * 1000, //seconds that must be waited before the gun begins to cool down when not overheated
            overheatTime: 5 * 1000, //time it is overheated for
        }, // heat properties of projectiles
        src: "e11twilight", // image for blaster
        projectileColor: "Green", // image for projectile
        type: 'E-11 Twilight',
        spreadMax: 10, // the amount of spread of the weapon
        class: 'Blaster Rifle', // the type of weapon
        set: "Thunder Warrior",
        description: "The E-11 Twilight is the typical variety  of the E-11, which was designed to be the Jack of all trades. The E-11 Twilight is good at everything with good damage, range firing speed, and cooling powers, but does not excel in any one area.", // a description of the weapon
        criticalChance: 12.5,
        criticalDamage: 15,
        accuracy: 2.5,
        accuracyDamage: 5,
        precision: 2,
        Stamina: {
            criticalChance: 10,
            criticalDamage: 10,
            accuracy: 10,
            accuracyDamage: 10,
            precision: 10,
            damage: 10,
            onKill: 10,
            onDamage: 10,
            drain: 10,
            duration: 10,
            activationTime: 10,
            cooldown: 10
        },
        Thaumaturgy: {
            criticalChance: 10,
            criticalDamage: 10,
            accuracy: 10,
            accuracyDamage: 10,
            precision: 10,
            damage: 10,
            onKill: 10,
            onDamage: 10,
            drain: 10,
            duration: 10,
            activationTime: 10,
            cooldown: 10
        },
        Health: {
            onKill: 10,
            onDamage: 10,
            drain: 10
        },
        Physical: {
            criticalChance: 10,
            criticalDamage: 10,
            accuracy: 10,
            accuracyDamage: 10,
            precision: 10,
            damage: 10,
        }
    };

    var e11Affluent = {initTime: 0.6, damage: 80, range: 11, firingSpeed: 0.6 * 1000, projectileSpeed: 5.5, heat: {max: 2.25 * 1000, increase: 0.2 * 1000, coolWaitTime: 4 * 1000, overheatTime: 6 * 1000}, src: "e11affluent", projectileColor: "Green", type: 'E-11 Affluent', spreadMax: 11, class: 'Blaster Rifle', set: "Thunder Warrior",  description: "The E-1 was designed to be the Jack of all trades, but the E-11 Affluent is a variety focused on exploiting enemies through critical hits. It has more maximum heat and greater criticals than the base E-11, the E-11 Twilight, but less damage and firing speed.", criticalChance: 25, criticalDamage: 15, accuracy: 3.5, accuracyDamage: 6, precision: 4, Stamina: { criticalChance: 15, criticalDamage: 15, accuracy: 15, accuracyDamage: 15, precision: 15, damage: 5, onKill: 5, onDamage: 5, drain: 5, duration: 15, activationTime: 15, cooldown: 15}, Thaumaturgy: { criticalChance: 15, criticalDamage: 15, accuracy: 15, accuracyDamage: 15, precision: 15, damage: 5, onKill: 5, onDamage: 5, drain: 5, duration: 5, activationTime: 5, cooldown: 5 }, Health: {onKill: 5, onDamage: 5, drain: 5 }, Physical: { criticalChance: 15, criticalDamage: 15, accuracy: 15, accuracyDamage: 15, precision: 15, damage: 5} };
    var e11Viper = {initTime: 0.4, damage: 115, range: 8.5, firingSpeed: 0.35 * 1000, projectileSpeed: 4.75, heat: {max: 3.5 * 1000, increase: 0.4375 * 1000, coolWaitTime: 2 * 1000, overheatTime: 4.5 * 1000}, src: "e11viper", projectileColor: "Green", type: 'E-11 Viper', spreadMax: 9, class: 'Blaster Rifle', set: "Thunder Warrior",  description: "The E-11 was designed to be the Jack of all trades, but the E-11 Viper is a variety focused on quick bursts of damage with better cooling powers than the E-11 Twilight, though with less maximum shots", criticalChance: 10, criticalDamage: 14, accuracy: 2.25, accuracyDamage: 4.75, precision: 1.75, Stamina: { criticalChance: 5, criticalDamage: 5, accuracy: 5, accuracyDamage: 5, precision: 5, damage: 15, onKill: 15, onDamage: 15, drain: 15, duration: 5, activationTime: 5, cooldown: 5}, Thaumaturgy: { criticalChance: 5, criticalDamage: 5, accuracy: 5, accuracyDamage: 5, precision: 5, damage: 15, onKill: 15, onDamage: 15, drain: 15, duration: 15, activationTime: 15, cooldown: 15}, Health: {onKill: 15, onDamage: 15, drain: 15 }, Physical: { criticalChance: 5, criticalDamage: 5, accuracy: 5, accuracyDamage: 5, precision: 5, damage: 15} };
    
    var dlt19Epitome = {initTime: 1.5, damage: 30, range: 7, firingSpeed: 0.2 * 1000, projectileSpeed: 4,heat: {max: 1 * 1000, increase: 0.025 * 1000, coolWaitTime: 5 * 1000, overheatTime: 4 * 1000}, src: 'dlt19epitome', projectileColor: "Red", type: 'DLT-19 Epitome', spreadMax: 12.5, class: 'Repeating Blaster', set: "Sith",  description: "The DLT-19 Epitome typifies the DLT-19 series. It has a very high rate of fire, but with low damage or range. Its cooling takes time to start, but quickly acts to cool down the entire gun and allows all shots to be repeated.", criticalChance: 8.5, criticalDamage: 10, accuracy: 1.5, accuracyDamage: 2.5, precision: 1.2, Stamina: { criticalChance: 3, criticalDamage: 3, accuracy: 2.5, accuracyDamage: 2.5, precision: 2.5, damage: 3, onKill: 3, onDamage: 3, drain: 3, duration: 17.5, activationTime: 17.5, cooldown: 17.5}, Thaumaturgy: { criticalChance: 8, criticalDamage: 8, accuracy: 6, accuracyDamage: 6, precision: 6, damage: 8, onKill: 8, onDamage: 8, drain: 8, duration: 22.5, activationTime: 22.5, cooldown: 22.5}, Health: {onKill: 3, onDamage: 3, drain: 3 }, Physical: { criticalChance: 3, criticalDamage: 3, accuracy: 2.5, accuracyDamage: 2.5, precision: 2.5, damage: 3 } };
    var dlt19Deluge = {initTime: 1.35, damage: 20, range: 6.5, firingSpeed: 0.15 * 1000, projectileSpeed: 2.5,heat: {max: 1.5 * 1000, increase: 0.015 * 1000, coolWaitTime: 7 * 1000, overheatTime: 5.5 * 1000}, src: 'dlt19deluge', projectileColor: "Red", type: 'DLT-19 Deluge', spreadMax: 14, class: 'Repeating Blaster', set: "Sith",  description: "The DLT-19 Deluge has an even higher rate of fire than the DLT-19 Epitome and can fire for much longer before overheating, though it does less damage.", criticalChance: 7.5, criticalDamage: 9, accuracy: 1.25, accuracyDamage: 2.25, precision: 1, Stamina: { criticalChance: 2.5, criticalDamage: 2.5, accuracy: 2, accuracyDamage: 2, precision: 2, damage: 2, onKill: 2, onDamage: 2, drain: 2, duration: 20, activationTime: 20, cooldown: 20}, Thaumaturgy: { criticalChance: 6, criticalDamage: 6, accuracy: 4, accuracyDamage: 4, precision: 4, damage: 6, onKill: 6, onDamage: 6, drain: 6, duration: 25, activationTime: 25, cooldown: 25 }, Health: {onKill: 3, onDamage: 3, drain: 3 }, Physical: { criticalChance: 4, criticalDamage: 4, accuracy: 2, accuracyDamage: 2, precision: 2, damage: 3 } };
    var dlt19Scarlet = {initTime: 2, damage: 40, range: 7.5, firingSpeed: 0.25 * 1000, projectileSpeed: 3.5,heat: {max: 2 * 1000, increase: 0.08 * 1000, coolWaitTime: 4.25 * 1000, overheatTime: 5 * 1000}, src: 'dlt19scarlet', projectileColor: "Red", type: 'DLT-19 Scarlet', spreadMax: 11.5, class: 'Repeating Blaster', set: "Sith",  description: "The DLT-19 Scarlet deals greater damage than the DLT-19 Epitome, but with less firing speed and less maximum heat.", criticalChance: 7, criticalDamage: 12, accuracy: 2, accuracyDamage: 4, precision: 1.5, Stamina: { criticalChance: 5, criticalDamage: 5, accuracy: 4, accuracyDamage: 4, precision: 4, damage: 5, onKill: 5, onDamage: 3.5, drain: 3.5, duration: 15, activationTime: 15, cooldown: 15}, Thaumaturgy: { criticalChance: 8, criticalDamage: 8, accuracy: 6, accuracyDamage: 6, precision: 6, damage: 8, onKill: 8, onDamage: 6, drain: 10, duration: 20, activationTime: 20, cooldown: 20}, Health: {onKill: 2.5, onDamage: 2.5, drain: 4 }, Physical: { criticalChance: 3, criticalDamage: 3, accuracy: 2.75, accuracyDamage: 2.75, precision: 2.75, damage: 3 } };
    
    var t21Shade = {initTime: 1, damage: 200, range: 15, firingSpeed: 2 * 1000, projectileSpeed: 5.5,heat: {max: 4 * 1000, increase: 2.67 * 1000, coolWaitTime: 4 * 1000, overheatTime: 2 * 1000}, src: "t21shade", projectileColor: "Blue", type: 'T-21 Shade', spreadMax: 5, class: 'Heavy Blaster', set: "Shadow",  description: "The T-21 Shade exemplifies the T-12. It has a very high damage and range, with a low rate of fire. The T-21 Shade has great critical, accuracy, range and precision.", criticalChance: 27.5, criticalDamage: 25, accuracy: 5, accuracyDamage: 7.5, precision: 5, Stamina: { criticalChance: 20, criticalDamage: 20, accuracy: 20, accuracyDamage: 20, precision: 20, damage: 15, onKill: 15, onDamage: 15, drain: 15, duration: 9, activationTime: 10, cooldown: 10 }, Thaumaturgy: { criticalChance: 12.5, criticalDamage: 12.5, accuracy: 12.5, accuracyDamage: 12.5, precision: 12.5, damage: 11, onKill: 11, onDamage: 11, drain: 11, duration: 4, activationTime: 4, cooldown: 4 }, Health: {onKill: 12.5, onDamage: 12.5, drain: 12.5 }, Physical: { criticalChance: 12.5, criticalDamage: 12.5, accuracy: 12.5, accuracyDamage: 12.5, precision: 12.5, damage: 12.5 } };
    var t21Vintage = {initTime: 1.15, damage: 250, range: 20, firingSpeed: 3.5 * 1000, projectileSpeed: 6,heat: {max: 6 * 1000, increase: 4.8 * 1000, coolWaitTime: 5 * 1000, overheatTime: 3 * 1000}, src: "t21vintage", projectileColor: "Blue", type: 'T-21 Vintage', spreadMax: 6, class: 'Heavy Blaster', set: "Shadow",  description: "The T-21 Vintage is an old fashioned version of the T-21 Shae. It has even greater damage and range. However, it is less accurate and fires even slower.", criticalChance: 35, criticalDamage: 30, accuracy: 4, accuracyDamage: 5.5, precision: 7, Stamina: { criticalChance: 25, criticalDamage: 25, accuracy: 25, accuracyDamage: 17.5, precision: 25, damage: 20, onKill: 20, onDamage: 20, drain: 20, duration: 7.5, activationTime: 7.5, cooldown: 7.5 }, Thaumaturgy: { criticalChance: 14, criticalDamage: 14, accuracy: 11, accuracyDamage: 14, precision: 14, damage: 12, onKill: 12, onDamage: 12, drain: 12, duration: 5, activationTime: 5, cooldown: 5 }, Health: {onKill: 15, onDamage: 15, drain: 15 }, Physical: { criticalChance: 15, criticalDamage: 15, accuracy: 11, accuracyDamage: 11, precision: 15, damage: 15 } };
    var t21Amaranthine = {initTime: 0.8, damage: 150, range: 6, firingSpeed: 0.75 * 1000, projectileSpeed: 5,heat: {max: 3 * 1000, increase: 1.67 * 1000, coolWaitTime: 4.4 * 1000, overheatTime: 1.5 * 1000}, src: "t21amaranthine", projectileColor: "Blue", type: 'T-21 Amaranthine', spreadMax: 7, class: 'Heavy Blaster', set: "Shadow",  description: "The T-21 Amaranthine is a modified version of the T-21 Shade that was intended for very close combat. It deals less damage, but has a greater rate of fire and more maximum shots.", criticalChance: 22.5, criticalDamage: 20, accuracy: 6, accuracyDamage: 8.5, precision: 5.5, Stamina: { criticalChance: 17.5, criticalDamage: 17.5, accuracy: 17.5, accuracyDamage: 17.5, precision: 17.5, damage: 13, onKill: 13, onDamage: 13, drain: 13, duration: 10.5, activationTime: 10.5, cooldown: 10.5 }, Thaumaturgy: { criticalChance: 11, criticalDamage: 11, accuracy: 10.5, accuracyDamage: 11, precision: 11, damage: 10.5, onKill: 10.5, onDamage: 10.5, drain: 13, duration: 6, activationTime: 6, cooldown: 6 }, Health: {onKill: 14, onDamage: 14, drain: 12 }, Physical: { criticalChance: 11, criticalDamage: 11, accuracy: 11, accuracyDamage: 11, precision: 11, damage: 11 } };
    rangedWeapons = [e11Twilight, e11Affluent, e11Viper, t21Shade, t21Vintage, t21Amaranthine, dlt19Deluge, dlt19Epitome, dlt19Scarlet];
    for(var i = 0; i < rangedWeapons.length; i ++) {
        rangedWeapons[i].damage *= 3;
        rangedWeapons[i].playerImage = false;
        rangedWeapons[i].equipTime = 2;
        rangedWeapons[i].refrence = "rangedWeapon";
        rangedWeapons[i].slot = "Ranged";
        rangedWeapons[i].delay = 0.5;
        rangedWeapons[i].id = rangedWeapons[i].type;
        rangedWeapons[i].mods = {
            available: ['weaponMultipliers', 'rangedMultipliers'],
            slotCount: 3,
            equipped: []
        }
        for(var e = 0; e < traits.length; e ++) {
            for(let prop in rangedWeapons[i][traits[e]]) {
                rangedWeapons[i][traits[e]][prop] = (rangedWeapons[i][traits[e]][prop] / 100) * traitMults[e][prop]; 
            }
        }
    }
    meleeWeapons = getLaserSwords(traits, traitMults);
}

function getLaserSwords(traits, traitMults) {
    let laserSwords = [
        { initTime: 1, block: {minTime: 1, parryTime: 0.25, wait: 1, stun: 0.1, knockback: 0.25, stabAngle: 60, projectileAngle: 45, reflectionRange: 5, reflectionSpread: 35, reflectionDrain: 35, enemyStabDrain: 400, ownStabDrain: 300, thaumAngle: 30, enemyThaumDrain: 500, ownThaumDrain: 300, continualDrain: 450, imediateDrain: 650}, strike: {delay: 0.4, wait: 1.5, damage: 300, knockback: 1.5, angle: 75, radius: 5, cost: 200}, criticalChance: 10, criticalDamage: 30, accuracy: 4, accuracyDamage: 7.5, precision: 3, src: "saberOrange", type: 'Coral Plasmablade', class: 'Aggressive', set: "Shadow", description: "The orange Coral Plasmablade is a plasmablade that focuses on pure offensive potential.", Stamina: { criticalChance: 20, criticalDamage: 20, accuracy: 20, accuracyDamage: 20, precision: 20, damage: 15, onKill: 15, onDamage: 15, drain: 15, duration: 9, activationTime: 10, cooldown: 10 }, Thaumaturgy: { criticalChance: 12.5, criticalDamage: 12.5, accuracy: 12.5, accuracyDamage: 12.5, precision: 12.5, damage: 11, onKill: 11, onDamage: 11, drain: 11, duration: 4, activationTime: 4, cooldown: 4 }, Health: {onKill: 12.5, onDamage: 12.5, drain: 12.5 }, Physical: { criticalChance: 12.5, criticalDamage: 12.5, accuracy: 12.5, accuracyDamage: 12.5, precision: 12.5, damage: 12.5 }},
        { initTime: 1.25, block: {minTime: 1.25, parryTime: 0.3, wait: 1.5, stun: 0.15, knockback: 0.3, stabAngle: 55, projectileAngle: 40, reflectionRange: 6, reflectionSpread: 40, reflectionDrain: 40, enemyStabDrain: 44, ownStabDrain: 330, thaumAngle: 35, enemyThaumDrain: 550, ownThaumDrain: 330, continualDrain: 495, imediateDrain: 715}, strike: {delay: 0.7, wait: 2.25, damage: 500, knockback: 2.5, angle: 90, radius: 7, cost: 350}, criticalChance: 12.5, criticalDamage: 45, accuracy: 6, accuracyDamage: 9, precision: 4.5, src: "saberPurple", type: 'Amethyst Plasmablade', class: 'Aggressive', set: "Shadow", description: "The purple Amethyst Plasmablade is a plasmablade that focuses on pure offensive potential. It attacks slowly, but focuses on strongly punishing the enemies it does hit.", Stamina: { criticalChance: 25, criticalDamage: 25, accuracy: 25, accuracyDamage: 17.5, precision: 25, damage: 20, onKill: 20, onDamage: 20, drain: 20, duration: 7.5, activationTime: 7.5, cooldown: 7.5 }, Thaumaturgy: { criticalChance: 14, criticalDamage: 14, accuracy: 11, accuracyDamage: 14, precision: 14, damage: 12, onKill: 12, onDamage: 12, drain: 12, duration: 5, activationTime: 5, cooldown: 5 }, Health: {onKill: 15, onDamage: 15, drain: 15 }, Physical: { criticalChance: 15, criticalDamage: 15, accuracy: 11, accuracyDamage: 11, precision: 15, damage: 15 }},
        { initTime: 0.85, block: {minTime: 0.75, parryTime: 0.2, wait: 0.8, stun: 0.075, knockback: 0.2, stabAngle: 50, projectileAngle: 50, reflectionRange: 5, reflectionSpread: 30, reflectionDrain: 45, enemyStabDrain: 350, ownStabDrain: 250, thaumAngle: 25, enemyThaumDrain: 450, ownThaumDrain: 270, continualDrain: 400, imediateDrain: 600}, strike: {delay: 0.2, wait: 0.75, damage: 235, knockback: 1.3, angle: 65, radius: 4.25, cost: 150}, criticalChance: 15, criticalDamage: 25, accuracy: 5, accuracyDamage: 6, precision: 5, src: "saberRed", type: 'Garnet Plasmablade', class: 'Aggressive', set: "Shadow", description: "The red Garnet Plasmablade is a plasmablade that focuses on pure offensive potential. It ferociously attacks with many quick attacks.", Stamina: { criticalChance: 17.5, criticalDamage: 17.5, accuracy: 17.5, accuracyDamage: 17.5, precision: 17.5, damage: 13, onKill: 13, onDamage: 13, drain: 13, duration: 10.5, activationTime: 10.5, cooldown: 10.5 }, Thaumaturgy: { criticalChance: 11, criticalDamage: 11, accuracy: 10.5, accuracyDamage: 11, precision: 11, damage: 10.5, onKill: 10.5, onDamage: 10.5, drain: 13, duration: 6, activationTime: 6, cooldown: 6 }, Health: {onKill: 14, onDamage: 14, drain: 12 }, Physical: { criticalChance: 11, criticalDamage: 11, accuracy: 11, accuracyDamage: 11, precision: 11, damage: 11 }},
        { initTime: 0.5, block: {minTime: 0.25, parryTime: 1, wait: 0.25, stun: 0.5, knockback: 2, stabAngle: 90, projectileAngle: 75, reflectionRange: 10, reflectionSpread: 15, reflectionDrain: 15, enemyStabDrain: 600, ownStabDrain: 100, thaumAngle: 60, enemyThaumDrain: 750, ownThaumDrain: 175, continualDrain: 200, imediateDrain: 350}, strike: {delay: 0.8, wait: 2.5, damage: 200, knockback: 0.75, angle: 35, radius: 3, cost: 400}, criticalChance: 3.5, criticalDamage: 10, accuracy: 2, accuracyDamage: 3.5, precision: 1.75, src: "saberBlue", type: 'Tanzanite Plasmablade', class: 'Defensive', set: "Sith", description: "The blue Tanzanite Plasmabalde is a plasmablade that focuses on pure defensive potential.", Stamina: { criticalChance: 3, criticalDamage: 3, accuracy: 2.5, accuracyDamage: 2.5, precision: 2.5, damage: 3, onKill: 3, onDamage: 3, drain: 3, duration: 17.5, activationTime: 17.5, cooldown: 17.5}, Thaumaturgy: { criticalChance: 8, criticalDamage: 8, accuracy: 6, accuracyDamage: 6, precision: 6, damage: 8, onKill: 8, onDamage: 8, drain: 8, duration: 22.5, activationTime: 22.5, cooldown: 22.5}, Health: {onKill: 3, onDamage: 3, drain: 3 }, Physical: { criticalChance: 3, criticalDamage: 3, accuracy: 2.5, accuracyDamage: 2.5, precision: 2.5, damage: 3 }},
        { initTime: 0.65, block: {minTime: 1.5, parryTime: 1.5, wait: 0.35, stun: 0.4, knockback: 1.75, stabAngle: 80, projectileAngle: 70, reflectionRange: 8, reflectionSpread: 20, reflectionDrain: 5, enemyStabDrain: 550, ownStabDrain: 33, thaumAngle: 50, enemyThaumDrain: 650, ownThaumDrain: 75, continualDrain: 50, imediateDrain: 500}, strike: {delay: 1, wait: 2.75, damage: 220, knockback: 0.9, angle: 40, radius: 3.125, cost: 450}, criticalChance: 3.25, criticalDamage: 12.5, accuracy: 1.75, accuracyDamage: 4, precision: 2, src: "saberGreen", type: 'Emerald Plasmablade', class: 'Defensive', set: "Sith", description: "The green Emerald Plasmablade is a plasmablade that focuses on pure defensive potential. It makes use of lengthy blocking.", Stamina: { criticalChance: 5, criticalDamage: 5, accuracy: 4, accuracyDamage: 4, precision: 4, damage: 5, onKill: 5, onDamage: 3.5, drain: 3.5, duration: 15, activationTime: 15, cooldown: 15}, Thaumaturgy: { criticalChance: 8, criticalDamage: 8, accuracy: 6, accuracyDamage: 6, precision: 6, damage: 8, onKill: 8, onDamage: 6, drain: 10, duration: 20, activationTime: 20, cooldown: 20}, Health: {onKill: 2.5, onDamage: 2.5, drain: 4 }, Physical: { criticalChance: 3, criticalDamage: 3, accuracy: 2.75, accuracyDamage: 2.75, precision: 2.75, damage: 3 }},
        { initTime: 0.4, block: {minTime: 0.75, parryTime: 0.75, wait: 0.15, stun: 0.6, knockback: 2.25, stabAngle: 100, projectileAngle: 85, reflectionRange: 12, reflectionSpread: 10, reflectionDrain: 22.5, enemyStabDrain: 700, ownStabDrain: 150, thaumAngle: 70, enemyThaumDrain: 850, ownThaumDrain: 225, continualDrain: 325, imediateDrain: 100}, strike: {delay: 0.725, wait: 2.15, damage: 175, knockback: 0.6, angle: 30, radius: 2.75, cost: 375}, criticalChance: 3.75, criticalDamage: 8.5, accuracy: 2.25, accuracyDamage: 3, precision: 1.5, src: "saberLime", type: 'Peridot Plasmablade', class: 'Defensive', set: "Sith", description: "The lime Peridot Plasmablade is a plasmablade that focuses on pure defensive potential. It makes use of quickly blocking.", Stamina: { criticalChance: 2.5, criticalDamage: 2.5, accuracy: 2, accuracyDamage: 2, precision: 2, damage: 2, onKill: 2, onDamage: 2, drain: 2, duration: 20, activationTime: 20, cooldown: 20}, Thaumaturgy: { criticalChance: 6, criticalDamage: 6, accuracy: 4, accuracyDamage: 4, precision: 4, damage: 6, onKill: 6, onDamage: 6, drain: 6, duration: 25, activationTime: 25, cooldown: 25 }, Health: {onKill: 3, onDamage: 3, drain: 3 }, Physical: { criticalChance: 4, criticalDamage: 4, accuracy: 2, accuracyDamage: 2, precision: 2, damage: 3 }},
        { initTime: 0.75, block: {minTime: 0.5, parryTime: 0.5, wait: 0.5, stun: 0.25, knockback: 1.25, stabAngle: 75, projectileAngle: 60, reflectionRange: 7.5, reflectionSpread: 25, reflectionDrain: 25, enemyStabDrain: 500, ownStabDrain: 200, thaumAngle: 45, enemyThaumDrain: 600, ownThaumDrain: 250, continualDrain: 300, imediateDrain: 450}, strike: {delay: 0.6, wait: 2, damage: 250, knockback: 1.25, angle: 50, radius: 4, cost: 300}, criticalChance: 5, criticalDamage: 15, accuracy: 2.5, accuracyDamage: 5, precision: 2.25, src: "saberYellow", type: 'Topaz Plasmablade', class: 'Balanced', set: "Sith", description: "The yellow Topaz Plasmablade is the classic plasmablade, which incorporates the complete balance between defensive and offensive capabilities.", Stamina: {criticalChance: 10, criticalDamage: 10, accuracy: 10, accuracyDamage: 10, precision: 10, damage: 10, onKill: 10, onDamage: 10, drain: 10, duration: 10, activationTime: 10, cooldown: 10 }, Thaumaturgy: { criticalChance: 10, criticalDamage: 10, accuracy: 10, accuracyDamage: 10, precision: 10, damage: 10, onKill: 10, onDamage: 10, drain: 10, duration: 10, activationTime: 10, cooldown: 10 }, Health: { onKill: 10, onDamage: 10, drain: 10 }, Physical: { criticalChance: 10, criticalDamage: 10, accuracy: 10, accuracyDamage: 10, precision: 10, damage: 10, }},
        { initTime: 0.35, block: {minTime: 0.7, parryTime: 0.7, wait: 0.35, stun: 0.35, knockback: 1.5, stabAngle: 82.5, projectileAngle: 65, reflectionRange: 8.25, reflectionSpread: 22.5, reflectionDrain: 42.5, enemyStabDrain: 550, ownStabDrain: 175, thaumAngle: 51.25, enemyThaumDrain: 625, ownThaumDrain: 425, continualDrain: 510, imediateDrain: 765}, strike: {delay: 0.5, wait: 1.75, damage: 275, knockback: 1.4, angle: 60, radius: 4.5, cost: 510}, criticalChance: 7.5, criticalDamage: 27.5, accuracy: 3, accuracyDamage: 6.75, precision: 2.75, src: "saberCyan", type: 'Boracite Plasmablade', class: 'Balanced', set: "Thunder Warrior", description: "The cyan Boracite Plasmablade is a less efficient but stronger version of the classic plasmablade. It incorporates the complete balance between defensive and offensive capabilities, but with a higher cost to use. A best fit for Thunder Warriors who choose to prioritize Maximum Stamina.", Stamina: { criticalChance: 15, criticalDamage: 15, accuracy: 15, accuracyDamage: 15, precision: 15, damage: 5, onKill: 5, onDamage: 5, drain: 5, duration: 15, activationTime: 15, cooldown: 15}, Thaumaturgy: { criticalChance: 15, criticalDamage: 15, accuracy: 15, accuracyDamage: 15, precision: 15, damage: 5, onKill: 5, onDamage: 5, drain: 5, duration: 5, activationTime: 5, cooldown: 5 }, Health: {onKill: 5, onDamage: 5, drain: 5 }, Physical: { criticalChance: 15, criticalDamage: 15, accuracy: 15, accuracyDamage: 15, precision: 15, damage: 5}},
        { initTime: 1.5, block: {minTime: 0.4, parryTime: 0.4, wait: 0.65, stun: 0.2, knockback: 1, stabAngle: 70, projectileAngle: 55, reflectionRange: 6.5, reflectionSpread: 27.5, reflectionDrain: 17.5, enemyStabDrain: 450, ownStabDrain: 140, thaumAngle: 40, enemyThaumDrain: 575, ownThaumDrain: 190, continualDrain: 225, imediateDrain: 365}, strike: {delay: 0.725, wait: 2.125, damage: 230, knockback: 1.1, angle: 45, radius: 3.5, cost: 210}, criticalChance: 4, criticalDamage: 12.5, accuracy: 2.3, accuracyDamage: 4.25, precision: 1.9, src: "saberWhite", type: 'Alabaster Plasmablade', class: 'Balanced', set: "Thunder Warrior", description: "The white Alabaster Plasmablade is a more efficient but weaker version of the classic plasmablade. It incorporates the complete balance between defensive and offensive capabilities, but with a lesser cost to use. A best fit for Thunder Warriors who choose not to prioritize Maximum Stamina.", Stamina: { criticalChance: 15, criticalDamage: 15, accuracy: 15, accuracyDamage: 15, precision: 15, damage: 5, onKill: 5, onDamage: 5, drain: 5, duration: 15, activationTime: 15, cooldown: 15}, Thaumaturgy: { criticalChance: 15, criticalDamage: 15, accuracy: 15, accuracyDamage: 15, precision: 15, damage: 5, onKill: 5, onDamage: 5, drain: 5, duration: 5, activationTime: 5, cooldown: 5 }, Health: {onKill: 5, onDamage: 5, drain: 5 }, Physical: { criticalChance: 15, criticalDamage: 15, accuracy: 15, accuracyDamage: 15, precision: 15, damage: 5}},

    ];
    for(var i = 0; i < laserSwords.length; i ++) {
        laserSwords[i].mods = {equipped: [], slotCount: 3, available: ['weaponMultipliers', 'meleeMultipliers']};
        laserSwords[i].id = laserSwords[i].type;
        laserSwords[i].equipTime = 2;
        laserSwords[i].strike.duration = 1;
        laserSwords[i].strike.damage *= 3;
        laserSwords[i].slot = "Melee";
        laserSwords[i].playerImage = false;
        laserSwords[i].refrence = "meleeWeapon";
        for(var e = 0; e < traits.length; e ++) {
            for(let prop in laserSwords[i][traits[e]]) {
                laserSwords[i][traits[e]][prop] = (laserSwords[i][traits[e]][prop] / 100) * traitMults[e][prop]; 
            }
        }
    }
    return laserSwords;
}

function getPower(equipment) {
    let power;
    if(isMod(equipment)) return Math.round(getModPower(equipment));
    power = 1 + Math.pow(equipment.rarityIncrease, 1.5) * (1 + (equipment.level * levelBonus));
    for(var i = 0; i < equipment.mods.equipped.length; i ++) {
        power += getModPower(equipment.mods.equipped[i]);
    }
    return Math.max(1, Math.round(power));
}

function isMod(equipment) {
    return !(equipment.slot == undefined || equipment.slot == "Legs" || equipment.slot == "Torso" || equipment.slot == "Helmet" || equipment.slot == "Left Arm" || equipment.slot == "Right Arm" || equipment.slot == 'Ranged' || equipment.slot == 'Melee');
}

function getModPower(mod) {
    let modPositive = 0;
    let modNegative = 0;
    let modBasepower = 1.5 * mod.rarityIncrease * (1 + mod.level * levelBonus);
    for(var e = 0; e < mod.minorModifications.length; e ++) {
        if(mod.minorModifications[e].negative == true) {
            modNegative ++;
        } else {
            modPositive ++;
        }
    }
    return modBasepower + (modPositive - modNegative) * mod.rarityIncrease * 0.7;
}

function recieveMessage(msg) {
    console.error("Message Of Unknowsn Type: ERROR CODE 950 041 - ", msg, ' - ', msg.id);
}

function revealHome() {
    document.getElementById("homeScreen").style.visibility = "visible";
    document.getElementById("playerName").innerHTML = troop.username.substr(0,13);
    showHomeScreen();
}

function copyObject(obj) {
    return JSON.parse(JSON.stringify(obj))
}

function combineObjects(obj1, obj2) {
    return {...copyObject(obj1), ...copyObject(obj2)}
}

function hideGameModeSelection(e) {
    if(e.target == e.currentTarget) {
        if(gameModeSelectionShowing == true) {
            clearInterval(moveSelectionUp);
            var movementDown = 0;
            moveSelectionDown = setInterval(function(){ 
                movementDown += 1;
                var top = document.getElementById("gameModeSelectionTab").offsetTop + movementDown * sizeUnits / 5;
                if(top > 100 * sizeUnits) {
                    gameModeSelectionShowing = false;
                    document.getElementById("gameModeSelectionBackground").style.visibility = "hidden";
                    clearInterval(moveSelectionDown);
                } else {
                    document.getElementById("gameModeSelectionTab").style.top = top + "px";
                }
            }, 20);
        }
    }
}

function showGameModeSelection() {
    gameModeSelectionShowing = 'moving';
    document.getElementById("gameModeSelectionTab").style.top = (100 * sizeUnits) + "px";
    document.getElementById("gameModeSelectionBackground").style.visibility = "visible";
    var movementUp = 0;
    clearInterval(moveSelectionDown);
    moveSelectionUp = setInterval(function(){ 
        movementUp += 1;
        var top = document.getElementById("gameModeSelectionTab").offsetTop - movementUp * sizeUnits / 5;
        if(top < 36 * sizeUnits) {
            gameModeSelectionShowing = true;
            document.getElementById("gameModeSelectionTab").style.top = (36 * sizeUnits) + "px";
            clearInterval(moveSelectionUp);
        } else {
            document.getElementById("gameModeSelectionTab").style.top = top + "px";
        }
    }, 20);
}

function viewCredits(event) {
    window.open("/credits");
}

function manageAccount(event) {
    window.open("/manage");
}

function news(event) {
    window.open("/news");
}

function sendFeedback(event) {
    window.open("/feedback");
}

function closeWs(e) {
    totalRedirect('disconnection');
}

function closeSettings(e, fast) {
    if(fast == true || e.target == e.currentTarget) {
        document.getElementById("settingsScreen").style.visibility = "hidden";
    }
}

function closePurchase(event, element) {
    if(event.target == event.currentTarget) {
        element.remove();
    }
}

function selectAbilityUpgrade(e) {
    if(e.target == e.currentTarget) {
        if(troop.level > troop.upgradedLevel) {
            closeSettings(undefined, true);
            showUpgradeAbilityScreen(false);
        } else {
            tell(9, "Fully Upgraded", "You have already upgraded your abilities the maximum number of times available at this level. Level up to upgrade another ability.");
        }
    }
}

function returnToHome() {
    totalRedirect(undefined, "https://thunderwarrior.org/home");
    return false;
}

//modiies equipment as needed from mods
function getModifiedEquipment() {
    let equipment = {
        rangedWeapon: copyObject(troop.rangedWeapon),
        meleeWeapon: copyObject(troop.meleeWeapon),
        helmet: copyObject(troop.playerImage.head),
        torso: copyObject(troop.playerImage.body),
        legs: copyObject(troop.playerImage.legs),
        leftArm: copyObject(troop.playerImage.leftArm),
        rightArm: copyObject(troop.playerImage.rightArm)
    }
    modifyWeapons(equipment.rangedWeapon, "accuratelyModified");
    modifyWeapons(equipment.meleeWeapon, "accuratelyModified");
    modifyRangedWeapon(equipment.rangedWeapon, "accuratelyModified");
    modifyMeleeWeapon(equipment.meleeWeapon, "accuratelyModified");
    modifyArmour(equipment.helmet, "accuratelyModified");
    modifyArmour(equipment.torso, "accuratelyModified");
    modifyArmour(equipment.legs, "accuratelyModified");
    modifyArmour(equipment.leftArm, "accuratelyModified");
    modifyArmour(equipment.rightArm, "accuratelyModified");
    return equipment;
}

//modifies weapons as needed from mods
function modifyWeapons(weapon, uniform) {
    let types = ["Thaumaturgy", "Stamina", "Health", "Physical"];
    let physical = modifyAbility(copyObject(troop.physical));
    weapon.power = getPower(weapon);
    weapon.initTime = calculateModifiedStatistic(weapon, weapon.initTime, "Quick Fire", undefined, true, false, uniform);
    weapon.criticalChance = minorlyModifyEquipment(weapon.criticalChance, "Physical Critical Chance", weapon.id, undefined, physical.criticalChance);
    weapon.criticalDamage = minorlyModifyEquipment(weapon.criticalDamage, "Physical Critical Damage", weapon.id, undefined, physical.criticalDamage);
    weapon.accuracy = minorlyModifyEquipment(weapon.accuracy, "Physical Accuracy", weapon.id, undefined, physical.accuracy);
    weapon.accuracyDamage = minorlyModifyEquipment(weapon.accuracyDamage, "Physical Accuracy Damage", weapon.id, undefined, physical.accuracyDamage);
    weapon.precision = minorlyModifyEquipment(weapon.precision, "Physical Precision", weapon.id, undefined, physical.precision);
    for(var i = 0; i < types.length; i ++) {
        let type = types[i];
        if(weapon[type] != undefined) {
            if(type != "Health") {
                weapon[type].criticalChance = minorlyModifyEquipment(weapon[type].criticalChance, type + " Critical Chance", weapon.id);
                weapon[type].criticalDamage = minorlyModifyEquipment(weapon[type].criticalDamage, type + " Critical Damage", weapon.id);
                weapon[type].accuracy = minorlyModifyEquipment(weapon[type].accuracy, type + " Accuracy", weapon.id);
                weapon[type].accuracyDamage = minorlyModifyEquipment(weapon[type].accuracyDamage, type + " Accuracy Damage", weapon.id);
                weapon[type].precision = minorlyModifyEquipment(weapon[type].precision, type + " Precision", weapon.id);
                weapon[type].damage = minorlyModifyEquipment(weapon[type].damage, type + " Damage", weapon.id);
                if(type != "Physical") {
                    weapon[type].duration = minorlyModifyEquipment(weapon[type].duration, type + " Duration", weapon.id);
                    weapon[type].activationTime = minorlyModifyEquipment(weapon[type].activationTime, type + " Activation Time", weapon.id);
                    weapon[type].cooldown = minorlyModifyEquipment(weapon[type].cooldown, type + " Cooldown", weapon.id);

                }
            }
            if(type != "Physical") {
                weapon[type].onKill = minorlyModifyEquipment(weapon[type].onKill, type + " on Kill", weapon.id);
                weapon[type].onDamage = minorlyModifyEquipment(weapon[type].onDamage, type + " on Damage", weapon.id);
                weapon[type].drain = minorlyModifyEquipment(weapon[type].drain, type + " Drain", weapon.id);
            }
        }
    }
}

//modifies melee weapons as needed from mods
function modifyMeleeWeapon(weapon, uniform) {
    let physicalDamage = minorlyModifyEquipment(troop.physical.damage, "Physical Damage", "damage", "Physical") / 100;
    weapon.strike.damage = calculateModifiedStatistic(weapon, weapon.strike.damage, "Damage", physicalDamage, false, false, uniform);
    weapon.block.wait = calculateModifiedStatistic(weapon, weapon.block.wait, "Usage Speed", undefined, true, false, uniform);
    weapon.strike.wait = calculateModifiedStatistic(weapon, weapon.strike.wait, "Usage Speed", undefined, true, false, uniform);
    weapon.block.minTime = calculateModifiedStatistic(weapon, weapon.block.minTime, "Usage Speed", undefined, true, false, uniform);
    weapon.strike.radius = calculateModifiedStatistic(weapon, weapon.strike.radius, "Power", undefined, false, false, uniform);
    weapon.strike.knockback = calculateModifiedStatistic(weapon, weapon.strike.knockback, "Power", undefined, false, false, uniform);
    weapon.block.stabAngle = calculateModifiedStatistic(weapon, weapon.block.stabAngle, "Deflection", undefined, false, false, uniform);
    weapon.block.knockback = calculateModifiedStatistic(weapon, weapon.block.knockback, "Deflection", undefined, false, false, uniform);
    weapon.block.stun = calculateModifiedStatistic(weapon, weapon.block.stun, "Deflection", undefined, false, false, uniform);
    weapon.block.enemyStabDrain = calculateModifiedStatistic(weapon, weapon.block.enemyStabDrain, "Deflection", undefined, false, false, uniform);
    weapon.block.projectileAngle = calculateModifiedStatistic(weapon, weapon.block.projectileAngle, "Reflection", undefined, false, false, uniform);
    weapon.block.reflectionRange = calculateModifiedStatistic(weapon, weapon.block.reflectionRange, "Reflection", undefined, false, false, uniform);
    weapon.block.reflectionSpread = calculateModifiedStatistic(weapon, weapon.block.reflectionSpread, "Reflection", undefined, false, false, uniform);
    weapon.block.reflectionDrain = calculateModifiedStatistic(weapon, weapon.block.reflectionDrain, "Slightness", undefined, true, false, uniform);
    weapon.block.ownStabDrain = calculateModifiedStatistic(weapon, weapon.block.ownStabDrain, "Slightness", undefined, true, false, uniform);
    weapon.block.ownThaumDrain = calculateModifiedStatistic(weapon, weapon.block.ownThaumDrain, "Slightness", undefined, true, false, uniform);
    weapon.block.enemyThaumDrain = calculateModifiedStatistic(weapon, weapon.block.enemyThaumDrain, "Slightness", undefined, true, false, uniform);
    weapon.block.thaumAngle = calculateModifiedStatistic(weapon, weapon.block.thaumAngle, "Redirection", undefined, false, false, uniform);
    weapon.block.continualDrain = calculateModifiedStatistic(weapon, weapon.block.continualDrain, "Slightness", undefined, true, false, uniform);
    weapon.block.imediateDrain = calculateModifiedStatistic(weapon, weapon.block.imediateDrain, "Slightness", undefined, true, false, uniform);
    weapon.strike.cost = calculateModifiedStatistic(weapon, weapon.strike.cost, "Slightness", undefined, true, false, uniform);
    weapon.block.parryTime = calculateModifiedStatistic(weapon, weapon.block.parryTime, "Parry", undefined, false, false, uniform);
}

//modifies ranged weapons as needed from mods   
function modifyRangedWeapon(weapon, uniform) {
    let physicalDamage = minorlyModifyEquipment(troop.physical.damage, "Physical Damage", "damage", "Physical") / 100;
    weapon.damage = calculateModifiedStatistic(weapon, weapon.damage, "Damage", physicalDamage, false, false, uniform);
    weapon.spreadMax = calculateModifiedStatistic(weapon, weapon.spreadMax, "Maximum Spread", undefined,  true, false, uniform);
    weapon.projectileSpeed = calculateModifiedStatistic(weapon, weapon.projectileSpeed, "Projectile Speed", undefined, false, false, uniform);
    weapon.range = calculateModifiedStatistic(weapon, weapon.range, "Range", undefined, false, false, uniform);
    weapon.firingSpeed = calculateModifiedStatistic(weapon, weapon.firingSpeed, "Firing Speed", undefined, true, false, uniform);
    weapon.heat.max = calculateModifiedStatistic(weapon, weapon.heat.max, "Maximum Heat", undefined, false, false, uniform);
    weapon.heat.coolWaitTime = calculateModifiedStatistic(weapon, weapon.heat.coolWaitTime, "Cooling Power", undefined, true, false, uniform);
    weapon.heat.overheatTime = calculateModifiedStatistic(weapon, weapon.heat.overheatTime, "Cooling Power", undefined, true, false, uniform);
    weapon.delay = calculateModifiedStatistic(weapon, weapon.delay, "Quick Fire", undefined, true, false, uniform);
}

function getAbilityFromFoundCount(equipmentTrait, foundCount) {
    if(foundCount >= 0) {
        return equipmentTrait * (1 + foundCount);
    } else {
        return equipmentTrait / (1 + foundCount);
    }
}

//modifies armour as needed from mods
function modifyArmour(armour, uniform) {
    let types = ["Thaumaturgy", "Stamina", "Health", "Physical"];
    let physical = modifyAbility(copyObject(troop.physical));
    armour.weight = getWeight(armour, uniform);
    armour.defense = getDefense(armour, uniform);
    armour.power = getPower(armour);
    for(var i = 0; i < types.length; i ++) {
        let type = types[i];
        if(armour[type] != undefined) {
            armour[type].criticalResistance = minorlyModifyEquipment(armour[type].criticalResistance, type + " Critical Resistance", armour.id);
            armour[type].criticalDefense = minorlyModifyEquipment(armour[type].criticalDefense, type + " Critical Defense", armour.id);
            armour[type].evasionChance = minorlyModifyEquipment(armour[type].evasionChance, type + " Evasion Chance", armour.id);
            armour[type].evasionDefense = minorlyModifyEquipment(armour[type].evasionDefense, type + " Evasion Defense", armour.id);
            if(type != "Physical") {
                if(type != "Health") {
                    armour[type].tenacity = minorlyModifyEquipment(armour[type].tenacity, type + " Tenacity", armour.id);
                }
                armour[type].defense = minorlyModifyEquipment(armour[type].defense, type + " Defense", armour.id);
                armour[type].regen = calculateModifiedStatistic(armour, armour[type].regen, type + " Recovery", undefined, false, false, uniform);
           }
        }
    }
    //    weapon.criticalChance = minorlyModifyEquipment(troop.criticalChance, "Physical Critical Chance", weapon.id, undefined, physical.criticalChance);
    armour.rangedDefense = minorlyModifyEquipment(armour.rangedDefense, "Ranged Defense", armour.id, undefined, physical.rangedDefense);
    armour.meleeDefense = minorlyModifyEquipment(armour.meleeDefense, "Melee Defense", armour.id, undefined, physical.meleeDefense);
    armour.stealthRadius = minorlyModifyEquipment(armour.stealthRadius, "Stealth Radius", armour.id, undefined, physical.stealthRadius);
    armour.stealthDetection = minorlyModifyEquipment(armour.stealthDetection, "Stealth Detection", armour.id, undefined, physical.stealthDetection);
}

//updates the counters displaying resource amounts
function updateResources() {
    if(document.getElementById('rewardsScreen').style.visibility != 'visible' ) {
        setLevel();
        document.getElementById("experienceCount").innerText = simplifyNumber(troop.resources.experience);
    }
    setResourceCounters()
}
function setResourceCounters() {
    document.getElementById("creditCount").innerText = simplifyNumber(troop.resources.credits);
    document.getElementById("skillPointsCount").innerText = simplifyNumber(troop.resources.skillPoints);
    document.getElementById("metalCount").innerText = simplifyNumber(troop.resources.metals);
    document.getElementById("crystalCount").innerText = simplifyNumber(troop.resources.crystals);
    document.getElementById("levelCountText").innerText = troop.level;
}

function setLevel() {
    var cost = Math.pow(troop.level, 1.2) * 25;
    if(troop.resources.experience >  cost && troop.level < 30) {
        troop.resources.experience -= cost;
        troop.level += 1;
        troop.resources.skillPoints += 1;
        unlockAbilities(true);
        saveTraitToServer("level", "resources");
        showUpgradeAbilityScreen(true);
    }
}
function unlockAbilities(send) {
    unlockAbility("stamina", send);
    unlockAbility("force", send);
}

function upgradeLater(e) {
    if(e.target != e.currentTarget) return;
    document.getElementById("upgradeAbilityScreen").style.visibility = "hidden";
    tell(11, "Upgrading Later", "You can upgrade an ability whenever you want! Just go to the settings screen by clicking on the gear icon and click the button that says Select Ability Upgrade.");
    updateResources();
}

function showUpgradeAbilityScreen(leveledUp) {
    if(leveledUp == true) {
        document.getElementById("upgradeAbilityTitle").innerText = "Congradulations! You leveled up to level " + troop.level + "!";
        document.getElementById("upgradeAbilityText").innerHTML = "Choose to upgrade your Thunder Warrior's Health, Stamina, or Thaumaturgy.<br>You also earned 1 skill point!";
    } else {
        document.getElementById("upgradeAbilityTitle").innerText = "Time to choose your upgrade!";
        document.getElementById("upgradeAbilityText").innerHTML = "Choose to upgrade your Thunder Warrior's Health, Stamina, or Thaumaturgy.";
    }
        document.getElementById("upgradeAbilityScreen").style.visibility = "visible";
}

function getAbilityInfo(ability) {
    let table = document.getElementById("statsTable");
    var upgradedAbility = modifyAbility(copyObject(troop[ability]));
    var modifiedAbility = modifyAbility(addAbilityBase(copyObject(troop[ability])));
    setStatsTable(troop[ability], table, getUpgradeValues, true);
    document.getElementById("statsScreen").style.visibility = "visible";

    function getUpgradeValues(value, value2, name, unit, modifiable, description) {
        var mE;
        var sE;
        var cE;
        var pE;
        if(value2 == false) {
            mE = modifiedAbility[value];
            sE = upgradedAbility[value];
        } else if(value2 == true) {
            mE = value;
            sE = value;
        } else {
            mE = modifiedAbility[value][value2];
            sE = upgradedAbility[value][value2];
        }
        if(isNaN(sE) == true && sE != 0) {
           /* sE = "-";
            cE = "-";
            pE = "-";*/
        } else {
            cE = mE - sE;
            if(sE == 0) {
                pE = 0;
            } else {
                pE = cE / Math.abs(sE) * 100;
                if(pE == 0) {
                    pE = "-"
                }
            }
        }
        return [name, sE, mE, cE, pE, description, unit, modifiable];
    }
}

function showClassPurchaseOption() {
    newPurchase("Purchase More Attribute Points", "Attribute points enable you to power up your Thunder Warrior and give you a head start over the competition!", [ {
            src: "/image/attributePointsPurchaseCheap",
            text: "Purchase 5 attribute points to enhance your Thunder Warrior for only 50 <img class = crystalText src = '/image/CrystalIcon'>",
            button: "Small Purchase",
            effect: () => classPurchase(5, 50),
        }, {
            src: "/image/attributePointsPurchaseRegular",
            text: "Purchase 25 attribute points to masively ammplify your Thunder Warrior for only 125 <img class = crystalText src = '/image/CrystalIcon'>",
            button: "Regular Purchase",
            effect: () => classPurchase(25, 125),
        }, {
            src: "/image/attributePointsPurchaseLarge",
            text: "Purchase 125 attribute points to ultimately boost your Thunder Warrior for only 250 <img class = crystalText src = '/image/CrystalIcon'>",
            button: "Ultimate Purchase",
            effect: () => classPurchase(125, 250),
        }
    ])
}
function classPurchase(attributeReward, cost) {
    if (troop.resources.crystals >= cost) {
        increaseClassPoints(attributeReward);
        troop.fullClassPoints += attributeReward;
        setClassAddition();
        setClassSubtraction();
        troop.resources.crystals -= cost;
        saveTraitToServer(["resources", "crystals"], "fullClassPoints");
    } else {
        tell(13, "More Crystals Needed", "In order to make this Attribute Point purchase, you need more crystals. You can purchase more here.");
        crystalPurchasePopup();
    }
}
function crystalPurchase(purchase, crystals, cost) {
    let paymentScreen;
    purchaseType = purchase;
    paymentScreen = document.getElementById("paymentScreenTemplate").content.cloneNode(true);
    paymentScreen.querySelector(".purchaseUpgradeTitle").innerText = "Complete Purchase";
    paymentScreen.querySelector(".purchaseUpgradeText").innerText = "In order to complete your purchase of " + crystals + " Crystals for " + cost + "$, you must enter in information.";
    document.getElementById("homeScreen").appendChild(paymentScreen);
    

}
function crystalPurchasePopup() {
    newPurchase("Purchase More Crystals", "Crystals are you for a variety of purposes, including the purchase of attribute points.", [ {
            src: "/image/classCrystalsPurchaseCheap",
            text: "Purchase 100 crystals for only 1.99!",
            button: "Small Purchase",
            effect: () => crystalPurchase("Small Purchase", 100, "1.99"),
        }, {
            src: "/image/classCrystalsPurchaseRegular",
            text: "Purchase 500 crystals for only 4.99!",
            button: "Regular Purchase",
            effect: () => crystalPurchase("Regular Purchase", 500, "4.99"),
        }, {
            src: "/image/classCrystalsPurchaseLarge",
            text: "Purchase 100000 crystals for only 9.99!",
            button: "Ultimate Purchase",
            effect: () => crystalPurchase("Ultimate Purchase", 100000, "9.99"),
        }
    ])
}
function newPurchase(title, text, options) {
    let purchase = document.getElementById("purchaseTemplate").content.cloneNode(true);
    purchase.querySelector(".purchaseUpgradeTitle").innerText = title;
    purchase.querySelector(".purchaseUpgradeText").innerText = text;
    for(var i = 0; i < options.length; i ++) {
        let purchaseOption = document.querySelector("#classPointPurchase").content.cloneNode(true);
        purchaseOption.querySelector(".upgradePurchaseImage").src = options[i].src;
        purchaseOption.querySelector(".upgradeAbilityOptionText").innerHTML = options[i].text;
        purchaseOption.querySelector(".upgradeAbilityOptionButton").innerText = options[i].button;
        purchaseOption.querySelector(".upgradeAbilityOptionButton").onclick = options[i].effect;
        purchase.querySelector(".upgradePurchaseHolder").appendChild(purchaseOption);
    }
    document.getElementById("homeScreen").appendChild(purchase);
}

function selectedUpgradeAbility(type) {
    document.getElementById("upgradeAbilityScreen").style.visibility = "hidden";
    troop[type] = addAbilityBase(troop[type]);
    troop.upgradedLevel ++;
    troop[type].level ++;
    saveTraitToServer("upgradedLevel", type);
    updateResources();
    if(onPage == "homeScreen") setHomeScreen();
}

function addAbilityBase(ability) {
    for(var prop in ability.base) {
        ability[prop] += ability.base[prop];
    }
    return ability;
}

function unlockAbility(ability, send) {
    for(var i = 0; i < troop[ability].game.length; i ++) {
        if(troop[ability].game[i] != undefined && troop[ability].game[i].name == "locked" && troop[ability].game[i].level <= troop.level) {
            troop[ability].game[i] = undefined;
            if(send) tell(18, "Ability Slot Unlocked", "You have unlocked a new slot to equip a Stamina or Thaumaturgy ability!");
            saveTraitToServer([ability, "game"]);
        }
    }
}

function createAllImages() {
    var imagesCreated = 0;
    var imageCount = 74;
    var loadDate = Date.now();
    createImages();
    createPlayerImages(); // will in the future be refrenced from sign up
    function createImages() {
        createShopImages();
        createSimpleImage("lockIcon", "lockIcon");
        createSimpleImage("creditsSmall", "creditsSmall");
        createSimpleImage("creditsRegular", "creditsRegular");
        createSimpleImage("creditsUltimate", "creditsUltimate");
        createSimpleImage("metalsSmall", "metalsSmall");
        createSimpleImage("metalsRegular", "metalsRegular");
        createSimpleImage("metalsUltimate", "metalsUltimate");
        createSimpleImage("crystalsSmall", "crystalsSmall");
        createSimpleImage("crystalsRegular", "crystalsRegular");
        createSimpleImage("crystalsUltimate", "crystalsUltimate");
        createSimpleImage("skillPointsSmall", "skillPointsSmall");
        createSimpleImage("skillPointsRegular", "skillPointsRegular");
        createSimpleImage("skillPointsUltimate", "skillPointsUltimate");

    }

    function createShopImages() {
        createSimpleImage("creditsIcon", "creditsIcon");
        createSimpleImage("metalsIcon", "metalIcon");
        createSimpleImage("crystalsIcon", "CrystalIcon");
        createSimpleImage("moneysIcon", "moneyIcon");
        for(var i = 0; i < allMods.length; i ++) {
            createSimpleImage(allMods[i].type, allMods[i].src);
            allMods[i].width = 1;
            allMods[i].height = 1;
            allMods[i].imageName = {naturalHeight: 1, naturalWidth: 1}
        }
    }
    //Loads the images needed for a character
    function createPlayerImages() {
        for(var i = 0; i < armour.length; i ++) {
            createBasicImg(armour[i]);
        }
        for(var i = 0; i < meleeWeapons.length; i ++) {
            createBasicImg(meleeWeapons[i]);
        }
        for(var i = 0; i < rangedWeapons.length; i ++) {
            createBasicImg(rangedWeapons[i]);
            rangedWeapons[i].projectileId = rangedWeapons[i].id + "projectile";
        }
    }

    function createSimpleImage(id, src){
        if (src == "" || src == undefined) {
            console.error("failed to load Image", id);
            countImages();
        } else {
            var newImage = new Image();
            newImage.id = id;
            newImage.onload = function() {
                document.body.appendChild(newImage);
                newImage.style.visibility = 'hidden';
                countImages();
            }
            newImage.src = "/image/" + src;
        }
    }

    //creates a basic image needed for a trooer
    function createBasicImg(object) {
        var newImg = new Image();
        newImg.id = object.id;
        newImg.onload = function() {
            object.imageName = {id: object.id, src: object.srcFlat || object.src, naturalWidth: newImg.naturalWidth, naturalHeight: newImg.naturalHeight};
            document.body.appendChild(newImg);
            newImg.style.visibility = 'hidden';
            countImages();
        }
        newImg.src = "/image/" + object.src;
    }

    function countImages() {
        imagesCreated++;
        document.getElementById("loadStatus").innerText = "Loading Game " + (Math.round(imagesCreated / imageCount * 10000) / 100) + "%";
        if(imagesCreated == imageCount) {
            continuePageCreationWithLoadedImages();
        } else if(imagesCreated > imageCount) {
            console.error(`Too Many Images ${imagesCreated} of ${imageCount}: ERROR CODE 489 034`);
        }
    }
}

function continuePageCreationWithLoadedImages() {
    document.getElementById("loadStatus").innerText = "Building Game";
    createEternalEvents();
    updateResources();
    troop.resources.classPoints = troop.fullClassPoints;
    pageLoaded = true;
    showClassSelectionScreen();
    createHomeScreenEvents();
    setImages();
    hideLoadingScreen();
}
function applyTrooperAbilities() {
    let tempStam, tempThaum;
    if(troop.built == "redo") {
        tempStam = troop.stamina.abilities;
        tempThaum = troop.force.abilities;
    }
    troop.physical = copyObject(physical);
    troop.hp = copyObject(hitpoints);
    troop.stamina = copyObject(stamina);
    troop.force = copyObject(force);
    if(troop.built == "redo") {
        troop.stamina.abilities = tempStam;
        troop.force.abilities = tempThaum;
    }
}
function setDefaultTrooperValues() {
    stamina = {
        max: 1000, // maximum heat times 1000 and seconds it will take to cool down from max heat
        coolWaitTime: 7 * 1000, //seconds that must be waited before the gun begins to cool down when not overheated
        regenPerSecond: 40,
        level: 1,
        maxAbilities: 4,
        onDamage: 1,
        onKill: 150,
        drain: 10,
        name: 'Stamina',
        description: 'Stamina is primarilly used to power various abilities that use the bodies own strength rather than any supernatural powers. Stamina is also used to fuel all melee abilities, such as attacking and blocking.',
        abilities: [],
        game: [],
        gameKeys: ["Z", "X", "C", "V", "Q", "E", "R", "T", "Y", "U"],
    }
    force = {
        max: 1 * 1000, // maximum heat times 1000 and seconds it will take to cool down from max heat
        coolWaitTime: 7.5 * 1000, //seconds that must be waited before the gun begins to cool down when not overheated
        regenPerSecond: 0.2,
        level: 1,
        maxAbilities: 3,
        onDamage: 200,
        onKill: 250,
        drain: 50,
        name: 'Thaumaturgy',
        description: 'Thaumaturgy is used to create all sorts of magical affects. It is the fuel for all magical powers that can disrupt enemies, inflict great damage, or even assist allies.',
        abilities: [],
        game: [],
        gameKeys: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0"]

    }
    hitpoints = {
        max: 300, // max hitpoints
        coolWaitTime: 5 * 1000,
        regenPerSecond: 0.05, // amount regenerated per second
        onDamage: 2,
        onKill: 50,
        drain: 2.5,
        level: 1,
        baseDefense: 6.5, //base statistic
        name: 'Health',
        description: 'Health is the Thunder Warrior\'s lifeblood. The higher it is, the longer a thunder warrior is likely to survive and upon completely draining, the thunder warrior is destroyed. Some attacks dealth percent of health damage, which reduces an enemy thunder warrior\'s health by the stated percent of it\'s health, rather than dealing a static amount of damage.',
    }
    physical = {
        rangedDefense: 2,
        meleeDefense: 2,
        onlyMeleeDefense: 2,
        onlyRangedDefense: 2,
        stealthDetection: 1,
        stealthDetectionBase: 2,
        stealthRadius: 5,
        stealthRadiusBase: 2,
        weight: 3,
        moveSpeed: 4.2,
        jumpDelay: 0.3,
        accelerationSeconds: 0.65,
        decelerationSeconds: 0.35,
        knockbackResistance: 2,
        level: 1,
        name: 'Physical',
        description: 'Physicality improves the Thunder Warrior\'s use of and defense against physical attacks, including blaster fire and plasmablade strikes. The higher it is, the more damaging these weapons will be and the easier it will be to resist them.',
    }
    var baseAbilityStat = {
        tenacity: 3,
        duration: 4,
        activationTime: 1.4,
        cooldown: 2,
    }
    var baseStat = {
        criticalChance: 10,
        criticalDamage: 25,
        criticalResistance: 5,
        criticalDefense: 5,
        evasionChance: 10,
        evasionDefense: 25,
        accuracy: 5,
        accuracyDamage: 5,
        precision: 2,
        damage: 2,
        defense: 2,
    }
    physical = combineObjects(baseStat, physical);
    stamina = combineObjects(baseAbilityStat, combineObjects(baseStat, stamina));
    force = combineObjects(baseAbilityStat, combineObjects(baseStat, force));
}

function setDefaultPage() {
    createAbilityOptions();
    finishAllModCreation();
}

function pageCreationWithClassSelected(selected) {
    setAffiliationImageIcon();
    setDisplayImageSrcs();
    revealInfoBar();
    if(selected) saveTraitToServer("built", "unlockedHelmets",  "unlockedBodies", "unlockedLegs", "unlockedRightArms", "unlockedLeftArms", "unlockedRangedWeapons", "unlockedMeleeWeapons", "unlockedMods","hp", "physical", "stamina", "force", "rangedWeapon", "meleeWeapon", "playerImage", "affiliation", "sourceAffiliation");    
    revealHome();
}
function setAffiliationImageIcon() {
    if(troop.affiliation == "Rebellion") {
        document.getElementById("affiliationIcon").src = "/image/rebellionIconColored";
    } else {
        document.getElementById("affiliationIcon").src = "/image/empireIconColored";
    }
}
function rejoinGame(inGame) {
    if(inGame) {
        sessionStorage.setItem("gameData", JSON.stringify(getGameData()));
        sessionStorage.setItem("rejoin", "true");
        sessionStorage.setItem("nextGame", "");
        redirected = true;
        document.getElementById("startForm").submit();
    }
}

function modifyClassOption(el, mult) {
    let stat = classOptions[el.parentElement.getAttribute("data-classType")];
    let nums = el.parentElement.querySelectorAll(".numCounter");
    let cost = getNumCost(stat, mult > 0 ? 0 : -1, mult);
    if((mult > 0 && stat.value == nums.length) || (mult < 0 && stat.value == 0) || (cost > 0 && troop.resources.classPoints < cost)) return;
    increaseClassPoints(-cost);
    stat.value += mult;
    if(mult > 0) {
        increaseClassOptionVisuals(stat, nums, el);
    } else {
        decreaseClassOptionVisuals(stat, nums, el);
    }
    setClassAddition();
    setClassSubtraction();
    setAbilityDisplays();
    document.getElementById("classAffiliation").src = classOptions.rebellion.value >= 4 ? "/image/rebellionIconColored" : "/image/empireIconColored";
}

function increaseClassOptionVisuals(stat, nums, el) {
    setNums(nums, stat);
    setCosts(stat, nums, 1);
    if(stat.value == nums.length) el.classList.add("cantClick");
    if(stat.value == 1)
        el.parentElement.querySelector(".classSubtraction").classList.remove("cantClick")
}

function decreaseClassOptionVisuals(stat, nums, el) {
    for(var i = stat.value; i < nums.length; i ++) {
        if(nums[i].classList.contains("clickedClassOption")) {
            nums[i].classList.remove('clickedClassOption');
        }
    }
    setCosts(stat, nums, -1);
    if(stat.value == 0) el.classList.add("cantClick");
    if(stat.value == nums.length - 1)
        el.parentElement.querySelector(".classAddition").classList.remove("cantClick")
}

function setNums(nums, stat) {
    for(var i = 0; i < stat.value; i ++) {
        if(!nums[i].classList.contains("clickedClassOption")) {
            nums[i].classList.add('clickedClassOption');
        }
    }
}
function setClassAddition() {
    let classKeys = Object.keys(classOptions),
    classAdditions = document.getElementsByClassName("classAddition");
    for(var i = 0; i < classKeys.length; i ++) {
        let cost = getNumCost(classOptions[classKeys[i]], undefined, 1);
        if(!classAdditions[i].classList.contains("cantClick") && (troop.resources.classPoints < cost || classOptions[classKeys[i]].value > 6)) classAdditions[i].classList.add("cantClick");
        else if(classAdditions[i].classList.contains("cantClick") && (troop.resources.classPoints >= cost && classOptions[classKeys[i]].value < 7)) classAdditions[i].classList.remove("cantClick")        
    }
}
function setClassSubtraction() {
    let classKeys = Object.keys(classOptions),
    classSubtractions = document.getElementsByClassName("classSubtraction");
    for(var i = 0; i < classKeys.length; i ++) {
        let cost;
        if(classOptions[classKeys[i]].start == 0) continue;
        cost = getNumCost(classOptions[classKeys[i]], -1);
        if(classOptions[classKeys[i]].value > classOptions[classKeys[i]].start) cost *= -1;
        if(!classSubtractions[i].classList.contains("cantClick") && (troop.resources.classPoints < cost || classOptions[classKeys[i]].value == 0))
            classSubtractions[i].classList.add("cantClick");
        else if(classSubtractions[i].classList.contains("cantClick") && troop.resources.classPoints >= cost && classOptions[classKeys[i]].value != 0)
            classSubtractions[i].classList.remove("cantClick");
    }
}
function increaseClassPoints(cost) {
    troop.resources.classPoints += cost;
    document.getElementsByClassName("resourceCounter")[4].innerHTML = simplifyNumber(troop.resources.classPoints);
    document.getElementsByClassName("resourceCounter")[5].innerHTML = simplifyNumber(troop.resources.crystals);
}
function getNumCost(stat, modifier = 0, change = 0) {
    let mult = stat.start == 0 ? 1 : 6, refundMult = 1, cost;
    if((stat.value > stat.start && change < 0) || (stat.value < stat.start && change > 0)) {
        refundMult = -1;
    }
    cost = stat.value + 1 + modifier - stat.start;
    if(cost == 0) return 0;
    cost = refundMult * Math.floor(1 + Math.abs(cost) * mult / 2.25);
    if(stat.value + 1 + modifier - stat.start > 5) cost += refundMult;
    return cost;
}
function setCosts(stat, nums) {
    for(var i = 0; i < nums.length; i ++) {
        if(i == stat.value -1) {
            nums[i].innerText = getCostText(stat, -1, -1); 
        } else if(i == stat.value && i < nums.length) {
            nums[i].innerText = getCostText(stat, undefined, 1); 
        } else {
            nums[i].innerText = ""; 
        }
    }
}
function getCostText(stat, modifier, change) {
    let cost = -getNumCost(stat, modifier, change);
    if(cost >= 0) cost = "+" + cost;
    return cost;
}

function showClassSelectionScreen() {
    if(troop.built != "finished") {
        onPage = "classScreen";
        resetClassSelection();
        increaseClassPoints(0);
        applyTrooperAbilities();
        buildClassSelectionScreen();
        setAbilityDisplays();
        tell(12, "Welcome to the Character Customizer", "Press the plus button to increase the value of different attributes. Hover over the attribute to see how it will affect your thunder warrior.");
        setClassVisibility();
    } else {
        setDefaultPage();
        pageCreationWithClassSelected(false);
    }
}
function setClassVisibility() {
    document.getElementById("informationBar").style.visibility = "visible";
    document.getElementById("affiliationIcon").style.visibility = "hidden";
    document.getElementById("playerName").style.visibility = "hidden";
    document.getElementById("experienceDisplay").style.visibility = "hidden";
    document.getElementById("skillPointsDisplay").style.visibility = "hidden";
    document.getElementById("creditsDisplay").style.visibility = "hidden";
    document.getElementById("metalDisplay").style.visibility = "hidden";
    document.getElementById("shopIcon").style.visibility = "hidden";
    document.getElementById("shopIcon").style.visibility = "hidden";
    document.getElementById("classPointsDisplay").style.visibility = "visible";
    document.getElementById("crystalDisplay").style.visibility = "visible";
    document.getElementById("classSelectionScreen").style.visibility = "visible";
    document.getElementsByClassName("abilityImageDisplay")[0].classList.add("classAbilityImageDisplay");
}
function setClassScreen() {
    increaseClassPoints(0);
}
function resetClassSelection() {
    let classKeys;
    classKeys = Object.keys(classOptions);
    for(var i = 0; i < classKeys.length; i ++) {
        classOptions[classKeys[i]].value = classOptions[classKeys[i]].start;
    }
}
function buildClassSelectionScreen() {
    let plus = "\n\nPress the Green Plus to improve this attribute.\n\n";
    let minus = "\n\nPress the Red Minus to improve this attribute.\n\n";
    let classDescriptions = {
        strength: "Strength enhances a Thunder Warriors potential to fight in Melee combat." + plus + "Strength majorly increases Physical Damage, Stamina Damage, and Melee Defense. Strength Minorly increases Maximum Health, Physical Critical Damage, and Physical Accuracy Damage",
        dexterity: "Dexterity enhances a Thunder Warriors potential to fight in Ranged combat." + plus + " Dexterity majorly increases Movement speed, Stealth Radius, all Stamina gains, and Ranged Defense. Dexterity minorly increases Physical Critical Chance, Physical Precision, Physical Accuracy",
        constitution: "Constitution improves a Thunder Warrior's Survivability and Maximum Stamina." + plus + "Constitution majorly increases Maximum Health. Constitution minorly increases all health gains, Maximum Stamina, Critical Defense, and Health Drain",
        intelligence: "Intelligence greatly increases a Thunder Warrior's potential to use Thaumaturgy." + plus + "Intelligence majorly increases Maximum Thaumaturgy, Thaumaturgy Damage, and maximm Thaumaturgy Abilities. Intelligence minorly increases Thaumaturgy Precision",
        wisdom: "Wisdom improves a Thunder Warrior's ability to avoid damage and use Stamina abilities" + plus + "Wisdom majorly increases Evasion Chance, Physical Crit resistance, Stealth Detection, and Maximum Stamina Abilities. Minorly increases Stamina Precision and Thamaturgy and Stamina Tenacity",
        light: "Siding with the Light increases Stamina and Thaumaturgy defensive traits." + plus + "Light majorly increases Stamina and Thaumaturgy Critical Resistance. Minorly increases Stamina and Thaumaturgy Defense and Accuracy Chance. Minorly decreases Stamina and Thaumaturgy Cooldown",
        dark: "Siding with the Dark increases Stamina and Thaumaturgy defensive traits." + minus + "Dark majorly increases Stamina and Thaumaturgy Duration. Minorly increases Stamina and Thaumaturgy Damage, Accuracy Damage, Cooldown, and Drain",
        rebellion: "Affiliating with the Rebellion improves the ammount of Thaumaturgy and Stamina gained over time." + plus + "Majorly decreases Stamina and Thaumaturgy Recovery Delay, Gain on Kill, Gain on Damage and Activation Time. Majorly increases Stamina and Thaumaturgy Recovery and Critical Chance",
        empire: "Affiliating with the Empire improves the ammount of Thaumaturgy and Stamina gained from attacking enemies." + minus + "Majorly increases Stamina and Thaumaturgy Recovery Delay, Gain on Kill, Gain on Damage, and Activation Time and Critical Damage. Majorly decreases Stamina and Thaumaturgy Recovery",
        slight: "Choosing slightness improves a Thunder Warrior's speed, but makes them more susceptible to attacks." + plus + "Majorly Decreases weight. Majorly increases Movement Speed and Evasion Defense. Minorly decreases Health Recovery Delay, Acceleration Time, Deceleration Time, Knockback Resistance, Defense, and Jump Preparation time",
        heavy: "Choosing heavy improves a Thunder Warrior's makes them less susceptible to attacks, but also less manueverable." + minus + "Majorly Increases weight and Defense. Minorly decreases Movement Speed, Evasion Defense, and Health Recovery Delay. Minorly increases Acceleration time, Deceleration time, Knockback Resistance, and Jump Preparation Time",
    }, classKeys = Object.keys(classOptions), 
    classOption;
    document.getElementById("classOptionHolder").innerHTML = "";
    for(var i = 0; i < classKeys.length; i ++) {
        let clone = document.getElementById("classOptionTemplate").content.cloneNode(true);
        document.getElementById("classOptionHolder").appendChild(clone);
        
    }
    classOption = document.getElementsByClassName("classOption");
    for(var i = 0; i < classOption.length; i ++) {
        let clone = classOption[i];
        let nums = clone.querySelectorAll(".numCounter");
        let titles = clone.querySelectorAll(".classTitle");
        let infoTitles = clone.querySelectorAll(".classSellectionBoxTitle");
        let infoText = clone.querySelectorAll(".classSelectionBoxText");
        clone.setAttribute("data-classType", classKeys[i]);
        titles[0].innerText = classKeys[i];
        infoTitles[0].innerText = classKeys[i];
        infoText[0].innerText = classDescriptions[classKeys[i]];
        if(classOptions[classKeys[i]].backTitle == undefined) {
            titles[1].remove();
        } else {
            titles[1].innerText = classOptions[classKeys[i]].backTitle;
            infoTitles[1].innerText = classOptions[classKeys[i]].backTitle;
            infoText[1].innerText = classDescriptions[classOptions[classKeys[i]].backTitle];
        }
        if(classOptions[classKeys[i]].value == 0) clone.querySelector(".classSubtraction").classList.add("cantClick");

        setCosts(classOptions[classKeys[i]], nums);
        setNums(nums, classOptions[classKeys[i]]);
    }
}
function revealInfoBar() {
    document.getElementById("affiliationIcon").style.visibility = "visible";
    document.getElementById("playerName").style.visibility = "visible";
    document.getElementById("experienceDisplay").style.visibility = "visible";
    document.getElementById("skillPointsDisplay").style.visibility = "visible";
    document.getElementById("creditsDisplay").style.visibility = "visible";
    document.getElementById("metalDisplay").style.visibility = "visible";
    document.getElementById("crystalDisplay").style.visibility = "visible";
    document.getElementById("shopIcon").style.visibility = "visible";
    document.getElementById("shopIcon").style.visibility = "visible";
}

function finishTrooper() {
    let starterEquipment =  [troop.rangedWeapon, troop.meleeWeapon, troop.playerImage.head, troop.playerImage.body, troop.playerImage.legs, troop.playerImage.leftArm, troop.playerImage.rightArm]
    troop.rangedWeapon.sourceAffiliation = troop.sourceAffiliation;
    troop.meleeWeapon.sourceAffiliation = troop.sourceAffiliation;
    troop.rangedWeapon.sourceName = troop.username;
    troop.meleeWeapon.sourceName = troop.username;
    for(var i = 0; i < starterEquipment.length; i ++) {
        starterEquipment[i].rarity = "Junk";
        starterEquipment[i].level = 0;
        starterEquipment[i].rarityIncrease = 1;
        starterEquipment[i].power = getPower(starterEquipment[i]);
    }
}

//sets the default remaining properties for all mods - for now, all are set as common
function finishAllModCreation() {
    for(var i = 0; i < weaponMultipliers.length; i ++) {
        weaponMultipliers[i].id = weaponMultipliers[i].type;
        weaponMultipliers[i].playerImage = false;
    }
    for(var i = 0; i < meleeMultipliers.length; i ++) {
        meleeMultipliers[i].id = meleeMultipliers[i].type;
        meleeMultipliers[i].playerImage = false;
    }
    for(var i = 0; i < rangedMultipliers.length; i ++) {
        rangedMultipliers[i].id = rangedMultipliers[i].type;
        rangedMultipliers[i].playerImage = false;
    }
    for(var i = 0; i < armourMultipliers.length; i ++) {
        armourMultipliers[i].id = armourMultipliers[i].type;
        armourMultipliers[i].playerImage = false;
    }
}


function createHomeScreenEvents() {
    document.onkeydown = function (event) {
        if(onPage == "weaponPage" && (event.which == 87 || event.which == 38)) {
            scrollWeaponPage(-1);
        } else if (onPage == "weaponPage" && (event.which == 40 || event.which == 83)) {
            scrollWeaponPage(1);
        } else if(onPage == "weaponPage" && (event.which == 8 || event.which == 46) && selectedItem != "none") {
            deconstructMod();
        } else if (event.which == 73) {
            showMoreInfo();
        } else if (event.which == 27 && document.getElementById('statsScreen').style.visibility == 'visible') {
            hideStats(true);
        } else if(event.which == 70) {
            stFullScreen(document.getElementById("fullScreenIcon"));
        } else if(onPage == "abilityPage", event) {
            equipAbility(event.key, troop[abilityProperty]);
        }
    };
}

function getPageOptionName(name) {
    return name.substring(0, 1).toLowerCase() + name.substring(1).replace(/ /g, "") + "PageOption"
}

function equipAbility(key, ability) {
    if(viewingAbility == 'none' && ability != undefined) {
        let abilityIcon = document.getElementById(getPageOptionName(ability.name));
        setAbilities(ability, abilityIcon, abilityIcon.children[1], abilityIcon.children[0], false);
    } else if(viewingAbility != "none") {
        if(!unlocked(viewingAbility)) return;
        for(var i = 0; i < troop[abilityProperty].maxAbilities; i ++) {
            if(key.toUpperCase() == troop[abilityProperty].gameKeys[i]) {
                if(troop[abilityProperty].game[i] != undefined && troop[abilityProperty].game[i].name == "locked") return;
                for(var e = 0; e < troop[abilityProperty].maxAbilities; e ++) {
                    if(troop[abilityProperty].game[e] != undefined && troop[abilityProperty].game[e].name != "locked" && troop[abilityProperty].game[e].name == viewingAbility.name) {
                        troop[abilityProperty].game[e] = undefined;
                    }
                }
                troop[abilityProperty].game[i] = viewingAbility;
                saveTraitToServer("resources", [abilityProperty, "game"]);
                troop[abilityProperty].game;
                setGameAbilities(abilityProperty);
                setAbilityInstructions(viewingAbility);
                return;
            }
        }
    }
}

function showMoreInfo() {
    if(selectedItem != 'none' && isMod(selectedItem)) {
        if(moreInfo) {
            moreInfo = false;
        } else {
            moreInfo = true;
        }
        showWeaponDescription(hoveredDisplay, hoveredEquipment);
    } else if(selectedItem != 'none' && (onPage == "homeScreen" || onPage == "classScreen" || (onPage == 'weaponPage' && modsShowing == false))) {
        showStats(selectedItem);
        hideWeaponDescription();
        showWeaponDescription(hoveredDisplay, hoveredEquipment);
    } else if(document.getElementById('statsScreen').style.visibility == 'visible') {
        hideStats(true);
    }
}

function getProperty() {
    var equipment;
    if(modsShowing == true) {
        equipment = equipmentForModifications
    } else {
        equipment = selectedEquipment;
    }
    if(equipment.playerImage == true) {
        return ["playerImage", equipment.refrence, "mods", "equipped"];
    } else {
        return [equipment.refrence, "mods", "equipped"];
    }
}

function deconstructMod() {
    var found = {found: 0, property: ""}
    var reset = false;
    found = searchArrayForItem(false, troop.unlockedMods, found, "unlockedMods");
    found = searchArrayForItem(false, selectedEquipment.mods.equipped, found, getProperty());
    found = searchArrayForItem(true, troop.unlockedHelmets, found, "unlockedHelmets");
    found = searchArrayForItem(true, troop.unlockedBodies, found, "unlockedBodies");
    found = searchArrayForItem(true, troop.unlockedLegs, found, "unlockedLegs");
    found = searchArrayForItem(true, troop.unlockedLeftArms, found, "unlockedLeftArms");
    found = searchArrayForItem(true, troop.unlockedRightArms, found, "unlockedRightArms");
    found = searchArrayForItem(true, troop.unlockedRangedWeapons, found, "unlockedRangedWeapons");
    found = searchArrayForItem(true, troop.unlockedMeleeWeapons, found, "unlockedMeleeWeapons");
    if(found.found != 0) {
        if(modsShowing == true) {
            addResources(25 * found.found * getDeconstructBonus(), 0, 0);
        } else {
            let metalBonus = 0;
            let metalChance = Math.random();
            if(metalChance >= 0.9) {
                metalBonus = 2;
            } else if(metalChance >= 0.6) {
                metalBonus = 1
            }
            addResources(Math.floor(150 * found.found * getDeconstructBonus()), metalBonus, 0);
        }
        hideWeaponDescription();

        if(modsShowing == true) {
            fullEquipmentArray = checkModAvailability()[0];
        }
        setSelectedEquipmentArray();
        if(selectedEquipmentArray.length <= 8 || selectedEquipmentArray.length == 11) {
            reset = true;
        }
        setWeaponScreen(reset);
        updateResources();
        saveTraitToServer("resources", found.property);
    } else {
        console.error('Illegal Mod Reported Prior To Deletion: ERROR CODE 489 034')
    }
}

function getDeconstructBonus() {
    return 0.75 + Math.random() / 2;
}

function setWeaponScreen(reset) {
    document.getElementById("characterBackground").src = "/image/" + selectedEquipment.src;
    createNewOrResetSelection(reset);
    if(reset == true && selectedEquipmentArray.length < 12) {
        resetEquipmentSelections();        
    }
    setSelectionPositions();
    setSelectionOptionPlacements();
    hideExtraDisplays();
    setWeaponPageWeapon();
    setDisplayImageSrcs();
    setWeaponScreenText();
    setMods();
    updateModEvents();
    setStatsList(document.getElementById("statsTable"));
    setHelpfulText()
    resetModCounters();
    setSelectionEvents();
}

function resetModCounters() {
    let counters = document.getElementsByClassName('counter');
    for(var i = 0; i < counters.length; i ++) {
        counters[i].style.visibility = 'hidden';
    }
}

function setHelpfulText() {
    let name = getWeaponName();
    let text;
    if(! fullEquipmentArray.length > 0) {
        document.getElementById('helpfulText').style.display = 'block';
        if(modsShowing == true) {
            text = `You have no unlocked modifications available for the currently equipped ${name}. You can unlock new modifications in the shop for credits. More credits can be earned by playing games, deconstructing equipment and mods, or purchasing with crystals.`
        } else {
            text = `You have no unlocked ${name}s available. You can unlock new equipment in the shop for credits and metal. More credits and metal can be earned by playing games, deconstructing equipment and mods, or purchasing with crystals.`
        }
        document.getElementById('helpfulText').innerText = text ;
    } else {
        document.getElementById('helpfulText').style.display = 'none';
    }
}

function getWeaponName() {
    let slotType;
    let name;
    if(selectedEquipment.slot == "Melee" || selectedEquipment.slot == "Ranged") {
        slotType = ' weapon';
    } else {
        slotType = '';
    }
    name = selectedEquipment.slot + slotType;
    if(name[name.length - 1] == 's') name = name.slice(0, name.length - 1);
    return name;
}

function setSelectionPositions() {
    var yAddition = 0;
    for(var i = 0; i < selectedEquipmentArray.length; i ++) {
        while(25 * sizeUnits * i - (100 * sizeUnits * yAddition)> 77.5 * sizeUnits) {
            yAddition += 1;
        }
        document.getElementById("weaponSelectionBackground" + i).style.left = (2.5 * sizeUnits + 25 * sizeUnits * i - (100 * sizeUnits * yAddition)) + "px";
        document.getElementById("weaponSelectionBackground" + i).style.top = (equipmentSelections[i].y * sizeUnits) + "px";
        if(modsShowing && selectedEquipmentArray[i].rarityIncrease <= selectedEquipment.rarityIncrease) {
            setAllCursors(document.getElementById("weaponSelectionBackground" + i), "pointer");
        } else if(!modsShowing) {
            setAllCursors(document.getElementById("weaponSelectionBackground" + i), "pointer");
        } else {
            setAllCursors(document.getElementById("weaponSelectionBackground" + i), "default");
        }
    }
}

function setAllCursors(elem, type) {
    let children = elem.children;
    for(var i = 0; i < children.length; i ++) {
        children[i].style.cursor = type;
    }
    elem.style.cursor = type;
}

function resetEquipmentSelections() {
    var yAddition;
    for(var i = 0; i < selectedEquipmentArray.length; i ++) {
        yAddition =  Math.floor(i / 4);
        equipmentSelections[i].y = yAddition * 22.5 + 0.25;;
    }
    selectedEquipmentArray = getFirstValues(12, 0)

}

function hideExtraDisplays() {
    var i = selectedEquipmentArray.length;
    while (document.getElementById("weaponSelectionBackground" + i) != null) {
        document.getElementById("weaponSelectionBackground" + i).style.visibility = 'hidden';
        i++;
    }
}

function createNewOrResetSelection(reset) {
    var yAddition;
    for(var i = 0; i < selectedEquipmentArray.length; i ++) {
        yAddition =  Math.floor(i / 4);
        if(document.getElementById("weaponSelectionBackground" + i) == null){
            var weaponSelectionBackground = document.createElement("DIV");
            var weaponImg = document.createElement("IMG");
            var modCounter = document.createElement("DIV");
            var modsAvailable = document.createElement("DIV");
            weaponSelectionBackground.setAttribute("id", "weaponSelectionBackground" + i);
            equipmentSelections.push({y: yAddition * 22.5 + 0.25});
            document.getElementById("weaponPageMods").appendChild(weaponSelectionBackground);
            setEquipmentBackgroundColor(selectedEquipmentArray[i],document.getElementById("weaponSelectionBackground" + i));
            document.getElementById("weaponSelectionBackground" + i).style.position = "absolute";
            document.getElementById("weaponSelectionBackground" + i).style.borderRadius = 100000000 + "px";
            weaponImg.setAttribute("src", selectedEquipmentArray[(i)].src);
            weaponImg.setAttribute("id", "weaponSelection" + i);
            document.getElementById("weaponSelectionBackground" + i).appendChild(weaponImg);
            document.getElementById("weaponSelection" + i).style.position = "absolute";
            document.getElementById("weaponSelectionBackground" + i).appendChild(modCounter);
            document.getElementById("weaponSelectionBackground" + i).appendChild(modsAvailable);
            modCounter.classList.add('modCounter');
            modCounter.classList.add('counter');
            modsAvailable.classList.add('modsAvailable');
            modsAvailable.classList.add('counter');
        } else if(document.getElementById("weaponSelectionBackground" + i) != null && reset == true) {
            equipmentSelections[i].y = yAddition * 22.5 + 0.25;;
        }
    }
}

function searchArrayForItem(returnEquipped, itemArray, found, propertyString) {
    if(found.found == 0) {
        for(var i = 0; i < itemArray.length; i ++) {
            if(itemArray[i].id == selectedItem.id) {
                found.found = itemArray[i].rarityIncrease;
                if(returnEquipped) {
                    for(var e = 0; e < itemArray[i].mods.equipped.length; e ++) {
                        troop.unlockedMods.push(itemArray[i].mods.equipped[e]);
                    }
                }
                itemArray.splice(i, 1);
                return {found: found.found, property: propertyString};
            }
        }
    }
    return found;
}

function scrollWeaponPage(direction) {
    var yAddition = 0;
    var speed = 22.5 / 22;
    var hasSet = 0;
    if(selectedEquipmentArray.length > 8) {
        for(var i = 0; i < selectedEquipmentArray.length; i ++) {
            equipmentSelections[i].y += speed * direction;
            document.getElementById("weaponSelectionBackground" + i).style.top = (equipmentSelections[i].y * sizeUnits) + "px";
            hasSet = keepSelectionsOnScreen(i, direction, hasSet);
        }
    }
    if(hasSet != 0) {
        resetSelectionArray(getOldIndexStart(selectedEquipmentArray[0], fullEquipmentArray) - 4 * direction);
        setSelectionPositions();
        setSelectionEvents();
    }
}

function resetSelectionArray(addition) {
    var selectedEquipmentArrayIndexStart = 0;
    selectedEquipmentArrayIndexStart = addition;
    if( selectedEquipmentArray.length < 12 && selectedEquipmentArrayIndexStart == 12) { //+ 4 <= 0 && selectedEquipmentArrayIndexStart + 5 > 0 ) {
        selectedEquipmentArrayIndexStart = 0;
    }

    if( selectedEquipmentArray.length < 12 && selectedEquipmentArrayIndexStart == -4) { //+ 4 <= 0 && selectedEquipmentArrayIndexStart + 5 > 0 ) {
        selectedEquipmentArrayIndexStart = selectedEquipmentArray.length - (selectedEquipmentArray.length % 4);
    }
    selectedEquipmentArray = getFirstValues(12, selectedEquipmentArrayIndexStart);
}
function keepSelectionsOnScreen(i, direction, hasSet) {
    var setDirection = 0;
    if( Math.round(document.getElementById("weaponSelectionBackground" + i).offsetTop * 100) / 100 >= 48.25 * sizeUnits && (direction == 1 || direction == 0)) {
        setDirection = -1;
    } else if(document.getElementById("weaponSelectionBackground" + i).offsetTop + document.getElementById("weaponSelectionBackground" + i).offsetHeight < -3 && (direction == -1 || direction == 0)) {
        setDirection = 1;
    }
    if(setDirection != 0){
        equipmentSelections[i].y += setDirection * 22.5 * 3;
        document.getElementById("weaponSelectionBackground" + i).style.top = (equipmentSelections[i].y * sizeUnits) + "px";
        return setDirection;
    } else {
        return hasSet;
    }
}

function setSelectionEvents() {
    var firstOne = getFirstOne();
    for(var i = 0; i < selectedEquipmentArray.length; i ++) {
        if(i + firstOne > selectedEquipmentArray.length - 1) {
            firstOne -= selectedEquipmentArray.length;
        }
        setWeaponScreenSelections(i, -firstOne);
    }
}

function setSelectionOptionPlacements() {
    var firstOne = getFirstOne();
    for(var i = 0; i < selectedEquipmentArray.length; i ++) {
        if(i + firstOne > selectedEquipmentArray.length - 1) {
            firstOne -= selectedEquipmentArray.length;
        }
        document.getElementById("weaponSelectionBackground" + (i + firstOne)).style.width = (20 * sizeUnits) + "px";
        document.getElementById("weaponSelectionBackground" + (i + firstOne)).style.height = (20 * sizeUnits) + "px";
        keepSelectionsOnScreen((i + firstOne), 0);
    }
}


function getFirstOne() {
    var lowestOne = 10000;
    var firstOne = 0;
    for(var i = 0; i < 12; i += 4) {
        if(document.getElementById("weaponSelectionBackground" + i) != null && document.getElementById("weaponSelectionBackground" + i).offsetTop < lowestOne) {
            lowestOne = document.getElementById("weaponSelectionBackground" + i).offsetTop;
            firstOne = i;
        }
    }
    return firstOne;
}

function getOldIndexStart(shortArray, fullArray) {
    for(var i = 0; i < fullArray.length; i ++) {
        if(shortArray == fullArray[i]) {
            return i;
        }
    }
    return 0;
}

function hideTell(e) {
    if(e.target == e.currentTarget) {
        for(var i = 0; i < troop.tells.length; i ++) {
            if(troop.tells[i] != undefined) {
                if(troop.tells[i].showing == true) {
                    troop.tells[i].showing = false;
                    break;
                }
            }
        }
        document.getElementById("tellScreen").style.visibility = "hidden";
    }
}

function dontShowAgain(){
    for(var i = 0; i < troop.tells.length; i ++) {
        if(troop.tells[i] != undefined) {
            if(troop.tells[i].showing == true) {
                troop.tells[i].canShow = false;
                troop.tells[i].showing = false;
                saveTraitToServer(["tells"]);
                break;
            }
        }
    }
    document.getElementById("tellScreen").style.visibility = "hidden";
}

function tell(index, title, text) {
    for(var i = 0; i < troop.tells.length; i ++) {
        if(troop.tells[i] != undefined) {
            if(troop.tells[i].showing == true) {
                return;
            }
        }
    }
    if(troop.tells[index] != undefined && troop.tells[index].canShow == false) {
        return
    }
    if(troop.tells[index] == undefined) {
        troop.tells[index] = {showing: true};
    } else if (troop.tells[index].showing == false) {
        troop.tells[index].showing = true;
    }
    document.getElementById("tellScreen").style.visibility = "visible";
    document.getElementById("tellTitle").innerText = title;
    document.getElementById("tellText").innerText = text;
}

function selectClass() {
    if(troop.built != "redo") {
        setEquipmentDefaults();
        setDefaultPage();
    }
    setClassProperties();
    if(troop.built == "redo") unlockAbilities(false);
    else finishTrooper();
    troop.built = "finished";
    pageCreationWithClassSelected(true);
    hideClassScreen();
}

function hideClassScreen() {
    document.getElementById("classPointsDisplay").style.visibility = "hidden";
    document.getElementById("classSelectionScreen").style.visibility = "hidden";
    document.getElementsByClassName("abilityImageDisplay")[0].classList.remove("classAbilityImageDisplay");
}

function setClassProperties() {
    classModifyEquipment(troop.stamina);
    classModifyEquipment(troop.force);
    classModifyEquipment(troop.hp);
    classModifyEquipment(troop.physical);
    troop.stamina.game[9] = {name: "locked", level: 28};
    troop.stamina.game[8] = {name: "locked", level: 21};
    troop.stamina.game[7] = {name: "locked", level: 15};
    troop.stamina.game[6] = {name: "locked", level: 10};
    troop.stamina.game[5] = {name: "locked", level: 6};
    troop.stamina.game[4] = {name: "locked", level: 3};
    troop.stamina.game[3] = getAbilityStarter(staminaAbilities, "Heal");
    troop.stamina.game[2] = getAbilityStarter(staminaAbilities, "Jump");
    troop.stamina.game[1] = getAbilityStarter(staminaAbilities, "Run");
    troop.stamina.game[0] = getAbilityStarter(staminaAbilities, "ChangeWeapon");
    troop.force.game[9] = {name: "locked", level: 29};
    troop.force.game[8] = {name: "locked", level: 26};
    troop.force.game[7] = {name: "locked", level: 23};
    troop.force.game[6] = {name: "locked", level: 20};
    troop.force.game[5] = {name: "locked", level: 17};
    troop.force.game[4] = {name: "locked", level: 14};
    troop.force.game[3] = {name: "locked", level: 11};
    troop.force.game[2] = {name: "locked", level: 8};
    troop.force.game[1] = {name: "locked", level: 5};
    troop.force.game[0] = {name: "locked", level: 2};
    troop.stamina.game.length = troop.stamina.maxAbilities;
    troop.stamina.gameKeys.length = troop.stamina.maxAbilities;
    troop.force.game.length = troop.force.maxAbilities;
    troop.force.gameKeys.length = troop.force.maxAbilities;
    if(troop.built != "redo") {
        troop.stamina.abilities.push(troop.stamina.game[0], troop.stamina.game[1], troop.stamina.game[2], troop.stamina.game[3]);
        setAllAbilityOptions();
    }
    troop.affiliation = troop.sourceAffiliation = classOptions.rebellion.value >= 4 ? "Rebellion" : "Empire";
    setBase(troop.stamina);
    setBase(troop.force);
    setBase(troop.hp);
    setBase(troop.physical);
}
function setEquipmentDefaults() {
    troop.unlockedHelmets = [];
    troop.unlockedBodies = [];
    troop.unlockedLegs = [];
    troop.unlockedRightArms = [];
    troop.unlockedLeftArms = [];
    troop.unlockedRangedWeapons = [];
    troop.unlockedMeleeWeapons = [];
    troop.unlockedMods = [];
    troop.rangedWeapon = copyObject(rangedWeapons[0]);
    troop.meleeWeapon = copyObject(meleeWeapons[6]);
    troop.playerImage = {head: copyObject(armour[0]), body: copyObject(armour[1]), legs: copyObject(armour[2]), rightArm: copyObject(armour[3]), leftArm: copyObject(armour[4])}
}
function getAbilityStarter(abilities, refrence) {
    for(var i = 0; i < abilities.length; i ++) {
        if(abilities[i].refrence == refrence) return abilities[i];
    }
}

function setBase(ability) {
    let fraction = 0.1;
    let minorFraction = 0.03;
    ability.base = {};
    if(ability.max != undefined) {
        ability.base.drain = ability.drain * fraction;
        ability.base.max = ability.max * fraction;
        ability.base.regenPerSecond = ability.regenPerSecond * fraction;
        ability.base.onDamage = ability.onDamage * fraction;
        ability.base.onKill = ability.onKill * fraction;
        ability.base.coolWaitTime = - ability.coolWaitTime * fraction;
    }
    if(ability.damage != undefined) {
        ability.base.damage = ability.damage * fraction;
        ability.base.criticalChance = ability.criticalChance * fraction;
        ability.base.criticalDamage = ability.criticalDamage * fraction;
        ability.base.precision = ability.precision * fraction;
        ability.base.criticalResistance = ability.criticalResistance * fraction;
        ability.base.criticalDefense = ability.criticalDefense * fraction;
        ability.base.evasionChance = ability.evasionChance * fraction;
        ability.base.evasionDefense = ability.evasionDefense * fraction;
        ability.base.accuracy = ability.accuracy * fraction;
        ability.base.accuracyDamage = ability.accuracyDamage * fraction;
        ability.base.defense = ability.defense * fraction;
    }
    if(ability.duration != undefined) {
        ability.base.duration = ability.duration * fraction;
        ability.base.cooldown = - ability.cooldown * fraction;
        ability.base.activationTime = - ability.activationTime * fraction;
        ability.base.tenacity = ability.tenacity * fraction;
    }
    if(ability.baseDefense != undefined) {
        ability.base.baseDefense = ability.baseDefense * fraction;
    }
    if(ability.rangedDefense != undefined) {
        ability.base.rangedDefense = ability.rangedDefense * fraction;
        ability.base.meleeDefense = ability.meleeDefense * fraction;
        ability.base.onlyMeleeDefense = ability.onlyMeleeDefense * fraction;
        ability.base.onlyRangedDefense = ability.onlyRangedDefense * fraction;
        ability.base.stealthDetection = ability.stealthDetection * fraction;
        ability.base.stealthDetectionBase = ability.stealthDetectionBase * fraction;
        ability.base.stealthRadius = ability.stealthRadius * fraction;
        ability.base.stealthRadiusBase = ability.stealthRadiusBase * fraction;
        ability.base.moveSpeed = ability.moveSpeed * minorFraction;
        ability.base.accelerationSeconds = - ability.accelerationSeconds * fraction;
        ability.base.decelerationSeconds = - ability.decelerationSeconds * fraction;
        ability.base.weight = - ability.weight * minorFraction;
        ability.base.knockbackResistance = - ability.knockbackResistance * fraction;
    }
}
function saveTraitToServer() {
    var keys = [];
    var property;
    var values = [];
    for(var i = 0; i < arguments.length; i ++) {
        keys.push(arguments[i]);
        if(!Array.isArray(keys[i])) keys[i] = [keys[i]];
    }
    for(var i = 0; i < keys.length; i ++) {
        property = troop;
            for(var e = 0; e < keys[i].length; e ++) {
                property = property[keys[i][e]]
            }
        values.push(copyObject(property))
    }
    send("trooper object", {username: troop.username, keys: keys, values: values});
}

//updates the events for when you click on resource counters
function createEternalEvents() {
    for(var i = 0; i < document.getElementsByClassName("resourceDisplay").length; i ++) {
        createResourceCounterEvent(i);
    }
    document.getElementById("abilityAdvicHolder").onmouseover = () => {
        let abilityCount = getAbilityCount(troop[abilityProperty]);
        let text = "";
        if(troop[abilityProperty].name == "Stamina") {
            let otherAbilityCount = getAbilityCount(troop.force);
            if(abilityCount >= 1) {
                text += "At your level, it is recommended that you equip the following abilities:\n1. Jump - Equip a Jump ability. Jump abilities are essential for reaching high places."
                if(abilityCount >= 2) {
                    text += "\n2. Melee - Equip the ability Change Weapon. Change Weapon enables the use of a laser sword in battle."
                }
                if(abilityCount >= 3) {
                    text += "\n3. Survival - Equip either a Block, Defense, or Heal ability. Any of these abilities will improve survival in the arena."
                }
                if(abilityCount >= 4) {
                    text += "\n4. Movement - Equip an additional Mobility ability. In adition to the jump ability equipped in slot 1, an additional Movement ability allows much faster movement."
                }
                if(abilityCount >= 5) {
                    text += "\n5. Offense - Equip either an Offense, Strike, or Shot ability. Any of these abilities will improve and diversify offensive capabilities."
                }
                if(abilityCount >= 6) {
                    text += "\n6+. For the rest of the abilities, it is recommended that you try out other abilities and find out what you like. Remember that equipping too many similiar abilities can become redundant and become less useful."
                } else if(abilityCount == 7) {
                    text += "\n6. For the remaining ability, it is recommended that you try out other abilities and find out what you like. Remember that equipping too many similiar abilities can become redundant and become less useful."
                }
            } else {
                text += "You cannot currently equip any Stamina abilities"
                if(otherAbilityCount >= 1) {
                    text += ". Switch to the Thaumaturgy page and equip Thaumaturgy abilities"
                } else {
                    text += " or Thaumaturgy abilities. Come to this page once you reach a higher level to equip an ability.";
                }
            }
        } else {
            let otherAbilityCount = getAbilityCount(troop.stamina);
            text += "coming later";
        }
        document.getElementById("abilityAdviceText").innerText = text;
    };
}

//create the display events for rsources
function createResourceCounterEvent(index) {
    document.getElementsByClassName("resourceDisplay")[index].onmouseover = function() {
        document.getElementsByClassName("resourceDisplay")[index].style.backgroundColor = "#111133";
    }
    document.getElementsByClassName("resourceDisplay")[index].onmouseout = function() {
        document.getElementsByClassName("resourceDisplay")[index].style.backgroundColor = "#05051a";
    }
}

function simplifyNumber(num) {
    if(num >= 1000000000000000) {
            num /= 1000000000000000;
        num = roundResourceDisplay(num) + "Q";
    } else if(num >= 1000000000000) {
        num /= 1000000000000;
        num = roundResourceDisplay(num) + "T";
    } else if(num >= 1000000000) {
        num /= 1000000000;
        num = roundResourceDisplay(num) + "B";
    } else if(num >= 1000000) {
        num /= 1000000;
        num = roundResourceDisplay(num) + "M";
    } else if(num >= 1000) {
        num /= 1000;
        num = roundResourceDisplay(num) + "K";
    } else {
        num = roundResourceDisplay(num);
    }
    return num;
}

function roundResourceDisplay(num) {
    if(num > 100) {
        num = Math.floor(num);
    } else  if(num > 10) {
        num = Math.floor(num * 10) / 10;
    } else {
        num = Math.floor(num * 100) / 100;
    }
    return num;
}

//draws a part of a character
function drawCharacter(canvas, part, width, x, y){  
    canvas.drawImage(document.getElementById(part.imageName.id), x - width / 2, y - width / 2, width, width);
}

//draws a character's seprate parts individuallyfdsfdsdsadsdsffdsafdsfhjsda fhdjsksjkdaldhjfkdsjksa
function drawFullCharacter(canvas) {
    let sizeMultiplier = (document.getElementById("characterBackground").height / (11 + 16 + 27));
    drawCharacter(canvas, troop.playerImage.leftArm, 19 * sizeMultiplier, document.getElementById("characterBackground").width / 2 + 7 * sizeMultiplier, 22.5 * sizeMultiplier);    
    drawCharacter(canvas, troop.playerImage.legs, 27 * sizeMultiplier, document.getElementById("characterBackground").width / 2, 37 * sizeMultiplier);    
    drawCharacter(canvas, troop.playerImage.body, 16 * sizeMultiplier, document.getElementById("characterBackground").width / 2, 20 * sizeMultiplier);    
    if(troop.playerImage.head.type == "Festive Helmet") {
    drawCharacter(canvas, troop.playerImage.head, 13 * sizeMultiplier, document.getElementById("characterBackground").width / 2 - 0.25 * sizeMultiplier, 9.5 * sizeMultiplier);
    } else {
    drawCharacter(canvas, troop.playerImage.head, 11 * sizeMultiplier, document.getElementById("characterBackground").width / 2 - 0.25 * sizeMultiplier, 10.25 * sizeMultiplier);
    }
    drawCharacter(canvas, troop.playerImage.rightArm, 20 * sizeMultiplier, document.getElementById("characterBackground").width / 2 - 7.2 * sizeMultiplier, 23.5 * sizeMultiplier);
}
//shows the settings screen, eventually
function viewSettings() {
    document.getElementById("settingsScreen").style.visibility = "visible";
    if(troop.level > troop.upgradedLevel) {
        setOptionActive(document.getElementById("selectAbilityUpgradeSettingsOption"));
    } else {
        setInactiveOption(document.getElementById("selectAbilityUpgradeSettingsOption"));
    }
    if(troop.resources.crystals >= 50 && onPage != "classScreen") {
        setOptionActive(document.getElementById("resetAttributesPointsOption"));
        document.getElementById("crystalOptionText").style.cursor = "pointer";
    } else {
        setInactiveOption(document.getElementById("resetAttributesPointsOption"));
        document.getElementById("crystalOptionText").style.cursor = "default";
    }
}
function setOptionActive(option) {
    option.style.borderColor = "#ffffff";
    option.style.backgroundColor = "#11113383";
    option.style.color = "#ffffff";
    option.style.cursor = "pointer";
}
function setInactiveOption(option) {
    option.style.borderColor = "#aaaaaa";
    option.style.backgroundColor = "#0a0a1c83";
    option.style.color = "#aaaaaa";
    option.style.cursor = "default";
}
function resetAttributesPoints(e) {
    if(onPage == "classScreen") {
        tell(17, "Selecting Attribute Points", "You are currently selecting attributes and have no need of resetting them.");
    } else if(troop.resources.crystals >= 50) {
        troop.resources.crystals -= 50;
        troop.resources.classPoints = 25;
        troop.fullClassPoints = troop.resources.classPoints;
        troop.built = "redo";
        troop.upgradedLevel = 1;
        closeSettings(undefined, true);
        hideHomeScreen();
        showClassSelectionScreen();
        document.getElementById("homeScreen").style.visibility = "hidden";
        document.getElementsByClassName("abilityImageDisplay")[0].style.visibility = "visible"
        document.getElementById("settingsIcon").style.visibility = "visible";
        
        saveTraitToServer("built", "upgradedLevel", ["resources", "crystals"], "fullClassPoints");


    } else {
        tell(16, "More Crystals Needed", "In order to make this Attribute Point purchase, you need more crystals. You can purchase more here.");   
    }
}

function showStats(equipment) {
    document.getElementById("statsScreen").style.visibility = "visible";
    var modifiedEquipment = onPage == "classScreen" ? classModifyEquipment(copyObject(equipment)) : modifyWhichEquipment(copyObject(equipment), "accuratelyModified");
    setStatsTable(equipment, document.getElementById("statsTable"), getValues, false);

    function getValues(value, value2, name, unit, modifiable, description) {
        var mE;
        var sE;
        var cE;
        var pE;
        if(value2 == false) {
            mE = modifiedEquipment[value];
            sE = equipment[value];
        } else if(value2 == true) {
            mE = value;
            sE = value;
        } else {
            mE = modifiedEquipment[value][value2];
            sE = equipment[value][value2];
        }
        if(isNaN(sE) == true && sE != 0) {
            sE = "-";
            cE = "-";
            pE = "-";
        } else {
            cE = mE - sE;
            if(sE == 0) {
                pE = "-";
            } else {
                pE = cE / Math.abs(sE) * 100;
            }
        }
        return [name, mE, sE, cE, pE, description, unit, modifiable];
    }
}

function getRangedTableData(equipment, getValues) {
    let type = ["Thaumaturgy", "Stamina", "Health", "Physical"];
    let tableData = [
        getValues("damage", false, "Physical Damage", "HP", true, "The amount of Physical Damage dealt with each hit from the weapon's projectiles"),
        getValues("range", false, "Range", "U", true, "The distance the projectiles fired can travel while dealing maximum damage upon a hit. A projectile can travel up to three times its range, but with damage diminishing to 15%."),
        valueAlteration(getValues("firingSpeed", false, "Firing Speed", "T", true, "The maximum rate per second at which the weapon can fire"), 0.001),
        valueAlteration(getValues("projectileSpeed", false, "Projectile Speed", "U", true, "The distance the projectile travels per second"), 1000 / 60),
        getValues("spreadMax", false, "Spread", '\xB0', true, "The angle in degrees of the spread of the weapon's projectiles"),
        getValues("heat", "max", "Maximum Heat", "H", true, "The weapon's maximum heat"),
        getValues("heat", "increase", "Heat Increase", "H", true, "The weapon heat gained when firing"),
        valueAlteration(getValues("heat", "coolWaitTime", "Cool Delay", "T", true, "The time in seconds it takes after being last fired before the weapon begins to cool"), 0.001),
        valueAlteration(getValues("heat", "overheatTime", "Overheat Time", "T", true, "The delay in seconds before cooling when the weapon overheats"), 0.001),
        valueAlteration(getValues("heat", "max", "Cool Time", "T", true, "The time it takes in seconds for the weapon to cool once cooling has begun"), 0.001),
        getValues("delay", false, "Shoot Delay", "T", true, "The delay after shooting begins when and projectiles start being fired"),
    ]
    return tableData;
}


function getWeaponTableData(equipment, getValues) {
    let type = ["Thaumaturgy", "Stamina", "Health", "Physical"];
    let tableData = [
        getValues("equipTime", false, "Equip Time", "T", false, "The time it takes to equip the weapon"),
        getValues("initTime", false, "Initialize Time", "T", true, "The delay before the weapon can be used after equipping it"),
        getValues("criticalChance", false, "Critical Chance", "%", true, "The chance to score a critical hit"),
        getValues("criticalDamage", false, "Critical Damage", "%HP", true, "The percent of bonus damage dealt upon landing a critical hit"),
        getValues("accuracy", false, "Accuracy", "%", true, "The percent by which enemies' evasion chance are reduced"),
        getValues("accuracyDamage", false, "Accuracy Damage", "%HP", true, "Decreases the percent of damage that is lost when an attack is evaded"),
        getValues("precision", false, "Precision", "D", true, "The amount by which the effectiveness of enemy armour is reduced"),
    ];
    for(var i = 0; i < type.length; i ++) {
        if(equipment[type[i]] != undefined) {
            tableData.push(
                getValues("<b>" + type[i] + "</b>", true, "Trait Type", "", false, "The following traits of this weapon will effect the " + type[i] + " Offensive traits of the entire Thunder Warrior"),
            );
            if(type[i] != "Health") {
                tableData.push(
                    getValues(type[i], "criticalChance", "Critical Chance", "%", true, "The chance to score a critical hit with a " + type[i] + " attack"),
                    getValues(type[i], "criticalDamage", "Critical Damage", "%HP", true, "The percent of bonus damage dealt upon landing a critical hit with a " + type[i] + " attack"),
                    getValues(type[i], "accuracy", "Accuracy", "%", true, "The percent by which enemies' " + type[i] + " evasion chance are reduced"),
                    getValues(type[i], "accuracyDamage", "Accuracy Damage", "%HP", true, "Decreases the percent of damage that is lost when a " + type[i] + " attack is evaded"),
                    getValues(type[i], "precision", "Precision", "D", true, "The amount by which the effectiveness of enemy armour is reduced while taking damage from a " + type[i] + " attack"),
                    getValues(type[i], "damage", "Damage", "%HP", true, "The increased damage that is dealt by all " + type[i] + " attacks"),
                );  
            }
            if(type[i] != "Physical") {
                if(type[i] != "Health") {
                    tableData.push(getValues(type[i],"activationTime", "Activation Time", "%T", true, "The percent by which the activation time of " + type[i] + " effects are decreased"));
                    tableData.push(getValues(type[i],"duration", "Duration", "%T", true, "The percent by which the duration of " + type[i] + " effects are increased"));
                    tableData.push(getValues(type[i],"cooldown", "Cooldown", "%T", true, "The percent by which the cooldown of " + type[i] + " effects are derceased"));
                }
                let abreviation = getAbility(type[i], true);
                tableData.push(
                    getValues(type[i], "onDamage", "On Damaging", "%" + abreviation, true, "The amount of " + type[i] + " gained as a percent of damage dealt, doubled when dealing Physical Damage"),
                    getValues(type[i], "onKill", "On Kill", abreviation, true, "The amount of " + type[i] + " gained upon defeating an enemy"),
                    getValues(type[i], "drain", "Drain", "%" + abreviation, true, "The amount of " + type[i] + " drained from an enemy upon attacking them, as a percent of damage dealt")
                );
            }
        }
    }
    return tableData;
}

function getMeleeTableData(equipment, getValues) {
    return [
        getValues("<b>Strike</b>", true, "Trait Type", "", false, "The following traits effect the weapon's ability to strike"),
        getValues("strike", "damage", "Physical Damage", "HP", true, "The amount of Physical Damage dealt with each hit from the weapon"),
        getValues("strike", "radius", "Strike Radius", "U", true, "The radius of attacks"),
        getValues("strike", "angle", "Strike Angle", "U", true, "The angle of effect that enemies are damaged during an attack"),
        getValues("strike", "knockback", "Strike Knockback", "U", true, "The ammount of knockback inflicted upon an enemy after landing a melee attack. The enemy is knocked back this many Game Units every second at a deteriorating rate."),
        getValues("strike", "cost", "Attack Cost", "S", true, "The stamina used up when attacking"),
        getValues("strike", "duration", "Strike Duration", "T", true, "The total duration of the strike, which is completed before the Strike Cooldown begins"),
        getValues("strike", "delay", "Strike Speed", "T", true, "The time between when the strike starts and when enemies are damaged"),
        getValues("strike", "wait", "Strike Cooldown", "T", true, "The cooldown after striking before the weapon can be used again"),
        getValues("<b>Block</b>", true, "Trait Type", "", false, "The following traits effect the weapon's overall ability to block"),
        getValues("block", "imediateDrain", "Block Cost", "S", true, "The stamina used up when beginning to block"),
        getValues("block", "continualDrain", "Block Drain", "S", true, "The stamina used up every second by continously blocking with this weapon"),
        getValues("block", "minTime", "Minimum Block", "T", true, "The minimum ammount of time that must be spent blocking with each use"),
        getValues("block", "wait", "Block Cooldown", "T", true, "The cooldown after blocking before the weapon can be used again"),
        getValues("block", "parryTime", "Parry Duration", "T", true, "The ammount of time during which parrying is available once blocking starts. Parried projectiles are sent back at their sources. Parried strikes have their sources knocked backed and stunned. Parried Thaumaturgy Attacks are redirected at their source."),
        getValues("<b>Block Projectile</b>", true, "Trait Type", "", false, "The following traits effect the weapon's ability to block projectiles"),
        getValues("block", "projectileAngle", "Reflection Angle", "\xB0", true, "The angle in degrees used to block projectiles"),
        getValues("block", "reflectionRange", "Reflection Range", "U", true, "The range of reflected projectiles. Increased by 75% when parrying."),
        getValues("block", "reflectionSpread", "Reflection Spread", "\xB0", true, "The maximum degrees of the random spread that effects the angle that a reflected projectile travels in. Decreased by 90% when parrying"),
        getValues("block", "reflectionDrain", "Reflection Cost", "S", true, "The stamina used up when blocking a projectile. Decreased by 50% when parrying."),
        getValues("<b>Block Melee</b>", true, "Trait Type", "", false, "The following traits effect the weapon's ability to block melee weapons"),
        getValues("block", "stabAngle", "Defelction Angle", "\xB0", true, "The angle in degrees used to block Plasmablade strikes"),
        getValues("block", "knockback", "Block Knockback", "U", true, "The ammount of knockback inflicted upon an enemy after blocking a melee attack. Increased by 50% when parrying."),
        getValues("block", "stun", "Stun Time", "T", true, "The time for which an enemy is stunned after their melee attack is blocked. Increased by 300% when parrying."),
        getValues("block", "enemyStabDrain", "Enemy Redirection Drain", "S", true, "The stamina that an enemy uses up when a melee attack is deflected. Increased by 50% when parrying."),
        getValues("block", "ownStabDrain", "Deflection Cost", "S", true, "The stamina used up when blocking a melee weapon. Decreased by 50% when parrying."),
        getValues("<b>Block Thaumaturgy</b>", true, "Trait Type", "", false, "The following traits effect the weapon's ability to block Thaumaturgy attacks. Only some Block abilities can block thaumaturgy attacks."),
        getValues("block", "thaumAngle", "Redirection Angle", "\xB0", true, "The angle in degrees used to block Thaumaturgy abilities"),
        getValues("block", "enemyThaumDrain", "Enemy Redirection Drain", "S", true, "The stamina that an enemy uses up when a Thaumaturgy attack is deflected. Increased by 50% when parrying."),
        getValues("block", "ownThaumDrain", "Redirection Cost", "S", true, "The stamina used up when blocking a Thaumaturgy attack. Decreased by 50% when parrying."),
        getValues("<b>General</b>", true, "Trait Type", "", false, "The following traits effect the weapon's overall usage"),
    ]
}

function getArmourTableData(equipment, getValues) {
    let type = ["Thaumaturgy", "Stamina", "Health", "Physical"];
    let tableData = [
        getValues("defense", false, "Defense", "D", true, "The amount by which damage taken is reduced"),
        getValues("weight", false, "Weight", "", true, "The amount by which the armour decreases speed and agility"),
        getValues("stealthRadius", false, "Stealth Radius", "U", true, "The amount by which the radius in which stealth is visible to enemies is decreased"),
        getValues("stealthDetection", false, "Stealth Detection", "U", true, "The amount by which the radius of revealing stealthed enemies is increased"),
        getValues("rangedDefense", false, "Ranged Defense", "D", true, "The Defense added against ranged attacks"),
        getValues("meleeDefense", false, "Melee Defense", "D", true, "The defense added against melee attacks"),
    ];
    for(var i = 0; i < type.length; i ++) {
        if(equipment[type[i]] != undefined) {
            tableData.push(
                getValues("<b>" + type[i] + "</b>", true, "Trait Type", "", false, "The following traits of this armour will effect the " + type[i] + " Defensive traits of the entire Thunder Warrior"),

            );
            if(type[i] != "Health") {
                tableData.push(
                    getValues(type[i], "criticalResistance", "Critical Resistance", "%", true, "The decresased chance of taking a critical hit from a " + type[i] + " attack"),
                    getValues(type[i], "criticalDefense", "Critical Defense", "%HP", true, "The percent by which damage is decreased upon taking a critical hit from a " + type[i] + " attack"),
                    getValues(type[i], "evasionChance", "Evasion Chance", "%", true, "The chance to take decreased damage from a " + type[i] + " attack"),
                    getValues(type[i], "evasionDefense", "Evasion Defense", "%HP", true, "The percent by which damage is decreased upon evading a " + type[i] + " attack"),
                );
            }
            if(type[i] != "Physical") {
                if(type[i] != "Health") {
                    tableData.push(
                        getValues(type[i], "tenacity", "Tenacity", "%T", true, "The percent by which the Effect Duration of enemy " + type[i] + " abilities are decreased"),
                        getValues(type[i], "defense", "Defense", "D", true, "The percent by which all damage from " + type[i] + " attacks is reduced"),);
                }
                tableData.push(
                    getValues(type[i], "regen", "Recovery", getAbility(type[i], true), true, "The speed at which " + type[i] + " is regenerated"),
                );
            }
        }
    }
    return tableData
}

function getSkillTableData(ability, getValues) {
    let troopAbility = modifyWhichEquipment(copyObject(troop[ability.abilityType || ability.abilityType]));
    let tableData, duration = ability.duration, activationTime = ability.activationTime;
    let classDescription = {
        Mobility: "Mobility abilities are new forms of Movement. The cost of mobility abilities are increased by weight.",
        Saber: "Saber abilities are actions that can be taken with a saber. Saber abilities use and modify the traits of the melee weapon. Saber abilities can only be acivated once a saber is equipped. No more than one Jump ability can be activated at a time.",
        Combat: "Combat abilities are enhancements to offensive and defensive capabilities.",
        Run: "A Run ability is active for as long as the key is held down. Run abilities primarilly increase movement speed. No more than one Boost or Run ability can be activated at a time.",
        Jump: "A Jump abilitiy is essential to every game. Jump abilities are different ways to leap into the air and travel upwards.",
        Strike: "A Strike ability is an enhanced strike or series of enhanced strikes with the saber.",
        Block: "A Block ability is active for as long as the key is held down. Block abilities prevent damage from attacks. Some block abilities can parry, refleting attacks back at the attacker.",
        Defense: "A Defense ability increases defensive capabilities for a short time.",
        Offense: "An Offense ability increases offensive capabilities for a short time.",
        Buff: "A Buff ability provides enhancements for a brief duration.",
        Boost: "A Boost ability temporarilly gives an increase to movement. No more than one Boost or Run ability can be activated at a time.",
        Shot: "A Shot ability is an amproved shot or series of shots with the ranged weapon. Shot abilities use and modify the traits of the ranged weapon. Shot abilities require that a ranged weapon is equipped. No more than one Shot ability can be activated at a time.",
        Utility: "A Uitility ability is an essential function that is carried out.",
        Support: "A Support ability assists allies.",
        Transpose: "A Transpose ability moves enemies in benefficial ways.",
        Debuff: "A Debuff ability hampers an enemy's ability to fight.",
        Damage: "The main purpose of a Damage ability is simply to remove enemy Health.",
        Immobalize: "Immobalize abbilities reduce enemy movement.",
        Domminance: "A Domminance ability decimates enemies through variouse means.",
        Movement: "A Movement ability increases the potential for manueverability of allies.",
    }

    if(duration == 0) duration = "instant";
    if(activationTime == 0) activationTime = "instant";
    tableData = [
        getValues("<b>General</b>", true, "Trait Type", "", false, "The following traits describe the ability and it's overall usage"),
        getValues("class", false, "Class", "", false, "The classification to which the ability belongs. " + classDescription[ability.class]),
        getValues("subclass", false, "Subclass", "", false, "The more specific classification to which the ability belongs. " + classDescription[ability.subclass]),
        getValues(getAbilityDescription(ability, false), true, "Description", "", false, "The description of the ability"),
        getValues(troopAbility.name, true, "Type", "", false, "The type of ability, and the main source of it's power: either Stamina or Thaumaturgy"),
        getValues(ability.ultimate ? "Ultimate" : "Regular", true, "Strength", "", false, "The strength of the ability, either Regular or Ultimate. Most abilities are regular. The most powerful abilities are ultimate, though they have a greater cost"),
        getValues("staminaCost", false, "Stamina Cost", "S", ability.subclass == "Strike", "The ammount of Stamina that is consumed when this ability is activated" + (ability.subclass == "Shot" ? ". The cost is increased using the weapon's strike cost" : (ability.subclass == "Block" ? ".The cost is entirely based off of the weapon's block cost." : ""))),
        getValues("thaumaturgyCost", false, "Thaumaturgy Cost", "Th", false, "The ammount of Thaumaturgy that is consumed when this ability is activated"),
        getValues(isNaN(activationTime) ? activationTime : "activationTime", isNaN(activationTime), "Activation Time", "T", !isNaN(activationTime), "The time it takes for the ability to activate"),
        getValues(isNaN(duration) ? duration : "duration", isNaN(duration), "Duration", "T", !isNaN(duration), "The ammount of time for which the ability is active. The Duration is not reduced by " + ability.abilityType + " Tenacity."),
        getValues("cooldown", false, "Cooldown", "T", true, "The ammount of time after an ability has been activated and its duration is complete, before the ability can be used again"),
        getValues(ability.solo ? "Solo" : "Compatible", true, "Compatability", "", false, "Whether or not the ability can be activated at the same time as others. Any number of Compatable abbilities can be activated at once, but only one Solo ability can be activated a once."),
    ];
    if(ability.effectDuration > 0) tableData.splice(10, 0, getValues("effectDuration", false, "Effect Duration", "T", true, "The ammount of time for which the negative effect of the ability that is placed uppon enemies is active. The Effect Duration is reduced by enemy " + ability.abilityType + " Tenacity."), );
    if(ability.staminaDrain != undefined) tableData.splice(8, 0, getValues("staminaDrain", false, "Stamina Drain", "S", false, "The ammount of Stamina that is drained every second taht the ability is activated") );
    if(ability.damage != undefined) tableData.push( getValues("damage", false, "Thaumaturgy Damage", "HP", true, "The ammount of Thaumaturgy Damage that is dealt immediately upon activation of the ability."), );
    if(ability.effectDamage != undefined) tableData.push( getValues("effectDamage", false, ability.abilityType + " Damage Over Time", "HP", true, "The ammount of " + ability.abilityType + " damage that is dealt every second to targets affected by the ability"), );
    if(ability.subclass == "Shot" || ability.subclass == "Strike") {
        if(ability.subclass == "Shot") {
            tableData.push(
                getValues("shotCount", false, "Shot Count", "", false, "The number of shots that this ability fires"),
            );
        } else {
            tableData.push(
                getValues("strikeCount", false, "Strike Count", "", false, "The number of shots that this ability fires"),
            );
        }
        tableData.push(
            getValues("<b>Multiplier</b>", true, "Trait Type", "", false, "The following traits are used to calculate the ability's traits"),
            valueAlteration(getValues("damageMult", false, "Damage Mult", "%", false, "Multiplies the weapon's Damage"), 100),
            valueAlteration(getValues("critChanceMult", false, "Criticial Chance Mult", "%", false, "Multiplies the weapon's Criticial Chance"), 100),
            valueAlteration(getValues("critDamageMult", false, "Critical Damage Mult", "%", false, "Multiplies the weapon's Critical Damage"), 100),
            valueAlteration(getValues("accuracyChanceMult", false, "Accuracy Mult", "%", false, "Multiplies the weapon's Accuracy"), 100),
            valueAlteration(getValues("accuracyDamageMult", false, "Accuracy Damage Mult", "%", false, "Multiplies the weapon's Accuracy Damage"), 100),
            valueAlteration(getValues("precisionMult", false, "Precision Mult", "%", false, "Multiplies the weapon's Precision"), 100),
        );
        if(ability.subclass == "Shot"){
            tableData.push(
                valueAlteration(getValues("rangeMult", false, "Range Mult", "%", false, "Multiplies the weapon's Range"), 100),
                valueAlteration(getValues("firingSpeedMult", false, "Firing Speed Mult", "%", false, "Multiplies the weapon's Firing Speed"), 100),
                valueAlteration(getValues("speedMult", false, "Speed Mult", "%", false, "Multiplies the weapon's Speed"), 100),
                valueAlteration(getValues("spreadMult", false, "Spread Mult", "%", false, "Multiplies the weapon's Spread"), 100),
                valueAlteration(getValues("costMult", false, "Heat Increase Mult", "%", false, "Multiplies the weapon's Heat Increase"), 100),
            );
        } else {
            tableData.push(
                valueAlteration(getValues("radiusMult", false, "Radius Mult", "%", false, "Multiplies the weapon's Radius"), 100),
                valueAlteration(getValues("knockbackMult", false, "Knockback Mult", "%", false, "Multiplies the weapon's Knockback"), 100),
                valueAlteration(getValues("costMult", false, "Stamina Cost Mult", "%", false, "The plasma blade's Attack Cost is multiplied by the ability's Stamina Cost Mult before being added to the ability's base stamina cost in order to form the ability's full stamina cost"), 100),
            );
        }
        tableData.push(
            getValues("<b>Multiplied Offensive Traits</b>", true, "Trait Type", "", false, "The following offensive traits were calculated using the weapon's modified statistics and the ability multipliers"),
        );
        if(ability.subclass == "Shot") {
            tableData.push(
                getValues("damage", false, "Physical Damage", "HP", false, "The amount of Physical Damage dealt with each hit from the weapon's projectiles"),
                getValues("range", false, "Range", "U", false, "The maximum distance the projectiles fired can travel"),
                valueAlteration( getValues("firingSpeed", false, "Firing Speed", "T", false, "The maximum rate per second at which the weapon can fire"), 0.001),
                valueAlteration( getValues("speed", false, "Projectile Speed", "U", false, "The distance the projectile travels per second"), 1000 / 60),
                getValues("spread", false, "Spread", '\xB0', false, "The angle in degrees of the spread of the weapon's projectiles"),
                getValues("cost", false, "Heat Increase", "H", false, "The weapon heat gained when firing"),
                getValues("staminaDamage", false, "Stamina Damage", "HP", true, "The amount of Stamina Damage dealt with each hit from the weapon"),

            );
        } else {
            tableData.push(
                getValues("damage", false, "Physical Damage", "HP", false, "The amount of Physical Damage dealt with each hit from the weapon"),
                getValues("radius", false, "Radius", "U", false, "The radius of attacks"),
                getValues("knockback", false, "Knockback", "U", false, "The ammount of knockback inflicted upon an enemy after landing a melee attack"),
                getValues("strikeCooldown", false, "Strike Cooldown", "U", false, "The cooldown after striking before the weapon can be used again"),
            );
        }
        tableData.push(
            getValues("critChance", false, "Critical Chance", "%", false, "The chance to score a critical hit"),
            getValues("critDamage", false, "Critical Damage", "%HP", false, "The percent of bonus damage dealt upon landing a critical hit"),
            getValues("accuracyChance", false, "Accuracy", "%", false, "The percent by which enemies' evasion chance are reduced"),
            getValues("accuracyDamage", false, "Accuracy Damage", "%HP", false, "Decreases the percent of damage that is lost when an attack is evaded"),
            getValues("precision", false, "Precision", "D", false, "The amount by which the effectiveness of enemy armour is reduced"),
            getValues("<b>Offensive Traits</b>", true, "Trait Type", "", false, "The following are the offensive traits of ability, which are not calculated using the ability's multipliers"),
            getValues("staminaDamage", false, "Stamina Damage", "HP", true, "The amount of Stamina Damage dealt with each hit from the weapon" + (ability.subclass == "Shot" ? 's projectiles' : '')),
        );
    } else if(ability.subclass == "Block") {
        tableData.push(
            getValues("<b>Multiplier</b>", true, "Trait Type", "", false, "The following traits are used to calculate the ability's traits"),
            valueAlteration(getValues("costMult", false, "Stamina Cost Mult", "%", false, "The plasma blade's Block Cost, Deflection Cost, Reflection Cost, and Redirection Cost are multiplied by the ability's Stamina Cost Mult"), 100),
            valueAlteration(getValues("drainMult", false, "Stamina Drain Mult", "%", false, "The plasma blade's Drain Cost is multiplied by the Ability's Drain Mult"), 100),
            valueAlteration(getValues("parryTotalTimeMult", false, "Parry Duration Mult", "%", false, "The plasma blade's Parry Duration is multiplied by the ability's Parry Mult"), 100),
            getValues("<b>Multiplied Blocking Traits</b>", true, "Trait Type", "", false, "The following Block traits were calculated using the weapon's modified statistics and the ability multipliers"),
            getValues("continualDrain", false, "Block Drain", "S", false, "The stamina used up every second by continously blocking with this weapon"),
            getValues("reflectionDrain", false, "Reflection Cost", "S", false, "The stamina used up when blocking a projectile"),
            getValues("ownStabDrain", false, "Deflection Cost", "S", false, "The stamina used up when blocking a melee weapon"),
            getValues("ownThaumDrain", false, "Redirection Cost", "S", false, "The stamina used up when blocking a Thaumaturgy attack"),
            getValues("parryTime", false, "Parry Duration", "T", false, "The ammount of time during which parrying is available once blocking starts"),
        );
        /*
        costMult: 1, drainMult: 1, parryTotalTimeMult: 1, canBlockThaum: false
        */
    }
    if(ability.damage > 0 || ability.effectDamage > 0 || ability.staminaDamage > 0) {
        if(ability.staminaDamage > 0) tableData.push(getValues("<b>Inheritted</b>", true, "Trait Type", "", false, "The following traits effect the ability and are inheritted from " + troopAbility.name + "and only affect the " + troopAbility.name + " Damage of the ability"));
        if(ability.damage > 0 || ability.effectDamage > 0) tableData.push(getValues("<b>Inheritted</b>", true, "Trait Type", "", false, "The following traits effect the ability and are inheritted from " + troopAbility.name));
        tableData.push(
            getValues(troopAbility.criticalChance, true, "Critical Chance", "%", false, "The increase in the chance to score a critical hit with a " + ability.name + " attack"),
            getValues(troopAbility.criticalDamage, true, "Critical Damage", "%HP", false, "The increase to the ammount of bonus damage dealt upon landing a critical hit with a " + ability.name + " attack"),
            getValues(troopAbility.accuracy, true, "Accuracy", "%", false, "The bonus to the percent by which enemies' " + ability.name + " evasion chance are reduced"),
            getValues(troopAbility.accuracyDamage, true, "Accuracy Damage", "%HP", false, "The increase to the decrease in the percent of damage that is lost when a " + ability.name + " attack is evaded"),
            getValues(troopAbility.precision, true, "Precision", "%D", false, "The bonus to the amount by which the effectiveness of enemy armour is reduced while taking damage from a " + ability.name + " attack"),
        );
    }
    return tableData;
}

function getAbilityCount(ability) {
    let abilityCount = 0;
    for(var i = 0; i < ability.game.length; i ++) 
        if(ability.game[i] == undefined || ability.game[i].name != "locked")
            abilityCount ++;
    return abilityCount;
}

function getAbilityTableData(equipment, getValues) {
    let ability = getAbility(equipment);
    let abilityAbreviation = getAbility(equipment, true);
    let tableDataChargability = [];
    let tableDataDamageability = [];
    let tableDataHasAbilities = [];
    if(ability.max != undefined) {
        tableDataChargability = [
            getValues("<b>General</b>", true, "Trait Type", "", false, "The following traits describe factors that affect the use of the ability"),
            getValues("max", false, "Maximum", abilityAbreviation, true, "The maximum possible " + ability.name + " that can be held at a time"),
            getValues("regenPerSecond", false, "Recovery", abilityAbreviation, true, "The amount of " + ability.name + " recovered per second while it is not being used"),
            valueAlteration(getValues("coolWaitTime", false, "Recovery Delay", "T", true, "The delay in seconds before " + ability.name + " recovery begins"), 0.001),
            getValues("onDamage", false, "On Damaging", "%" + abilityAbreviation, true, "The amount of " + ability.name + " gained as a percent of damage dealt, doubled when Physical Damage"),
            getValues("onKill", false, "Gain on Kill", abilityAbreviation, true, "The amount of " + ability.name + " gained upon defeating an enemy"),
            getValues("drain", false, "Drain", "%" + abilityAbreviation, true, "The amount of " + ability.name + " drained from an enemy upon attacking them, as a percent of damage dealt"),
        ]
        if(ability.name == "Health") {
            tableDataChargability.push(
                getValues("baseDefense", false, "Base Defense", "D", true, "The thunder warrior's Base Defense, which is applied to defense for stamina, thaumaturgy, ranged, and melee attacks"), 
            );
        } else {
            tableDataChargability.push(
                getValues(getAbilityCount(ability), true, "Ability Count", "", false, "The  amount of " + ability.name + " abilities that can currently be equipped"),
                getValues("maxAbilities", false, "Ability Max", "", onPage == "classScreen", "The maximum amount of " + ability.name + " abilities that can be equipped"),
            );
        }
    } else {
        tableDataChargability = [
            getValues("<b>General</b>", true, "Trait Type", "", false, "The following traits describe factors that affect the use of the ability"),
            getValues("weight", false, "Weight", "", true, "The base weight of the thunder warrior, before adding the weight of armour"),
            getValues("moveSpeed", false, "Move Speed", "U", true, "The thunder warrior's movement speed, which is decreased by weight"),
            getValues("stealthRadiusBase", false, "Stealth Radius", "U", true, "The distance by which enemy Stealth Detection is decreased"),
        ]
    }
    if(ability.damage != undefined) {
        tableDataDamageability = [
            getValues("<b>Offensive Modifier</b>", true, "Trait Type", "", false, "The following traits effect the offensive traits of abilities"),
            getValues("damage", false, "Damage", "%HP", true, "The percent of bonus " + ability.name + " Damage that is dealt by all " + ability.name + " attacks"),
            getValues("<b>Offensive Overall</b>", true, "Trait Type", "", false, "The following traits effect the offensive traits are used for the offensive traits of abilities"),
            getValues("criticalChance", false, "Critical Chance", "%", true, "The increase in the chance to score a critical hit with a " + ability.name + " attack"),
            getValues("criticalDamage", false, "Critical Damage", "%HP", true, "The increase to the ammount of bonus damage dealt upon landing a critical hit with a " + ability.name + " attack"),
            getValues("accuracy", false, "Accuracy", "%", true, "The bonus to the percent by which enemies' " + ability.name + " evasion chance are reduced"),
            getValues("accuracyDamage", false, "Accuracy Damage", "%HP", true, "The increase to the decrease in the percent of damage that is lost when a " + ability.name + " attack is evaded"),
            getValues("precision", false, "Precision", "%D", true, "The bonus to the amount by which the effectiveness of enemy armour is reduced while taking damage from a " + ability.name + " attack"),
            getValues("<b>Defensive Overall</b>", true, "Trait Type", "", false, "The following traits effect the overall defensive traits of the entire thunder warrior"),
            getValues("defense", false, "Defense", "D", true, "The ammount by which all damage from " + ability.name + " attacks is reduced by armour, excluding the Base Defense which would be used in calculating defense during the game"),
            getValues("totalDefense", false, "Total Defense", "D", false, "The ammount by which all damage from " + ability.name + " attacks is reduced by armour, including the Base Defense which is used in calculating defense during the game"),
            getValues("criticalResistance", false, "Critical Resistance", "%", true, "The decresased chance of taking a critical hit from a " + ability.name + " attack"),
            getValues("criticalDefense", false, "Critical Defense", "%HP", true, "The percent by which damage is decreased upon taking a critical hit from a " + ability.name + " attack"),
            getValues("evasionChance", false, "Evasion Chance", "%", true, "The chance to take decreased damage from a " + ability.name + " attack"),
            getValues("evasionDefense", false, "Evasion Defense", "%HP", true, "The percent by which damage is decreased upon evading a " + ability.name + " attack"),
        ]
        if(ability.name == "Physical") {
            tableDataHasAbilities = [
                getValues("<b>Defensive Modifier</b>", true, "Trait Type", "", false, "The following traits effect the defensive traits of armour and abilities"),
                getValues("rangedDefense", false, "Ranged Defense", "%D", true, "The ammount by which all damage from " + ability.name + " attacks is reduced"),
                getValues("meleeDefense", false, "Melee Defense", "%D", true, "The ammount by which all damage from " + ability.name + " attacks is reduced"),
                getValues("stealthDetection", false, "Stealth Detection", "%U", true, "The bonus to the distance to stealthed enemies in which they are visible"),
                getValues("<b>Additional Traits</b>", true, "Trait Type", "", false, "The following traits effect the defensive traits of armour and abilities"),
                getValues("jumpDelay", false, "Jump Preparation", "T", true, "The time it takes to prepare to jump once jumping begins"),
                getValues("accelerationSeconds", false, "Acceleration", "T", true, "The time it takes to accelerate to full speed while moving"),
                getValues("decelerationSeconds", false, "Decelleration", "T", true, "The time it takes to fully decelerate when movement stops"),
                getValues("knockbackResistance", false, "Knockback Resistance", "%", true, "The ammount by which knockback is reduced, which is increased with weight"),
                valueAlteration(getValues("knockbackResistance", false, "Total Knockback Resistance", "%", true, "The total ammount by which knockback is reduced, calculated using weight"), getFullWeight() / 50),
            ];
            tableDataDamageability.splice(10, 0, 
                getValues("onlyRangedDefense", false, "Ranged Defense", "D", true, "The ammount by which all damage from Ranged attacks is reduced by armour, excluding the Physical Defense and Base Defense which would be used in calculating defense during the game"),
                getValues("totalRangedDefense", false, "Total Ranged Defense", "D", false, "The ammount by which all damage from Ranged attacks is reduced by armour, excluding the Physical Defense, but including the Base Defense which would be used in calculating defense during the game"),
                getValues("physicalRangedDefense", false, "Physical Ranged Defense", "D", false, "The ammount by which all damage from Physical Ranged attacks is reduced by armour, including the Physical Defense  and Base Defense which is used in calculating defense during the game"),
                getValues("onlyMeleeDefense", false, "Melee Defense", "D", true, "The ammount by which all damage from Melee attacks is reduced by armour, excluding the Physical Defense or Stamina Defense and Base Defense which would be used in calculating defense during the game"),
                getValues("totalMeleeDefense", false, "Total Melee Defense", "D", false, "The ammount by which all damage from Melee attacks is reduced by armour, excluding the Physical Defense or Stamina Defense, but including the Base Defense which would be used in calculating defense during the game"),
                getValues("physicalMeleeDefense", false, "Physical Melee Defense", "D", false, "The ammount by which all damage from Physical Melee attacks is reduced by armour, including the Physical Defense and Base Defense which is used in calculating defense during the game"),
                getValues("staminaMeleeDefense", false, "Stamina Melee Defense", "D", false, "The ammount by which all damage from Physical Melee attacks is reduced by armour, including the Stamina Defense and Base Defense which is used in calculating defense during the game"),
            );
            tableDataDamageability.push( getValues("stealthDetectionBase", false, "Stealth Detection", "U", true, "The distance to stealthed enemies in which they are visible") );
            tableDataDamageability.splice(7, 0, 
                getValues("stealthRadius", false, "Stealth Radius", "%U", true, "The bonus to the amount by which the radius in which stealth is visible to enemies is decreased"),
            );
        }
    }
    if(ability.duration != undefined) {
        tableDataHasAbilities = [
            getValues("tenacity", false, "Tenacity", "%T", true, "The percent by which the Effect Duration of enemy " + ability.name + " abilities are decreased")
        ]
        tableDataDamageability.splice(1, 0,
            getValues("activationTime", false, "Activation Time", "%T", true, "The percent by which the activation time of " + ability.name + " effects are increased"),
            getValues("duration", false, "Duration", "%T", true, "The percent by which the duration of " + ability.name + " effects are increased"),
            getValues("cooldown", false, "Cooldown", "%T", true, "The percent by which the cooldown of " + ability.name + " effects are increased"),
        )

    }
    return tableDataChargability.concat(tableDataDamageability, tableDataHasAbilities);
}

function addEquipmentTableData(tableData, equipmentType, equipment, getValues) {
    return[
        getValues("<b>General</b>", true, "Trait Type", "", false, "The following traits describe factors that affect the use of the ability"),
        getValues("class", false, "Class", "", false, "The type of " + equipmentType),
        getValues("set", false, "Set", "", false, "The set to which this "  + equipmentType + " belongs, with all of the equipment that belongs to any given set having been specialised for the same task. Because the traits of all of a thunder warrior's equipment build off of each other, using all of the equipment from the same set can create a Thunder Warrior with incredible skill in one specific area"),
        getValues("rarity", false, "Rariry", "", false, "The "  + equipmentType + "'s rarity, which increases all of it's base stats. The rarities are Junk, Common, Uncommon, Rare, Epic, Legendary, and Insane"),
        getValues("level", false, "Level", "", false, "The "  + equipmentType + "'s level, which only increases it's damage or defense"),
        getValues("power", false, "Power", "", true, "The "  + equipmentType + "'s power, which signifies it's maximum capabilitties, but is only a description of the rest of the " + equipmentType + " and does not add anything to it. It is made up of the "  + equipmentType + "'s rarity, level, and it's modifications' rarities, level, and minor modifications."),
        getValues("mods", "slotCount", "Modification Slots", "", false, "The amount of modifications that can be equipped to this "  + equipmentType),
    ].concat(tableData);
}

function setTableHeader(table, abilityUpgradeHeaders, isAbility) {
    let tableHeaders;
    if(onPage == "classScreen") {
        tableHeaders = ["Statistic", "Value", "Initial Value", "Modified Increase", "% Increase", "description"];
    } else if(abilityUpgradeHeaders) {
        tableHeaders = ["Statistic", "Current Value", "Upgraded Value", "Upgraded Increase", "% Increase", "description"];
    } else if(isAbility){
        tableHeaders = ["Statistic", "Value", "Initial Value", "Equipment Increase", "% Increase", "description"];
    } else {
        tableHeaders = ["Statistic", "Value", "Initial Value", "Modified Increase", "% Increase", "description"];
    }
    for(var i = 0; i < table.rows[0].cells.length; i ++) {
        table.rows[0].cells[i].innerHTML = tableHeaders[i];
    }

}

function setStatsTable(equipment, table, getValues, abilityUpgradeHeaders) {
    var tableData = [];
    var equipmentType;
    var isAbility = equipment.slot == undefined;
    setTableHeader(table, abilityUpgradeHeaders, equipment.slot == undefined);
    document.getElementById("statsTitle").innerText = equipment.type || equipment.name;
    if(equipment.slot == "Ranged") {
        equipmentType = "weapon";
        tableData = getRangedTableData(equipment, getValues).concat(getWeaponTableData(equipment, getValues));
    } else if(equipment.slot == "Melee") {
        equipmentType = "weapon";
        tableData = getMeleeTableData(equipment, getValues).concat(getWeaponTableData(equipment, getValues));
    } else if(!isAbility){
        equipmentType = "armour";
        tableData = getArmourTableData(equipment, getValues);
    } else {
        if(viewingAbility == "none") {
            tableData = getAbilityTableData(equipment, getValues);
        } else {
            tableData = getSkillTableData(equipment, getValues);
        }
    }
    if(!isAbility) tableData = addEquipmentTableData(tableData, equipmentType, equipment, getValues);
    tableData = setTableData(tableData);
    setTable(table, tableData);
    setStatsList(table, true);
    document.getElementById("statScroller").scrollTop = 0;
}

function setTable(table, tableData) {
    var eAddition = 0;
    for(var i = 0; i < tableData.length; i ++) {
        if(table.rows.length < i + 2) {
            table.insertRow(table.rows.length);
            for(var e = 0; e < 6; e ++) {
                table.rows[i + 1].insertCell(e);
            }
        }
        if(table.rows[i + 1].cells.length < 6) {
            for(var e = 4 - table.rows[i + 1].cells.length + 1; e < 5; e ++) {
                    table.rows[i + 1].insertCell(e);
            }
        }
        eAddition = 0;
        for(var e = 0; e < 6; e ++) {
            if(tableData[i][e] == "-") {
                table.rows[i + 1].cells[e - eAddition].style.textAlign = "center";
            } else {
                table.rows[i + 1].cells[e - eAddition].style.textAlign = "left";
            }
            if(tableData[i][e] == "empty") {
                table.rows[i + 1].cells[1].colSpan  = 4;
                table.rows[i + 1].deleteCell(2);
                eAddition = 3;
            } else {
                table.rows[i + 1].cells[e - eAddition].colSpan  = 1;
                table.rows[i + 1].cells[e - eAddition].innerHTML = tableData[i][e];
            }
        }
    }
    table.rows[0].style.display = "table-row";
    for(var i = 1; i < table.rows.length; i ++) {
        if(i % 2 == 1) {
            table.rows[i].style.backgroundColor = "#49828047"
        } else {
            table.rows[i].style.backgroundColor = "#00000000"
        }
        
        if(i > tableData.length) {
            table.rows[i].style.display = "none";
        } else {
            table.rows[i].style.display = "table-row";
        }
    }
}

function getAbility(ability, abreviation) {
    if(ability.name == "Stamina") {
        if(abreviation) return 'S';
        return troop.stamina;
    } else if(ability.name == "Health") {
        if(abreviation) return 'HP';
        return troop.hp;
    } else if(ability.name == "Physical") {
        if(abreviation) return 'P';
        return troop.physical;
    } else {
        if(abreviation) return 'Th';
        return troop.force;
    }
}

function setTableData(data) {
    var maxNumber = 4;
    for(var i = 0; i < data.length; i ++) {
        if(data[i][7] == true) {
            if(data[i][3] == 0 || isNaN(data[i][3])) {
                if(data[i][7] == true) {
                    data[i][2] = data[i][3] = data[i][4]= "-";
                }
                maxNumber = 2;
            } else if(!isNaN(data[i][4])){
                maxNumber = 5;
            }
            if(isNaN(data[i][1]) == false || data[i][1] == 0) {
                for(var e = 1; e < maxNumber; e ++) {
                    if(data[i][1] != 0) {
                        data[i][e] = simplifyTableNumber(data[i][e]);
                    }
                    if(e == 4) {
                        data[i][e] = data[i][e] + " %";
                    } else {
                        data[i][e] = data[i][e] + " " + data[i][6]
                    }
                }
            }
        } else {
            if(!isNaN(data[i][1])) {
                data[i][1] = simplifyTableNumber(data[i][1]) + " " + data[i][6];
            }
            data[i][2] = data[i][3] = data[i][4] = "empty";
        }
    }
    return data
}
function simplifyTableNumber(num) {
    var divisor = 100;
    if(!isNaN(num) && num != 0) {
        while (Math.floor(num * divisor) / divisor == 0) {
            divisor *= 10;
        }
        num = (Math.round(num * divisor) / divisor);
    }
    return num;
}

function valueAlteration(valueArray, multiplier) {
    for(var i = 1; i < 4; i ++) {
        valueArray[i] = valueArray[i] * multiplier;
    }
    return valueArray;
}

function setStatsList(table, initial) {
    if(document.getElementById("statsScreen").style.visibility != "visible" && !initial) return;
    var tableHeight = 0;
    for(var i = 1; i < table.rows.length; i ++) {
        for(var e = 1; e < table.rows[i].cells.length; e ++) {
            table.rows[i].cells[e].style.fontSize = sizeUnits * 1.25 + "px";
        }
    }
    for(var e = 0; e < table.rows[0].cells.length; e ++) {
        table.rows[0].cells[e].style.fontSize = sizeUnits * 1.5 + "px";
    }
    for(var i = 1; i < table.rows.length; i ++) {
            table.rows[i].cells[0].style.fontSize = sizeUnits * 1.5 + "px";
    }
    tableHeight = 2 * sizeUnits + document.getElementById("statsTable").offsetTop + document.getElementById("statsTable").offsetHeight + document.getElementById("statsUnitTitle").offsetHeight + document.getElementById("statsUnit").offsetHeight;
    document.getElementById("statScroller").style.height = (90 * sizeUnits) + "px";
    document.getElementById("statScroller").style.top = (5 * sizeUnits) + "px";
    document.getElementById("statsList").style.height = (tableHeight) + "px";
    document.getElementById("statsList").style.top = Math.max(0 * sizeUnits, 40 * sizeUnits - tableHeight / 2) + "px";
}

function hideStats(quickClose, e) {
    if(quickClose == true || e.target == e.currentTarget) {
        var table = document.getElementById("statsTable");
        document.getElementById("statsScreen").style.visibility = "hidden";
        for(var i = 0; i < table.rows.length; i ++) {
            table.rows[i].style.display = "none";
        }
        if(selectedItem != "none") {
            showWeaponDescription(hoveredDisplay, hoveredEquipment);
        }
    }
}

//sets the description canvas's size and display ability properties
function setDescriptionCanvas(canvas, equipment, yAddition, height) {
    var ratios = getPropertyRatios(equipment);
    var enhancedRatios;
    var trueRatios;
    var maxRatios;
    var accuratelyModifiedRatios;
    if(ratios != '') {
        enhancedRatios = getPropertyRatios(modifyWhichEquipment(copyObject(equipment), "Lowest"));
        trueRatios = getPropertyRatios(modifyWhichEquipment(copyObject(equipment), "True"));
        maxRatios = getPropertyRatios(modifyWhichEquipment(copyObject(equipment), "Highest"));
        accuratelyModifiedRatios = getPropertyRatios(modifyWhichEquipment(copyObject(equipment), "accuratelyModified"));
        for(var i = 0; i < enhancedRatios.length; i ++) {
            enhancedRatios[i].ratio = ratios[i].ratio + ((enhancedRatios[i].ratio - ratios[i].ratio) * (trueRatios[i].ratio - ratios[i].ratio) / (maxRatios[i].ratio - ratios[i].ratio));
        }
        canvas.canvas.height = height * sizeUnits * homePixelRatio * trueRatios.length;
        canvas.canvas.style.visibility = 'visible';
        canvas.clearRect(0, 0, canvas.canvas.width, canvas.canvas.height);
        for(var i = 0; i < ratios.length; i ++) {
            displayRatioToCanvas(canvas, yAddition, .5 + 2 * i, ratios[i].ratio, enhancedRatios[i].ratio, accuratelyModifiedRatios[i].text, accuratelyModifiedRatios[i].amount);  
        }
        canvas.canvas.style.height = height * sizeUnits * trueRatios.length;
    } else {
        canvas.canvas.style.visibility = 'hidden';
        ctx3.canvas.style.display = 'none';
    }
}

function modifyWhichEquipment(equipment, uniform) {
    if(equipment.slot == undefined) {
        if(equipment.abilityType == undefined) {
            return modifyAbility(equipment);
        } else {
            return modifySkill(equipment);
        }
    } else if(equipment.slot == "Melee") {
        modifyWeapons(equipment, uniform);
        modifyMeleeWeapon(equipment, uniform);
    } else if(equipment.slot == "Ranged") {
        modifyWeapons(equipment, uniform);
        modifyRangedWeapon(equipment, uniform);
    } else {
        modifyArmour(equipment, uniform);
    }
    return equipment
}

function classModifyEquipment(ability) {
    let change = 2;
    let major = 0.1, minor = 0.0333333333333,
    strength = classOptions.strength.value, dexterity = classOptions.dexterity.value, constitution = classOptions.constitution.value, intelligence = classOptions.intelligence.value, wisdom = classOptions.wisdom.value, light = change *  Math.max(0, classOptions.light.value - (classOptions.light.start - 0.5)), rebellion = change *  Math.max(0, classOptions.rebellion.value - (classOptions.rebellion.start - 0.5)), slight = change *  Math.max(0, classOptions.slight.value - (classOptions.slight.start - 0.5)), dark = change *  Math.max(0, (classOptions.light.start - 0.5) - classOptions.light.value), empire = change *  Math.max(0, (classOptions.rebellion.start - 0.5) - classOptions.rebellion.value), heavy = change *  Math.max(0, (classOptions.slight.start - 0.5) - classOptions.slight.value);
    let total = (strength + dexterity + constitution + intelligence + wisdom + light + empire + slight + dark + rebellion + heavy) / 56;
    if(ability.name == "Physical") {
        ability.damage *= 1 + (strength * major);
        ability.moveSpeed *= 1 + (dexterity * major + slight * major - heavy * minor);
        ability.stealthRadius *= 1 + (dexterity * major);
        ability.stealthRadiusBase *= 1 + (dexterity * major);
        ability.criticalDamage *= 1 + (strength * minor);
        ability.accuracyDamage *= 1 + (strength * minor);
        ability.meleeDefense *= 1 + (strength * major);
        ability.rangedDefense *= 1 + (dexterity * major);
        ability.criticalChance *= 1 + (dexterity * minor);
        ability.precision *= 1 + (dexterity * minor);
        ability.accuracy *= 1 + (dexterity * minor);
        ability.stealthDetection *= 1 + (wisdom * minor);
        ability.stealthDetectionBase *= 1 + (wisdom * minor);
        ability.criticalResistance *= 1 + (wisdom * minor);
        ability.weight *= 1 + (heavy * major - slight * minor);
        ability.accelerationSeconds *= 1 + (heavy * minor - slight * minor);
        ability.decelerationSeconds *= 1 + (heavy * minor - slight * minor);
        ability.knockbackResistance *= 1 + (heavy * minor - slight * minor);
        ability.jumpDelay *= 1 + (heavy * minor - slight * minor);
        ability.defense *= 1 + (heavy * major - slight * minor);
    } else if(ability.name == "Health") {
        ability.max *= 1 + (strength * minor + constitution * minor);
        ability.regenPerSecond *= 1 + (constitution * major);
        ability.onDamage *= 1 + (constitution * major);
        ability.drain *= 1 + (constitution * minor);
        ability.onKill *= 1 + (constitution * major);
        ability.coolWaitTime *= 1 + (-slight * minor - heavy * minor);
        ability.baseDefense *= 1 + (heavy * major - slight * minor);
    } else if(ability.name == "Stamina"){
        ability.max *= 1 + (constitution * major);
        ability.damage *= 1 + (strength * major);
        ability.regenPerSecond *= 1 + (dexterity * major);
        ability.onDamage *= 1 + (dexterity * major);
        ability.onKill *= 1 + (dexterity * major);
        ability.maxAbilities = Math.round(ability.maxAbilities * (1 + (wisdom * major)));
        if(wisdom == 7 && dexterity == 7) ability.maxAbilities += Math.floor(1 * total);
        ability.precision *= 1 + (wisdom * minor);
    } else {
        ability.max *= 1 + (intelligence * major);
        ability.damage *= 1 + (intelligence * major);
        ability.precision *= 1 + (intelligence * minor);
        ability.maxAbilities = Math.round(ability.maxAbilities * (1 + (intelligence * major)));
        if(intelligence == 7 && (light == 7 || dark == 7)) ability.maxAbilities += Math.floor(3 * total);
    }
    if(ability.name == "Stamina" || ability.name == "Thaumaturgy") {
        ability.duration *= 1 + (dark * major);
        ability.damage *= 1 + (dark * minor);
        ability.accuracyDamage *= 1 + (dark * minor);
        ability.cooldown *= 1 + (dark * minor - light * minor);
        ability.drain *= 1 + (dark * minor);
        ability.coolWaitTime *= 1 + (empire * major - rebellion * major);
        ability.onKill *= 1 + (empire * major - rebellion * major);
        ability.onDamage *= 1 + (empire * major - rebellion * major);
        ability.activationTime *= 1 + (empire * major - rebellion * major);
        ability.regenPerSecond *= 1 + (rebellion * major - empire * major);
        ability.criticalChance *= 1 + (rebellion * major);
        ability.criticalDamage *= 1 + (empire * major);
        ability.criticalResistance *= 1 + (light * major);
        ability.defense *= 1 + (light * minor);
        ability.accuracy *= 1 + (light * minor);
        ability.tenacity *= 1 + (wisdom * minor);
    }
    if(ability.name == "Stamina" || ability.name == "Thaumaturgy" || ability.name == "Physical") {
        ability.evasionChance *= 1 + (wisdom * minor);
        ability.evasionDefense *= 1 + (slight * major - heavy * minor);
        ability.criticalDefense *= 1 + (constitution * minor);
    }
    modifyAbilityInfo(ability);
    return ability;
}

function modifyAbility(ability, modifySkills) {
    if(ability.max != undefined) {
        ability.max = minorlyModifyEquipment(ability.max, "Max " + ability.name, "max", ability.name);
        ability.regenPerSecond = minorlyModifyEquipment(ability.regenPerSecond, ability.name + " Recovery", "regen", ability.name);
        ability.coolWaitTime = minorlyModifyEquipment(ability.coolWaitTime, ability.name + " Delay", "delay", ability.name);
        ability.onDamage = minorlyModifyEquipment(ability.onDamage, ability.name + " on Damage", "onDamage", ability.name);
        ability.drain = minorlyModifyEquipment(ability.drain, ability.name + " Drain", "drain", ability.name);
        ability.onKill = minorlyModifyEquipment(ability.onKill, ability.name + " on Kill", "onKill", ability.name);
    }
    if(ability.damage != undefined) {
        ability.criticalChance = minorlyModifyEquipment(ability.criticalChance, ability.name + " Critical Chance", "criticalChance", ability.name);
        ability.criticalDamage = minorlyModifyEquipment(ability.criticalDamage, ability.name + " Critical Damage", "criticalDamage", ability.name);
        ability.criticalResistance = minorlyModifyEquipment(ability.criticalResistance, ability.name + " Critical Resistance", "criticalResistance", ability.name);
        ability.criticalDefense = minorlyModifyEquipment(ability.criticalDefense, ability.name + " Critical Defense", "criticalDefense", ability.name);
        ability.evasionChance = minorlyModifyEquipment(ability.evasionChance, ability.name + " Evasion Chance", "evasionChance", ability.name);
        ability.evasionDefense = minorlyModifyEquipment(ability.evasionDefense, ability.name + " Evasion Defense", "evasionDefense", ability.name);
        ability.accuracy = minorlyModifyEquipment(ability.accuracy, ability.name + " Accuracy", "accuracy", ability.name);
        ability.accuracyDamage = minorlyModifyEquipment(ability.accuracyDamage, ability.name + " Accuracy Damage", "accuracyDamage", ability.name);
        ability.precision = minorlyModifyEquipment(ability.precision, ability.name + " Precision", "precision", ability.name);
        ability.damage = getAbilityDamage(ability);
        ability.defense = minorlyModifyEquipment(ability.defense, ability.name + " Defense", "defense", ability.name);
    }
    if(ability.duration != undefined) {
        ability.tenacity = minorlyModifyEquipment(ability.tenacity, ability.name + " Tenacity", "tenacity", ability.name);
        ability.activationTime = minorlyModifyEquipment(ability.activationTime, ability.name + " Activation Time", "activationTime", ability.name, undefined, true);
        ability.duration = minorlyModifyEquipment(ability.duration, ability.name + " Duration", "duration", ability.name);
        ability.cooldown = minorlyModifyEquipment(ability.cooldown, ability.name + " Cooldown", "cooldown", ability.name, undefined, true);
    }
    if(ability.name == "Health") {
        ability.baseDefense = getDefenseBase(ability);
    } else if(ability.name == "Physical") {
        ability.rangedDefense = minorlyModifyEquipment(ability.rangedDefense, "Ranged Defense", "rangedDefense", "Physical");
        ability.meleeDefense = minorlyModifyEquipment(ability.meleeDefense, "Melee Defense", "meleeDefense", "Physical");
        ability.onlyRangedDefense += traitFuncOnAllArmour(getArmourTrait, "rangedDefense", "Ranged Defense");
        ability.onlyMeleeDefense += traitFuncOnAllArmour(getArmourTrait, "meleeDefense", "Melee Defense");
        ability.moveSpeed = minorlyModifyEquipment(ability.moveSpeed, "Movement Speed");// * (100 / (21 + ability.weight));
        ability.stealthRadius = minorlyModifyEquipment(ability.stealthRadius, "Stealth Radius", "stealthRadius", "Physical");;
        ability.stealthDetection = minorlyModifyEquipment(ability.stealthDetection, "Stealth Detection", "stealthDetection", "Physical");
        ability.stealthRadiusBase = minorlyModifyEquipment(ability.stealthRadius, "Stealth Radius", "stealthRadius", "Physical") + traitFuncOnAllArmour(getMinorlyModifiedArmourTrait, "stealthRadius", "Stealth Radius", ability.stealthRadius);
        ability.stealthDetectionBase = minorlyModifyEquipment(ability.stealthDetectionBase, "Stealth Detection", "stealthDetection", "Physical") + traitFuncOnAllArmour(getMinorlyModifiedArmourTrait, "stealthDetection", "Stealth Detection", ability.stealthDetection);
        ability.knockbackResistance = minorlyModifyEquipment(ability.knockbackResistance, "Knockback Resistance", "knockbackResistance", ability.name);
        ability.accelerationSeconds = minorlyModifyEquipment(ability.accelerationSeconds, "Acceleration", "accelerationSeconds", ability.name);
        ability.decelerationSeconds = minorlyModifyEquipment(ability.decelerationSeconds, "Deceleration", "decelerationSeconds", ability.name);
    }
    modifyAbilityInfo(ability)
    if(modifySkills) {
        for(var i = 0; i < ability.game.length; i ++)
            if(ability.game[i] != undefined && ability.game[i].name != "locked")
                ability.game[i] = modifySkill(copyObject(ability.game[i]), ability);
    }
    return ability;
}
function modifyAbilityInfo(ability) {
    if(ability.damage != undefined) ability.totalDefense = ability.defense + getDefenseBase();
    if(ability.name == "Physical") {
        let baseDefense = getDefenseBase();
        ability.totalRangedDefense = ability.onlyRangedDefense + baseDefense;
        ability.physicalRangedDefense = ability.onlyRangedDefense + baseDefense + ability.defense;
        ability.totalMeleeDefense = ability.onlyMeleeDefense + baseDefense;
        ability.physicalMeleeDefense = ability.onlyMeleeDefense + baseDefense + ability.defense;
        ability.staminaMeleeDefense = ability.onlyMeleeDefense + baseDefense + (onPage == "classScreen" ? classModifyEquipment(copyObject(troop.stamina)).defense : minorlyModifyEquipment(troop.stamina.defense, "Stamina Defense", "defense", "Stamina"));
        if(onPage != "classScreen") ability.weight = getFullWeight(ability);
    }

}
function getFullWeight(ability = troop.physical) {
    return troop.built != "finished" ? 0 : ability.weight + getWeight(troop.playerImage.head, "accuratelyModified") + getWeight(troop.playerImage.body, "accuratelyModified") + getWeight(troop.playerImage.legs, "accuratelyModified") + getWeight(troop.playerImage.leftArm, "accuratelyModified") + getWeight(troop.playerImage.rightArm, "accuratelyModified");
}
function getAbilityDamage(ability) {
    return minorlyModifyEquipment(ability.damage, ability.name + " Damage", "damage", ability.name);
}
function modifySkill(ability, mainAbility) {
    let troopAbility = mainAbility || modifyWhichEquipment(copyObject(troop[ability.abilityType]));
    modifySkillTrait(ability, troopAbility, "duration", "duration");
    modifySkillTrait(ability, troopAbility, "activationTime", "activationTime", true);
    modifySkillTrait(ability, troopAbility, "cooldown", "cooldown", true);
    modifySkillTrait(ability, troopAbility, "damage", "damage");
    modifySkillTrait(ability, troopAbility, "effectDuration", "duration");
    modifySkillTrait(ability, troopAbility, "effectDamage", "damage");

    if(ability.subclass == "Shot" || ability.subclass == "Strike") {
        let weapon = modifyWhichEquipment(copyObject( ability.subclass == "Shot" ? troop.rangedWeapon : troop.meleeWeapon));
        if(ability.subclass == "Shot") {
            ability.damage = weapon.damage * ability.damageMult;
            ability.cost = weapon.heat.increase * ability.costMult;
            ability.range = weapon.range * ability.rangeMult;
            ability.firingSpeed = weapon.firingSpeed * ability.firingSpeedMult;
            ability.speed = weapon.projectileSpeed * ability.speedMult;
            ability.spread = weapon.spreadMax * ability.spreadMult;
        } else {
            ability.damage = weapon.strike.damage * ability.damageMult;
            ability.radius = weapon.strike.radius * ability.radiusMult;
            ability.knockback = weapon.strike.knockback * ability.knockbackMult;
            ability.strikeCooldown  = weapon.strike.wait * ability.cooldownMult;;
            ability.staminaCost += weapon.strike.cost * ability.costMult;
        }
        ability.critChance = weapon.criticalChance * ability.critChanceMult;
        ability.critDamage = weapon.criticalDamage * ability.critDamageMult;
        ability.accuracyChance = weapon.accuracy * ability.accuracyChanceMult;
        ability.accuracyDamage = weapon.accuracyDamage * ability.accuracyDamageMult;
        ability.precision = weapon.precision * ability.precisionMult;
        ability.staminaDamage = ability.staminaDamage * ( 1 + getAbilityDamage(troop.stamina) / 100);
    } else if(ability.subclass == "Block") {
        let weapon = modifyWhichEquipment(copyObject(troop.meleeWeapon));
        ability.staminaCost = weapon.block.imediateDrain * ability.costMult;
        ability.reflectionDrain = weapon.block.reflectionDrain * ability.costMult;
        ability.ownStabDrain = weapon.block.ownStabDrain * ability.costMult;
        ability.ownThaumDrain = weapon.block.ownThaumDrain * ability.costMult;
        ability.parryTime = weapon.block.parryTime * ability.parryTotalTimeMult;
        ability.continualDrain = weapon.block.continualDrain * ability.drainMult;
    } else if(ability.class == "Mobility") {
        ability.staminaCost *= getFullWeight() / 50;
    }
    return ability;
}
function modifiedSKillStaminaCost(ability) {
    let cost;
    if(ability.subclass == "Strike")
        cost = calculateModifiedStatistic(troop.meleeWeapon, troop.meleeWeapon.strike.cost, "Slightness", undefined, true, false, "accuratelyModified");
    else
        cost = calculateModifiedStatistic(troop.meleeWeapon, troop.meleeWeapon.block.imediateDrain, "Slightness", undefined, true, false, "accuratelyModified");
    return ability.staminaCost + cost * ability.costMult;
}
function modifySkillTrait(ability, troopAbility, abilityTrait, troopAbilityTrait, negative = false) {
    if(ability[abilityTrait] != undefined && !isNaN(ability[abilityTrait])) ability[abilityTrait] *= 1 + (troopAbility[troopAbilityTrait] / 100 * (negative ? -1 : 1));
}

function getDefenseBase(ability = troop.hp) {
    return ability.baseDefense + traitFuncOnAllArmour(getDefense, "accuratelyModified");
}

function traitFuncOnAllArmour(func, ...params) {
    return troop.playerImage == undefined ? 0 : (func.apply(null, [troop.playerImage.head].concat(params)) + func.apply(null, [troop.playerImage.body].concat(params)) + func.apply(null, [troop.playerImage.legs].concat(params)) + func.apply(null, [troop.playerImage.leftArm].concat(params)) + func.apply(null, [troop.playerImage.rightArm].concat(params)));
}
function getArmourTrait(armour, trait, traitName) {
    return calculateModifiedStatistic(armour, armour[trait], traitName, undefined, false, false, "accuratelyModified");
}
function getMinorlyModifiedArmourTrait(armour, trait, traitName, traitIncrease) {
    return minorlyModifyEquipment(armour[trait], traitName, armour.id, undefined, traitIncrease);
}

function getDefense(armour, uniform) {
    let defenseFoundCount = uniform == "accuratelyModified" ? minorlyModifyEquipment(troop.physical.defense, "Physical Defense", "defense", "Physical") / 100 : 0;
    defenseFoundCount += calculateModifiedStatistic(armour, armour.defense, "Defense", undefined, false, false, uniform, true);
    defenseFoundCount += calculateModifiedStatistic(armour, armour.defense, "Tank", undefined, false, false, uniform, true);
    defenseFoundCount += calculateModifiedStatistic(armour, armour.defense, "Speeder", undefined, true, true, uniform, true);
    defenseFoundCount += calculateModifiedStatistic(armour, armour.defense, "Powerhouse", undefined, true, true, uniform, true);
    return getAbilityFromFoundCount(armour.defense, defenseFoundCount);
}
function getWeight(armour, uniform) {
    let weightFoundCount = 0;
    weightFoundCount += calculateModifiedStatistic(armour, armour.weight, "Weight", undefined, true, false, uniform, true);
    weightFoundCount += calculateModifiedStatistic(armour, armour.weight, "Tank", undefined, false, true, uniform, true);
    weightFoundCount += calculateModifiedStatistic(armour, armour.weight, "Speeder", undefined, true, false, uniform, true);
    return getAbilityFromFoundCount(armour.weight, weightFoundCount);
}

//draws a rectangle on the canvas to display a ratio
function displayRatioToCanvas(canvas, yAddition, height, ratio, enhancedRatio, text1, text2) {
    quickRect(canvas, (7.5 * canvas.canvas.width / 28 + (canvas.canvas.width - 8.5 * canvas.canvas.width / 28) * ratio), (canvas.canvas.width / 28 * height) + yAddition, ((canvas.canvas.width - canvas.canvas.width / 28 * 8.5) - ((canvas.canvas.width - canvas.canvas.width / 28 * 8.5) * ratio)), (canvas.canvas.width / 28 * 1.5), "#1a1a4a");
    if(enhancedRatio >= ratio) {
        quickRect(canvas, (7.5 * canvas.canvas.width / 28), (canvas.canvas.width / 28 * height) + yAddition, ((canvas.canvas.width - canvas.canvas.width / 28 * 8.5) * enhancedRatio), (canvas.canvas.width / 28 * 1.5), "#999999");
    }
    quickRect(canvas, (7.5 * canvas.canvas.width / 28), (canvas.canvas.width / 28 * height) + yAddition, ((canvas.canvas.width - canvas.canvas.width / 28 * 8.5) * ratio), (canvas.canvas.width / 28 * 1.5), "#ffffff");
    if(enhancedRatio < ratio) {
        quickRect(canvas, (7.5 * canvas.canvas.width / 28), (canvas.canvas.width / 28 * height) + yAddition, ((canvas.canvas.width - canvas.canvas.width / 28 * 8.5) * enhancedRatio), (canvas.canvas.width / 28 * 1.5), "#999999");
    }
    quickText(canvas, "start", (canvas.canvas.width / 28), (canvas.canvas.width / 28 * (1.3 + height)) + yAddition, (1.5 * canvas.canvas.width / 28), "#ffffff", text1, getRatioText(text2), '#c9bc0c', 7 * (canvas.canvas.width / 28), 0);
}
//combines the coloring and drawing of a rectangle for simplification
function quickRect(canvas, x, y, width, height, color) {
    canvas.fillStyle = color;
    canvas.fillRect(x, y, width, height);
}

function getRatioText(text) {
    if(text == 0) {
        return text;
    } else if(text < 1) {
        let zeroes = 1;
        while(text * zeroes < 1) {
            zeroes *= 10;
        }
        return Math.round(text * zeroes) / zeroes; 
    } else if(text < 10) {
        return Math.round(text * 100) / 100; 
    } else if(text < 100) {
        return Math.round(text * 10) / 10.
    } else {
        return Math.round(text);
    }
}

//simplifies drawing text to a canvas
function quickText(canvas, align, x, y, fontSize,  textColor1, text1, text2, textColor2, xAddition, yAddition, fontSize2) {
    canvas.fillStyle = textColor1;
    canvas.font = fontSize + 'px Arial';
    canvas.textAlign = align;
    canvas.fillText(text1, x, y);
    if(text2 != undefined) {
        canvas.fillStyle = textColor2;
        if(fontSize2 != undefined) { 
            canvas.font = fontSize2 + 'px Arial';
        }
        canvas.fillText(text2, x + xAddition, y + yAddition);
        
    }
}

//finds which equipment is being equipped and returns that equipment's ratio
function getPropertyRatios(equipment) {
    if(equipment.slot == 'Helmet') {
        return getArmourPropertyRatios(equipment, helmets);
    } else if(equipment.slot == 'Torso') {
        return getArmourPropertyRatios(equipment, bodies);
    } else if(equipment.slot == 'Legs') {
        return getArmourPropertyRatios(equipment, legs);
    } else if(equipment.slot == 'Left Arm') {
        return getArmourPropertyRatios(equipment, leftArms);
    } else if(equipment.slot == 'Right Arm') {
        return getArmourPropertyRatios(equipment, rightArms);
    } else  if(equipment.slot == 'Ranged') { 
        return getRangedWeaponPropertyRatios(rangedWeapons, equipment);
    } else if( equipment.slot == 'Melee') {
        return getMeleeWeaponPropertyRatios(meleeWeapons, equipment);
    } else  if(equipment.slot == 'Ranged Mod') { 
        return '';
    } else if( equipment.slot == 'Melee Mod') {
        return '';
    } else if( equipment.slot == 'Weapon Mod') {
        return '';
    } else if( equipment.slot == 'Armour Mod') {
        return '';
    }
}

//returns the properties of equiopped armour
function getArmourPropertyRatios(equipment, equipmentSlot) {
    var highestDefense = 0;
    var highestWeight = 0;
    var highestChargeStamina = 0;
    var highestChargeThaumiturgy = 0;
    var highestChargeHealth = 0;
//    var highestCharge = 0;
    for(var i = 0; i < equipmentSlot.length; i ++) {
        highestDefense = getRatio(equipmentSlot[i], equipment, "defense", armourMultipliers[0], highestDefense);
        highestWeight = getRatio(equipmentSlot[i], equipment, "weight", armourMultipliers[1], highestWeight);
        highestChargeStamina = getRatio(equipmentSlot[i], equipment, "regen", armourMultipliers[2], highestChargeStamina, "Stamina");
        highestChargeThaumiturgy = getRatio(equipmentSlot[i], equipment, "regen", armourMultipliers[3], highestChargeThaumiturgy, "Thaumaturgy");
        highestChargeHealth = getRatio(equipmentSlot[i], equipment, "regen", armourMultipliers[4], highestChargeHealth, "Health");
    }
    return [
        {ratio: equipment.defense / Math.pow(1.6, equipment.rarityIncrease ) / (1 + (equipment.level * levelBonus)) / highestDefense, amount: equipment.defense, text: "Defense"},
        {ratio: equipment.weight / highestWeight, amount: equipment.weight, text: "Weight"},
        {ratio: equipment.Stamina.regen / highestChargeStamina, amount: equipment.Stamina.regen, text: "Regen S"},
        {ratio: equipment.Thaumaturgy.regen / highestChargeThaumiturgy, amount: equipment.Thaumaturgy.regen, text: "Regen T"},
        {ratio: equipment.Health.regen / highestChargeHealth, amount: equipment.Health.regen, text: "Regen H"},

    ];
}
function getRatio(equipmentSlotCheck, equipment, trait, mod, highest, traitBase) {
    let equipmentTrait = traitBase == undefined ? equipmentSlotCheck[trait] : equipmentSlotCheck[traitBase][trait];
    let value = equipmentTrait * 1.1 * (1 + ((mod.increase || mod.decrease) * equipmentSlotCheck.mods.slotCount * 1.1 * getRarity(equipment.rarityIncrease).slotCount));
    if(value > highest) {
        return value;
    } else {
        return highest;
    }
}

function getMeleeWeaponPropertyRatios(weaponArray, weapon) {
    var damageRatio = 0;
    var strikeRadiusRatio = 0;
    var angleRatio = 0;
    var costRatio = 0;
    for(var i = 0; i < weaponArray.length; i ++) {
        damageRatio = getRatio(weaponArray[i], weapon, "damage", weaponMultipliers[0], damageRatio, "strike");
        strikeRadiusRatio = getRatio(weaponArray[i], weapon, "radius", meleeMultipliers[0], strikeRadiusRatio, "strike");
        if((weaponArray[i].block.stabAngle + weaponArray[i].block.projectileAngle) / 2 * 1.1 * (1 + (meleeMultipliers[4].increase * weaponArray[i].mods.slotCount * 1.1 * getRarity(weapon.rarityIncrease).slotCount)) > angleRatio) {
            angleRatio = (weaponArray[i].block.stabAngle + weaponArray[i].block.projectileAngle) / 2 * 1.1 * (1 + (meleeMultipliers[4].increase * weaponArray[i].mods.slotCount * 1.1 * getRarity(weapon.rarityIncrease).slotCount));
        }
        if((weaponArray[i].strike.cost + weaponArray[i].block.imediateDrain) / 2 * 1.1 * (1 + (meleeMultipliers[4].increase * weaponArray[i].mods.slotCount * 1.1 * getRarity(weapon.rarityIncrease).slotCount)) > costRatio) {
            costRatio = (weaponArray[i].strike.cost + weaponArray[i].block.imediateDrain) / 2 * 1.1 * (1 + (meleeMultipliers[4].increase * weaponArray[i].mods.slotCount * 1.1 * getRarity(weapon.rarityIncrease).slotCount));
        }
    }
    return [
        {ratio: weapon.strike.damage / Math.pow(1.5, weapon.rarityIncrease) / (1 + (weapon.level * (levelBonus + 0.4))) / damageRatio, amount: weapon.strike.damage, text: "Damage"},
        {ratio: weapon.strike.radius / Math.pow(1.1, weapon.rarityIncrease) / strikeRadiusRatio, amount: weapon.strike.radius, text: "Radius"},
        {ratio: (weapon.block.stabAngle + weapon.block.projectileAngle) / 2 / 2 / Math.pow(1.1, weapon.rarityIncrease) / angleRatio, amount: weapon.block.imediateDrain, text: "Angle"},
        {ratio: (weapon.strike.cost + weapon.block.imediateDrain) / 2 / Math.pow(1.1, weapon.rarityIncrease) / costRatio, amount: weapon.strike.cost, text: "Cost"},
    ];
}

//returns the weapon properties
function getRangedWeaponPropertyRatios(weaponArray, weapon) {
    var damageRatio = 0;
    var rangeRatio = 0;
    var heatRatio = 0;
    var firingSpeedRatio= 0;
    var maxHeat;
    var heatIncrease;
    var finalMaxHeat = weapon.heat.max;
    var finalIncrease = weapon.heat.increase / Math.pow(0.95, weapon.rarityIncrease);
    var heatText = weapon.heat.max / weapon.heat.increase;
    for(var i = 0; i < weaponArray.length; i ++) {
        if(weaponArray[i].damage * 1.1 *  (1 + (weaponMultipliers[0].increase * (weaponArray[i].mods.slotCount * 1.1 * getRarity(weapon.rarityIncrease).slotCount))) > damageRatio) {
            damageRatio = weaponArray[i].damage * 1.1 * (1 + (weaponMultipliers[0].increase * weaponArray[i].mods.slotCount * 1.1 * getRarity(weapon.rarityIncrease).slotCount));
        }
        if(60000 / (weaponArray[i].firingSpeed * 0.5 / (1 + (rangedMultipliers[0].decrease * weaponArray[i].mods.slotCount * 1.1 * getRarity(weapon.rarityIncrease).slotCount))) > firingSpeedRatio) {
            firingSpeedRatio = 60000 / (weaponArray[i].firingSpeed * 0.5 / (1 + (rangedMultipliers[0].decrease * weaponArray[i].mods.slotCount * 1.1 * getRarity(weapon.rarityIncrease).slotCount)));
        }
        
        if(weaponArray[i].range * 1.1 * (1 + (rangedMultipliers[5].increase * weaponArray[i].mods.slotCount * 1.1 * getRarity(weapon.rarityIncrease).slotCount)) > rangeRatio) {
            rangeRatio = weaponArray[i].range * 1.1 * (1 + (rangedMultipliers[5].increase * weaponArray[i].mods.slotCount * 1.1 * getRarity(weapon.rarityIncrease).slotCount));
        }
        if(weaponArray[i].heat.max * 1.1 * (1 + (rangedMultipliers[2].increase * weaponArray[i].mods.slotCount * 1.1 * getRarity(weapon.rarityIncrease).slotCount)) / weaponArray[i].heat.increase * 1.1 > heatRatio) {
            heatRatio = weaponArray[i].heat.max * 1.1 * (1 + (rangedMultipliers[2].increase * weaponArray[i].mods.slotCount * 1.1 * getRarity(weapon.rarityIncrease).slotCount)) / weaponArray[i].heat.increase * 1.1;
        }
    }
    return [
        {ratio: weapon.damage / Math.pow(1.5, weapon.rarityIncrease) / (1 + (weapon.level * (levelBonus + 0.4))) / damageRatio, amount: weapon.damage, text: "Damage"},
        {ratio: (60000 / ((weapon.firingSpeed / Math.pow(0.95, weapon.rarityIncrease)))) / firingSpeedRatio, amount: 60000 / weapon.firingSpeed, text: "Speed"},
        {ratio: finalMaxHeat / finalIncrease / heatRatio, amount: heatText, text: "Capacity"},
        {ratio: weapon.range / Math.pow(1.1, weapon.rarityIncrease) / rangeRatio, amount: weapon.range, text: "Range"},
    ];
}

//hides the weapon screen
function hideWeaponScreen() {
    let modCounters = document.getElementsByClassName('counter');
    for(var i = 0; i < 12; i ++) {
        if(document.getElementById("weaponSelectionBackground" + i) != null) {
            document.getElementById("weaponSelectionBackground" + i).style.visibility = "hidden";       
        }             
    }
    for(var e = 0; e < modCounters.length; e ++) {
        modCounters[e].style.visibility = 'hidden'
    }
    document.getElementById(weaponIcon.id).onload = null;
    document.getElementById(weaponIcon.id).style.visibility = "hidden";
    document.getElementById('weaponModEquippedCounter').style.visibility = 'hidden';
    document.getElementById('weaponModAvailableCounter').style.visibility = 'hidden';
    ctx4.canvas.style.visibility = 'hidden';
    document.getElementById("weaponPage").style.visibility = "hidden";
    document.getElementById('weaponPageWeapon').style.visibility = 'hidden';
    modsShowing = false;
    hidDescriptionMinors();
    hideOrShowModSelection();
}

function hideOrShowModSelection() {
    for(var i = 0; i < selectedEquipment.mods.slotCount; i ++) {
        document.getElementById("modBackground" + i).style.display = 'none';
        document.getElementById("modImage" + i).style.visibility = 'hidden';
        document.getElementById("modBackground" + i).style.cursor = 'default';
        document.getElementById("modImage" + i).style.cursor = 'default';
    }
    if(modsShowing == true) {
        for(var i = 0; i < selectedEquipment.mods.slotCount; i ++) {
            document.getElementById("modBackground" + i).style.display = 'block';
        }
        document.getElementById('modConstructionButton').onclick = function() { showShopScreen('mod') };
        document.getElementById('modConstructionButton').innerText = 'Construct More Mods';
        for(var i = 0; i < selectedEquipment.mods.equipped.length; i ++) {
            document.getElementById("modImage" + i).style.visibility = 'visible';
            document.getElementById("modBackground" + i).style.cursor = 'pointer';
            document.getElementById("modImage" + i).style.cursor = 'pointer';
        }   
    } else {
        document.getElementById('modConstructionButton').onclick = function() { showShopScreen('equipment') };
        document.getElementById('modConstructionButton').innerText = 'Construct More Equipment';
    }
}

function getOneToFour() {
    var number = Math.floor(Math.random() * 4) + 1;
    if(number == 1) {
        return 1;
    } else if(number == 2) {
        number = Math.floor(Math.random() * 2) + 1;
        if(number == 1) {
            return 1;
        } else {
            return 2;
        }
    } else if(number == 3) {
        number = Math.floor(Math.random() * 4) + 1;
        if(number == 4) {
            return 3;
        } else {
            return 1;
        }
    } else {
        number = Math.floor(Math.random() * 8) + 1;
        if(number == 8) {
            return 4;
        } else {
            return 1;
        }
    }  
}

function weaponsShopScreen() {
    setShopSelection("Weapons", "Equipment Pack: Weapon", 1, "oneToFour", 1, "oneToFour", 3, 0, 1250, 5, 7.5, [meleeWeapons, rangedWeapons], ["unlockedMeleeWeapons", "unlockedRangedWeapons"], rangedWeapons.concat(meleeWeapons));
}

function armourShopScreen() {
    setShopSelection("Armour", "Equipment Pack: Armour", 1, "oneToFour", 1, "oneToFour", 3, 1, 1250, 5, 7.5, [helmets, bodies, legs, leftArms, rightArms], ["unlockedHelmets", "unlockedBodies", "unlockedLegs", "unlockedLeftArms", "unlockedRightArms"], helmets.concat(bodies, legs, leftArms, rightArms));
}

function equipmentShopScreen() {
    setShopSelection("Equipment", "Equipment Pack: Any", 1, "oneToFour", 1, "oneToFour", 3, 2, 1000, 5, 7.5, [meleeWeapons, rangedWeapons, helmets, bodies, legs, leftArms, rightArms], ["unlockedMeleeWeapons", "unlockedRangedWeapons", "unlockedHelmets", "unlockedBodies", "unlockedLegs", "unlockedLeftArms", "unlockedRightArms"], meleeWeapons.concat(rangedWeapons, helmets, bodies, legs, leftArms, rightArms));
}

function weaponModsShopScreen() {
    setShopSelection("Weapon Mods", "Mod Pack: Weapon", "oneToFour", "oneToFour", 2, "oneToFour", 6, 3, 185, 0, 2, [weaponMultipliers, meleeMultipliers, rangedMultipliers], ["unlockedMods", "unlockedMods", "unlockedMods"], rangedMultipliers.concat(weaponMultipliers, meleeMultipliers));
}

function armourModsShopScreen() {
    setShopSelection("Armour Mods", "Mod Pack: Armour", "oneToFour", "oneToFour", 2, "oneToFour", 6, 4, 185, 0, 2, [armourMultipliers], ["unlockedMods"], armourMultipliers);
}

function allModsShopScreen() {
    setShopSelection("Of Any Mods", "Mod Pack: Any", "oneToFour", "oneToFour", 2, "oneToFour", 6, 5, 150, 0, 2, [weaponMultipliers, meleeMultipliers, rangedMultipliers, armourMultipliers], ["unlockedMods", "unlockedMods", "unlockedMods", "unlockedMods"], rangedMultipliers.concat(weaponMultipliers, armourMultipliers, meleeMultipliers));
}

function getDescriptionItems(origArray, name) {
    let newItems = [];
    let itemArray = [];
    if(onPage = "shopScreen" && shopNames == name) return shopItems;
    for(var i = 0; i < 9; i ++) {
        if(itemArray.length == 0) itemArray = [...origArray];
        let index = Math.floor(Math.random() * itemArray.length);
        newItems.push(itemArray[index]);
        itemArray.splice(index, 1);
    }
    return newItems;
}

function setShopSelection(name, description, purchases, rarePurchases, rarePurchasesAddition, legendaryPurchases, legendaryPurchaseAddition, idNumber, creditCost, metalCost, experienceCost, selectionArrays, unlockArrays, descriptionItems) {
    var maxPurchasesCommon = 0;
    var maxPurchasesRare = 0;
    var maxPurchasesLegendary = 0;
    shopDescription = description;
    shopItems = getDescriptionItems(descriptionItems, name);
    shopNames = name;
    shopCost = {credits: creditCost, metals: metalCost}
    onPage = "shopScreen";
    if(purchases == "oneToFour") {
        maxPurchasesCommon = 4;
    } else {
        maxPurchasesCommon = purchases;
    }
    if(rarePurchases == "oneToFour") {
        maxPurchasesRare = 4;
    }else {
        maxPurchasesRare = rarePurchases;
    }
    if(legendaryPurchases == "oneToFour") {
        maxPurchasesLegendary = 4;
    }else {
        maxPurchasesLegendary = legendaryPurchases;
    }
    shopNumber = [maxPurchasesCommon, maxPurchasesRare + rarePurchasesAddition, maxPurchasesLegendary + legendaryPurchaseAddition];
    document.getElementById("shopScreen").style.visibility = "visible";
    setImages();
    setPurchaseHeaders(idNumber);
    setEquipmentOptionCursors(creditCost, metalCost);
    setShopOptionVisibility("visible");
    document.getElementById("purchaseOption0").onclick = function() {
        makePurchase(1, 75000, 50000,  10000, 2500, 750, 50, 1, purchases, 0, creditCost, metalCost, experienceCost, selectionArrays, unlockArrays);
        setEquipmentOptionCursors(creditCost, metalCost);
    };
    document.getElementById("purchaseOption1").onclick = function() {
        makePurchase(15, 500, 5000, 20000, 50000, 7500, 750, 20, rarePurchases, rarePurchasesAddition, creditCost * 10, metalCost * 10, experienceCost * 10, selectionArrays, unlockArrays);
        setEquipmentOptionCursors(creditCost, metalCost);
    };
    document.getElementById("purchaseOption2").onclick = function() {
        makePurchase(25, 5, 50, 200, 2000, 5000, 500, 25, legendaryPurchases, legendaryPurchaseAddition, creditCost * 100, metalCost * 100, experienceCost * 100, selectionArrays, unlockArrays);
        setEquipmentOptionCursors(creditCost, metalCost);
    };
}
function setPurchaseHeaders(idNumber) {
    for(var i = 0; i < 10; i ++) {
        document.getElementById("purchaseHeader" + i).classList.remove("clickedPurchaseHeader");
    }
    document.getElementById("purchaseHeader" + idNumber).classList.add("clickedPurchaseHeader");
}

function setEquipmentOptionCursors(creditCost, metalCost) {
    if(troop.resources.credits >= creditCost && troop.resources.metals >= metalCost) {
        document.getElementById("purchaseOption0").style.cursor = "pointer";
    } else {
        document.getElementById("purchaseOption0").style.cursor = "default";
    }
    if(troop.resources.credits >= creditCost * 100 && troop.resources.metals >= metalCost * 100) {
        document.getElementById("purchaseOption2").style.cursor = "pointer";
    } else {
        document.getElementById("purchaseOption2").style.cursor = "default";
    }
    if(troop.resources.credits >= creditCost * 10 && troop.resources.metals >= metalCost * 10) {
        document.getElementById("purchaseOption1").style.cursor = "pointer";
                
    } else {
        document.getElementById("purchaseOption1").style.cursor = "default";
    }
    setShopScreen();
}
function setResourceOptionCursors(crystalCosts) {
    let purcahseOptions = document.getElementsByClassName("purchaseOptions");
    for(var i = 0; i < purcahseOptions.length; i ++) {
        if(troop.resources.crystals >= crystalCosts[i]) {
            purcahseOptions[i].style.cursor = "pointer";
        } else {
            purcahseOptions[i].style.cursor = "default";
        }
    }
}

function createModBackground(canvas, text, text2, text3, costMultiplier, width, height, gc1, gc2, gc3, gc4) {
    quickText(canvas, "center", canvas.canvas.width / 2, canvas.canvas.height / 10, canvas.canvas.width / 10, gc4, text, shopDescription, gc3, 0, canvas.canvas.height / 20, canvas.canvas.width / 12.5);
    quickText(canvas, "end", canvas.canvas.width / 2.05, canvas.canvas.height / 1.07, canvas.canvas.width / 10, gc1, simplifyNumber(shopCost.credits * costMultiplier));
    quickText(canvas, "end", canvas.canvas.width / 1.25, canvas.canvas.height / 1.07, canvas.canvas.width / 10, gc1, simplifyNumber(shopCost.metals * costMultiplier));
    quickText(canvas, "center", canvas.canvas.width / 2, canvas.canvas.height / 5, canvas.canvas.width / 18.5, gc3, "Unlock up to " + text2 + " " + shopNames);
    quickText(canvas, "center", canvas.canvas.width / 2, canvas.canvas.height / 4.4, canvas.canvas.width / 18.5, gc3, "Best Chance of " + text3 );
}
function drawShopItems() {
    for(var itemMultiplier = 0; itemMultiplier < 3; itemMultiplier ++) {
        let canvas = window["ctx" + (itemMultiplier + 5)];
        quickImage(canvas, "creditsIcon", canvas.canvas.width / 2.05, canvas.canvas.height / 1.12, 3.5 * sizeUnits * homePixelRatio);
        quickImage(canvas, "metalsIcon", canvas.canvas.width / 1.225, canvas.canvas.height / 1.1175, 3.5 * sizeUnits * homePixelRatio);
        drawItem(canvas, shopItems[0 + 3 * itemMultiplier], canvas.canvas.width / 5, canvas.canvas.height / 3.5, 10 * sizeUnits * homePixelRatio);
        drawItem(canvas, shopItems[1 + 3 * itemMultiplier], canvas.canvas.width / 2, canvas.canvas.height / 2.35, 10 * sizeUnits * homePixelRatio);
        drawItem(canvas, shopItems[2 + 3 * itemMultiplier], canvas.canvas.width / 5, canvas.canvas.height / 1.75, 10 * sizeUnits * homePixelRatio);
    }
}
function createEquipmentModOverlay(canvas, level, costMultiplier) {
    if(troop.level < level) {
        createGradient(canvas, "#000000a0", "#000000a0", "#000000a0", "#000000a0", 0.75, 0.75);
        quickImage(canvas, "lockIcon", canvas.canvas.width / 2 - canvas.canvas.width / 4, canvas.canvas.height / 2 - canvas.canvas.width / 4, canvas.canvas.width / 2);
    } else if(troop.resources.credits < shopCost.credits * costMultiplier || troop.resources.metals < shopCost.metals * costMultiplier) {
        createGradient(canvas, "#000000a0", "#000000a0", "#00000000", "#00000000", 0.75, 0.75);
    }
}
function drawItem(canvas, equipment, x, y, w) {
    var h = document.getElementById(equipment.type).naturalHeight / document.getElementById(equipment.type).naturalWidth * w;
    if(equipment.slot == "Legs" || equipment.slot == "Torso" || equipment.slot == "Helmet" || equipment.slot == "Left Arm" || equipment.slot == "Right Arm") {
        drawCharacter(canvas, equipment, w * 0.8, x + w /2, y + h /2);   
    } else {
        quickImage(canvas, equipment.type, x + w/10, y + h/10 - h / 2 + w / 2, w * 0.8);
    }
    canvas.beginPath();
    canvas.lineWidth  = w / 150;
    canvas.arc(x + w / 2, y + w / 2, w/2, 0, 2 * Math.PI);
    canvas.stroke();
}

function quickImage(canvas, id, x, y, w) {
    var h;
    if(h == undefined) {
        h = document.getElementById(id).naturalHeight / document.getElementById(id).naturalWidth * w;
    }
    canvas.drawImage(document.getElementById(id), x, y, w, h);
}

function createGradient(canvas, gc1, gc2, gc3, gc4, stop1, stop2) {
    var gradient = canvas.createLinearGradient(0, 0, canvas.canvas.width, canvas.canvas.height);
    gradient.addColorStop(0, gc1);
    gradient.addColorStop(stop1, gc2);
    gradient.addColorStop(stop2, gc3);
    gradient.addColorStop(1, gc4);
    canvas.fillStyle = gradient;
    canvas.fillRect(0, 0, canvas.canvas.width, canvas.canvas.height);
}

function makePurchase(level, junkChance, commonChance, uncommonaChance, rareChance, epicChance, legendaryChance, insaneChance, purchases, purchasesAddition, creditCost, metalCost, experienceCost, selectionArrays, unlockArrays){
    var completeSelectionArray = [];
    var outerChosenIndex = [];
    var chosenIndex;
    var rarityIncrease;
    if(troop.level < level) {
        tell(10, "Level Not Reached", "You cannot select this purchase until you have reached level " + level + ".");
        return;
    }
    addResources(-creditCost, -metalCost, 0);
    if(troop.resources.credits >= 0 && troop.resources.metals >= 0) {
        for(var i = 0; i < selectionArrays.length; i ++) {
            for(var e = 0; e < selectionArrays[i].length; e++) {
                completeSelectionArray.push(selectionArrays[i][e]);
            }
        }
        if(purchases == "oneToFour") {
            purchases = getOneToFour();
        }
        purchases = purchases + purchasesAddition;
        for(var i= 0; i < purchases; i ++) {
            outerChosenIndex = Math.floor(Math.random() * (selectionArrays.length));
            chosenIndex = Math.floor(Math.random() * selectionArrays[outerChosenIndex].length);
            rarityIncrease = calculateRarity(junkChance, commonChance, uncommonaChance, rareChance, epicChance, legendaryChance, insaneChance);
            currentRewards.push(recievePurchasedItem(chosenIndex, outerChosenIndex, rarityIncrease, completeSelectionArray, selectionArrays, unlockArrays));
        }
        showRewardsScreen(experienceCost);
        addResources(0, 0, experienceCost)
    } else {
        if(troop.resources.metals < 0) {
            purchaseMetals();
            tell(4, "Necessary Metal Unavailable", "You do not have the Metal necessary to make this transaction. Unlock more Metals by playing the game or purchasing with Crystals.");
        } else if(troop.resources.credits < 0) {
            purchaseCredits();
            tell(15, "Necessary Credits Unavailable", "You do not have the Credits necessary to make this transaction. Unlock more Credits by playing the game or purchasing with Crystals.");
        }
        addResources(creditCost, metalCost, 0);
    }
}

function accpetRewards(event) {
    let rewardBoxes;
    if(event.target != event.currentTarget) return;
    document.getElementById('rewardsScreen').style.visibility = 'hidden';
    rewardBoxes = document.getElementsByClassName('rewardBox');
    currentRewards.length = 0;
    for(var i = 0; i < rewardBoxes.length; i ++) {
        rewardBoxes[i].style.display = 'none';
    }
    updateResources();
    setShopScreen();
}

function showRewardsScreen(xp) {
    let rewardBoxes = document.getElementsByClassName('rewardBox');
    let rewardImages = document.getElementsByClassName('rewardImage');
    document.getElementById('rewardsScreen').style.visibility = 'visible';
    for(var i = 0; i < currentRewards.length + 1; i ++) {
        if(rewardBoxes.length < i + 1) {
            createNewRewardBox(i);
        }
        setRewardBox(rewardBoxes[i], currentRewards[i - 1], rewardImages[i], i, xp);
    }
    for(var i = currentRewards.length + 1; i < rewardBoxes.length; i ++) {
        rewardBoxes[i].style.display = 'none';
    }
    document.getElementById('rewardsCloseButton').style.top = rewardBoxes[currentRewards.length].offsetTop + rewardBoxes[currentRewards.length].offsetHeight + 2.5 * sizeUnits + 'px';
    document.getElementById('rewardBackground').style.height = document.getElementById('rewardsCloseButton').offsetTop - document.getElementById('rewardBackground').offsetTop + document.getElementById('rewardsCloseButton').offsetHeight + 2 * sizeUnits + 'px';
    document.getElementById('rewardsCloseButton').style.top = rewardBoxes[currentRewards.length].offsetTop + rewardBoxes[currentRewards.length].offsetHeight + 2.5 * sizeUnits + 'px';
}

function setRewardBox(rewardBox, reward, rewardImage, i, xp) {
    rewardBox.style.display = 'block';
    if(i == 0) {
        rewardImage.src = "/image/experienceIcon";
        rewardImage.style.height = rewardBox.offsetHeight / 1.4 + 'px';
        rewardImage.style.width = rewardBox.offsetHeight / 1.4 + 'px';
        rewardImage.style.left =  rewardBox.offsetHeight / 7 + 'px';
        rewardImage.style.top =  rewardBox.offsetHeight / 7 + 'px';
        if(xp != undefined) {
            document.getElementsByClassName('rewardText')[i].innerText = xp;
        }
    } else {
        rewardImage.src = "/image/" + reward.src;
        displayImage(rewardImage, rewardBox, reward);
        createSimpleDesription(rewardBox, reward);
    }
}

function createSimpleDesription(element, reward) {
    element.onmouseover = function() { showWeaponDescription(element, reward); };
    element.onmouseout = function() { hideWeaponDescription(); };
}

function createNewRewardBox(i) {
    let rewardBox = document.createElement('DIV');
    let rewardImage = document.createElement('IMG');
    let rewardText;
    rewardBox.classList.add('rewardBox');
    rewardImage.classList.add('rewardImage');
    document.getElementById('rewardHolder').appendChild(rewardBox);
    rewardBox.appendChild(rewardImage);
    if(i == 0) {
        rewardText = document.createElement('P');
        rewardText.classList.add('rewardText');
        rewardBox.appendChild(rewardText);
    }
}

function addResources(creditCost, metalCost, experienceCost, skillPointCost) {
    if(skillPointCost != undefined) troop.resources.skillPoints += skillPointCost;
    troop.resources.experience += experienceCost;
    troop.resources.credits += creditCost;
    troop.resources.metals += metalCost;
}

function recievePurchasedItem(chosenIndex, outerChosenIndex, rarityIncrease, completeSelectionArray, selectionArrays, unlockArrays) {
    var foundIt = false;
    var rarity;
    var newEquipment = copyObject(selectionArrays[outerChosenIndex][chosenIndex]);
    newEquipment.rarityIncrease = rarityIncrease;
    
    rarity = getRarity(rarityIncrease);
    newEquipment.rarity = rarity.rarity;
    newEquipment.level = troop.level;
    if(newEquipment.mods != undefined) {
        newEquipment.mods.slotCount = Math.floor(newEquipment.mods.slotCount * rarity.slotCount);
    }
    newEquipment.sourceAffiliation = troop.sourceAffiliation;
    newEquipment.sourceName = troop.username;
    increaseEquipmentStatsByLevel(newEquipment);
    troop.boughtCount ++;
    newEquipment.id = newEquipment.type + troop.boughtCount;
    if(unlockArrays[outerChosenIndex] == 'unlockedMods') {
        newEquipment.minorModifications = getMinorModifications(newEquipment);
    }
    newEquipment.power = getPower(newEquipment);
    troop[unlockArrays[outerChosenIndex]].push(newEquipment);
    saveTraitToServer(unlockArrays[outerChosenIndex], "resources", 'boughtCount');
    return newEquipment;
}

function getMinorModifications(mod) {
    let minorModifications = [];    
    for(var i = 0; i < mod.rarityIncrease; i ++) {
        minorModifications.push(getMinorModification(mod));
    }
    return minorModifications;
}

function getMinorModification(mod) {
    let modTrait = getMinorMod(mod);
    if(modTrait.available == 'Armour Mod' && mod.slot == 'Armour Mod' && Math.floor(Math.random() * 2) == 0) {
        if(modTrait.increase != undefined) {
            modTrait.increase *= 5.625;
        } else {
            modTrait.decrease *= 5.625;
        }
        modTrait.specific = true;
    } else if (modTrait.available == 'Weapon Mod' && (mod.slot == 'Weapon Mod' || mod.slot == 'Ranged Mod' || mod.slot == 'Melee Mod' ) && Math.floor(Math.random() * 2) == 0) {
        if(modTrait.increase != undefined) {
            modTrait.increase *= 2.25;
        } else {
            modTrait.decrease *= 2.25;
        }
        modTrait.specific = true;
    } else {
        modTrait.specific = false;
    }
    if(Math.floor(Math.random() * 3) == 0) {
        modTrait.negative = true;
    } else {
        modTrait.negative = false;
    }
    if(modTrait.increase == undefined) {
        modTrait.decrease = getIncrease(modTrait.decrease, mod.rarityIncrease, mod.level);
    } else {
        modTrait.increase = getIncrease(modTrait.increase, mod.rarityIncrease, mod.level);
    }
    return modTrait;
}

function getMinorMod(mod) {
    let modChances = 0;
    let modTrait;
    let modNum;
    let modFound;
    for(var i = 0; i < modTraits.length; i ++) {
        modChances += modTraits[i].chance * modTraits[i].options.length;
    }
    while(true) {
        modNum = Math.floor(Math.random() * modChances) + 1
        for(var i = 0; i < modTraits.length; i ++) {
            modNum -= modTraits[i].chance * modTraits[i].options.length;
            if(modNum <= 0) {
                modTrait = modTraits[i].options[Math.floor(Math.random() * modTraits[i].options.length)]
                if((modTrait.available == 'any' && Math.floor(Math.random() * 2) == 0) || modTrait.available == mod.slot || modTrait.available == 'Weapon Mod' && (mod.available == 'Weapon Mod' || mod.available == 'Ranged Mod' || mod.available == 'Melee Mod' )) {
                    return copyObject(modTrait);
                }
                break;
            }
        }
    }
}

function getIncrease(modIncrease, rarityIncrease, level) {
    let increase = 0;
    let randomChance;
    for(var i = 0; i < 6; i ++) {
        randomChance = Math.floor((Math.random() * 0.6 + 0.7) * 1000 * level) / (10000 * level);
        increase += rarityIncrease * modIncrease * randomChance / 10;
    }
    return increase;
}

function getRarity(rarityIncrease) {
    var rarity;
    var slotCount;
    if(rarityIncrease == 1) {
        rarity = "Junk";
        slotCount = 1;
    } else if(rarityIncrease == 2) {
        rarity = "Common";
        slotCount = 2;
    } else if(rarityIncrease == 3) {
        rarity = "Uncommon";
        slotCount = 2;
    } else if(rarityIncrease == 4) {
        rarity = "Rare";
        slotCount = 3;
    }else if(rarityIncrease == 5) {
        rarity = "Epic";
        slotCount = 3;
    } else if(rarityIncrease == 7) {
        rarity = "Legendary";
        slotCount = 4;
    } else if(rarityIncrease == 10) {
        rarity = "Insane";
        slotCount = 6;
    } else {
        console.error("Rarity Not Within Allowed Range: ERROR CODE 926 711");
    }
    return {rarity: rarity, slotCount: slotCount};
}

function increaseEquipmentStatsByLevel(equipment) {
    if(equipment.mods != undefined) {
        if(equipment.slot == "Melee" || equipment.slot == "Ranged") {
            equipment.criticalChance *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
            equipment.criticalDamage *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
            equipment.accuracy *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
            equipment.accuracyDamage *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
            equipment.precision *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
            equipment.initTime *= Math.pow(decreaseBase, equipment.rarityIncrease) * getRandBonus(true);
            let traits = ["Physical", "Thaumaturgy", "Stamina", "Health"];
            for(var i = 0; i < traits.length; i ++) {
                if(equipment[traits[i]].criticalChance != undefined) equipment[traits[i]].criticalChance *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                if(equipment[traits[i]].criticalDamage != undefined) equipment[traits[i]].criticalDamage *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                if(equipment[traits[i]].accuracy != undefined) equipment[traits[i]].accuracy *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                if(equipment[traits[i]].accuracyDamage != undefined) equipment[traits[i]].accuracyDamage *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                if(equipment[traits[i]].precision != undefined) equipment[traits[i]].precision *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                if(equipment[traits[i]].damage != undefined) equipment[traits[i]].damage *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                if(equipment[traits[i]].onKill != undefined) equipment[traits[i]].onKill *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                if(equipment[traits[i]].onDamage != undefined) equipment[traits[i]].onDamage *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                if(equipment[traits[i]].drain != undefined) equipment[traits[i]].drain *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                if(equipment[traits[i]].duration != undefined) equipment[traits[i]].duration *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                if(equipment[traits[i]].activationTime != undefined) equipment[traits[i]].activationTime *= Math.pow(decreaseBase, equipment.rarityIncrease) * getRandBonus(true);
                if(equipment[traits[i]].cooldown != undefined) equipment[traits[i]].cooldown *= Math.pow(decreaseBase, equipment.rarityIncrease) * getRandBonus(true);
            }

            if(equipment.slot == "Ranged") {
                equipment.damage *= Math.pow(majorIncreaseBase, equipment.rarityIncrease) * (1 + (equipment.level * levelBonus)) * getRandBonus();
                equipment.range *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                equipment.firingSpeed *= Math.pow(decreaseBase, equipment.rarityIncrease) * getRandBonus(true);
                equipment.projectileSpeed *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                equipment.heat.increase *= Math.pow(decreaseBase, equipment.rarityIncrease) * getRandBonus(true);
                equipment.heat.coolWaitTime *= Math.pow(decreaseBase, equipment.rarityIncrease) * getRandBonus(true);
                equipment.heat.overheatTime *= Math.pow(decreaseBase, equipment.rarityIncrease) * getRandBonus(true);
            } else {
                equipment.strike.damage *= Math.pow(majorIncreaseBase, equipment.rarityIncrease) * (1 + (equipment.level * levelBonus)) * getRandBonus();
                equipment.block.wait *= Math.pow(decreaseBase, equipment.rarityIncrease) * getRandBonus(true);
                equipment.strike.wait *= Math.pow(decreaseBase, equipment.rarityIncrease) * getRandBonus(true);
                equipment.strike.radius *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                equipment.strike.angle *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                equipment.strike.knockback *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                equipment.block.stabAngle *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                equipment.block.knockback *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                equipment.block.stun *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                equipment.block.enemyStabDrain *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                equipment.block.projectileAngle *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                equipment.block.reflectionRange *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                equipment.block.reflectionSpread *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                equipment.block.reflectionDrain *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                equipment.block.ownStabDrain *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                equipment.block.thaumAngle *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                equipment.block.enemyThaumDrain *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                equipment.block.ownThaumDrain *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                equipment.block.continualDrain *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                equipment.block.imediateDrain *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                equipment.strike.cost *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                equipment.block.parryTime *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
            }
        } else if(equipment.slot == "Legs" || equipment.slot == "Torso" || equipment.slot == "Helmet" || equipment.slot == "Right Arm" || equipment.slot == "Left Arm") {
            equipment.defense *= Math.pow(majorIncreaseBase, equipment.rarityIncrease) * (1 + (troop.level * levelBonus)) * getRandBonus();
            equipment.weight *= Math.pow(decreaseBase, equipment.rarityIncrease) * getRandBonus(true);
            let traits = ["Physical", "Thaumaturgy", "Stamina", "Health"];
            for(var i = 0; i < traits.length; i ++) {
                equipment[traits[i]].criticalResistance *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                equipment[traits[i]].criticalDefense *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                equipment[traits[i]].evasionChance *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                equipment[traits[i]].evasionDefense *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                if(equipment[traits[i]].defense != undefined) equipment[traits[i]].defense *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                if(equipment[traits[i]].tenacity != undefined) equipment[traits[i]].tenacity *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
                if(equipment[traits[i]].regen != undefined) equipment[traits[i]].regen *= Math.pow(increaseBase, equipment.rarityIncrease) * getRandBonus();
            }
        }
    } else {
        if(equipment.increase != undefined) {
            equipment.increase *= getRandBonus();
        }
        if(equipment.decrease != undefined) {
            equipment.decrease *= getRandBonus();
        }
    }
}

//returns a random bonus, which modifies traits by making them equal to between 75% and 100%  of their value, but does not let them exceed 100%
function getRandBonus(decrease) {
    return (decrease ? 1 : 0.5) + Math.random() * 0.5;
}

function calculateRarity(junkChance, commonChance, uncommonaChance, rareChance, epicChance, legendaryChance, insaneChance) {
    var randomNumber = Math.floor(Math.random() * (junkChance + commonChance + uncommonaChance + rareChance + epicChance + legendaryChance + insaneChance)) + 1;
    if(randomNumber <= junkChance) {
        return 1;
    } else if(randomNumber <= junkChance + commonChance) {
        return 2;
    } else if(randomNumber <= junkChance + commonChance + uncommonaChance) {
        return 3;
    } else if(randomNumber <= junkChance + commonChance + uncommonaChance + rareChance) {
        return 4;
    } else if(randomNumber <= junkChance + commonChance + uncommonaChance + rareChance + epicChance) {
        return 5;
    } else if(randomNumber <= junkChance + commonChance + uncommonaChance + rareChance + epicChance + legendaryChance) {
        return 7;
    } else if(randomNumber <= junkChance + commonChance + uncommonaChance + rareChance + epicChance + legendaryChance + insaneChance) {
        return 10;
    } else {
        return "impossible";
        console.error('Impossible Rearity Discovered: ERROR CODE 654 856');
    }
}

//hides the shop screen
function hideShopScreen() {
    document.getElementById("shopScreen").style.visibility = "hidden";
    setShopOptionVisibility("hidden");
}

function getGameData() {
    return {equipment: getModifiedEquipment(), hp: modifyAbility(copyObject(troop.hp)), stamina: modifyAbility(copyObject(troop.stamina), true), thaum: modifyAbility(copyObject(troop.force), true), physical: modifyAbility(copyObject(troop.physical)) };
}

//reveals the game, starts it, and hides home screen images
function startGame(gameMode) {
    redirected = true;
    joinGame(getGameData(), gameMode);
}

function stFullScreen(icon) {
    if(icon.status == "window") {
        try {
            icon.status = "fullScreen";
            icon.src = "/image/fullScreenExitButton";
            document.documentElement.requestFullscreen();
        } catch(err) {
            console.error("failed to enter fullscreen", err);
        }
    } else {
        try {
            icon.src = "/image/fullScreenEnterButton";
            icon.status = "window";
            document.exitFullscreen()
        } catch(err) {
            console.error("failed to exit fullscreen", err);
        }
    }

}

//sets the screen to the shop screen
function showShopScreen(clicked) {
    if(onPage == "weaponPage") {
        hideWeaponScreen();
        if(clicked == "equipment") {
            if(selectedEquipment.slot == "Melee" || selectedEquipment.slot == "Ranged") {
                weaponsShopScreen();
            } else {
                armourShopScreen();
            }
        } else {
            if(selectedEquipment.slot == "Melee" || selectedEquipment.slot == "Ranged") {
                weaponModsShopScreen();
            } else {
                armourModsShopScreen();
            }
        }
    } else if(onPage == "abilityPage") {
        hideAbilityPage();
        equipmentShopScreen();
    } else if(onPage == "homeScreen") {
        hideHomeScreen();
        equipmentShopScreen();
    } else if (onPage == "shopScreen") {
        hideShopScreen();
        showHomeScreen();
    }
}

//shows the weapon screen
function showHomeScreen() {
    onPage = "homeScreen";
    document.getElementById("settingsIcon").style.visibility = "visible";
    document.getElementById("playerName").style.visibility = "visible";
    document.getElementById("affiliationIcon").style.visibility = "visible";
    document.getElementById("characterScreen").style.visibility = "visible";
    setImages();
    document.getElementsByClassName("abilityImageDisplay")[0].style.visibility = "visible";
}

function hideGameAbilities() {
    let abilityIcons = document.getElementsByClassName("gameAbilities");
    for(var i = 0; i < abilityIcons.length; i ++) {
        abilityIcons[i].children[0].style.visibility = "hidden";
        abilityIcons[i].style.display = "none";
    }
    document.getElementById("abilityGameIconHolder").style.visibility = "hidden";
    document.getElementById("abilityAdviceButton").style.visibility = "hidden";
}
function hideAbilityDescription(complete) {
    hideGameAbilities();
    document.getElementById("abilityDescription").style.visibility = "hidden";
    if(viewingAbility != "none") {
        if(complete) {
            resetAbilityIcons(undefined, viewingAbility.abilityType);
            document.getElementById('unlockButton').style.visibility = 'hidden';
        } else resetAbilities(true);
    }
}
function resetAbilities(quick, e) {
    if( quick || e.target == e.currentTarget) {
        if(viewingAbility != 'none' || document.getElementById("abilityDescription").style.visibility != "visible") {
            setAbilityPage(abilityProperty);
        } else {
            hideAbilityDescription();
        }
    }
}

function setAbilities(ability, option, icon, color, noChange) {
    if(!noChange && color.classList.contains("clickedOption")) {
        resetAbilities(true);
        stopViewingAbility(ability);
    } else {
        let allPrequisites = false;
        let description = getAbilityDescription(ability, true);
        let duration = simplifyTableNumber(ability.duration);
        let cooldown = simplifyTableNumber(ability.cooldown);
        let activationTime = simplifyTableNumber(ability.activationTime);
        let prerequisiteDescription;
        setAbilityPageDescriptionLocation(option);
        document.getElementById("abilityDescription").style.visibility = "visible";
        viewingAbility = ability;
        document.getElementById("abilityTitle").innerHTML = `<img id = abilityTitleIcon src =${getSrc(ability)}> ${ability.name}`;
        allPrequisites = true;
        description += "<br><br><b>Class</b>: " + ability.class + " <i>" + ability.subclass + "</i>";
        if(ability.staminaCost > 0 || ability.subclass == "Block") description += "<br><br><b>Stamina</b>: " + ((ability.subclass != "Strike" && ability.subclass != "Block") ? (ability.class == "Mobility" ? "<span style=color:#aa4eff>" + simplifyTableNumber(ability.staminaCost) + "</span>" : simplifyTableNumber(ability.staminaCost)) : "<span style=color:#aa4eff>" + simplifyTableNumber(modifiedSKillStaminaCost(ability)) + "</span>");
        if(ability.thaumaturgyCost > 0) description += "<br><br><b>Thaumaturgy</b>: " + simplifyTableNumber(ability.thaumaturgyCost);
        if(ability.damage > 0) description += "<br><br><b>Damage</b>: " + simplifyTableNumber(ability.damage);
        if(ability.effectDamage > 0) description += "<br><br><b>Effect Damage</b>: " + simplifyTableNumber(ability.effectDamage);
        if(activationTime == 0) activationTime = "Instant";
        if(ability.duration == 0) duration = "Instant";
        if(!cooldown) cooldown = "Instant";
        description += "<br><br><b>Activation Time</b>: " + activationTime;
        description += "<br><br><b>Duration</b>: " + duration;
        if(ability.effectDuration > 0) description += "<br><br><b>Effect Duration</b>: " + simplifyTableNumber(ability.effectDuration);
        description += "<br><br><b>Cooldown</b>: " + cooldown;
        if(unlocked(ability)) {
            document.getElementById('abilityText').innerHTML = description;
            document.getElementById('unlockButton').style.visibility = 'hidden';
            setGameAbilities(ability.abilityType);
        } else {
            if(ability.prerequisites.length > 0) {
                prerequisiteDescription = "<br><br><b>Prerequisites</b>: ";
                for(var i = 0; i < ability.prerequisites.length; i ++) {
                    if(troop[ability.abilityType].abilities.length == 0) {
                        prerequisiteDescription += ability.prerequisites[i];
                        if(i < ability.prerequisites.length - 1) prerequisiteDescription += ", ";
                        allPrequisites = false;
                    } else {
                        for(var e = 0; e < troop[ability.abilityType].abilities.length; e ++) {
                            if(ability.prerequisites[i] == troop[ability.abilityType].abilities[e].name) {
                                let comma = "";
                                if(i < ability.prerequisites.length - 1) comma = ", ";
                                prerequisiteDescription += "<span style=color:#777777>" + ability.prerequisites[i] + comma + "</span>";
                                break;
                            }
                            if(e == troop[ability.abilityType].abilities.length - 1) {
                                prerequisiteDescription += ability.prerequisites[i];
                                if(i < ability.prerequisites.length - 1) prerequisiteDescription += ", ";
                                allPrequisites = false;
                            }
                        }
                    }
                }
                if(allPrequisites) description += "<span style=color:#777777>" + prerequisiteDescription + "</span>";
                else description += prerequisiteDescription;
            }
            if(troop.resources.skillPoints >= ability.unlockCost) {
                description += "<span style=color:#777777><br><br><b>Skill Points to Unlock</b>: " + simplifyNumber(ability.unlockCost) + "</span>";
            } else {
                description += "<br><br><b>Skill Points to Unlock</b>: " + simplifyNumber(ability.unlockCost);
            }
            if(troop.resources.credits >= ability.creditCost) {
                description += "<span style=color:#777777><br><br><b>Credits to Unlock</b>: " + simplifyNumber(ability.creditCost) + "</span>";
            } else {
                description += "<br><br><b>Credits to Unlock</b>: " + simplifyNumber(ability.creditCost);
            }
            document.getElementById("abilityText").innerHTML = description;
            setUnlockButton(ability, option, icon, color, allPrequisites);
            document.getElementById("abilityTypeIcon").style.visibility = "visible";
            hideGameAbilities();
        }
        resetAbilityIcons(color, ability);
        color.classList.add("clickedOption");
        color.classList.remove("unClickedOption");
        color.style.transitionDuration = 3 + "s";
        setAbilityInstructions(ability);
        document.getElementById("abilityInfoIcon").onclick = () => showStats(ability);
    }
    setAllGameAbilityCursors(ability.abilityType);
}

function setAbilityInstructions(ability) {
    let mainAbility = troop[ability.abilityType];
    for(var e = 0; e < mainAbility.abilities.length; e ++) {
        if(mainAbility.abilities[e].name == ability.name && mainAbility.game[0] != "locked") {
            setAbilityInstructionsText(mainAbility)
            return;
        }
    }
    if(ability.abilityType != undefined) resetGameAbilityInstructions(troop[ability.abilityType]);
}
function setAbilityInstructionsText(mainAbility, message = "Equip") {
    let imageText = "";
        for(var i = 0; i < mainAbility.game.length; i ++) {
            if(mainAbility.game[i] == undefined || (mainAbility.game[i].name != "locked" && (viewingAbility == "none" || mainAbility.game[i].name != viewingAbility.name))) {
                imageText += "<img class = abilityInstructionsIcon src = \"/image/" + mainAbility.gameKeys[i].toLowerCase() + "Icon\">"
            }
        }
        document.getElementById("abilityGameInstructions").innerHTML = imageText + " / <img class = abilityInstructionsIcon src = '/image/cursurIcon'> " + message;
        document.getElementById("abilityGameInstructions").style.color = "#ffffff"
}

function setGameAbilities(abilityNameBase) {
    let abilityName = getRefrence(abilityNameBase);
    let ability = troop[abilityName];
    let abilityIcons = document.getElementsByClassName("gameAbilities");
    for(var i = 0; i < ability.maxAbilities; i ++) {
        setGameAbility(ability, abilityIcons, i);
    }
    for(i; i < abilityIcons.length; i ++) {
        abilityIcons[i].style.display = "none";
    }
    document.getElementById("abilityGameIconHolder").style.visibility = "visible";
    document.getElementById("abilityAdviceButton").style.visibility = "visible";
}

function setGameAbility(ability, abilityIcons, i) {
if(i + 1 > abilityIcons.length)  createNewGameAbilityIcon();
    abilityIcons[i].style.display = "flex";
    if(ability.game[i] == undefined) {
        abilityIcons[i].children[0].style.visibility = "hidden";
        abilityIcons[i].children[1].innerText = ability.gameKeys[i];
        abilityIcons[i].onclick = function() {
            equipAbility(ability.gameKeys[i]);
        }
        setCursor(abilityIcons[i], undefined); 
    } else if(ability.game[i].name == "locked") {
        abilityIcons[i].children[0].style.visibility = "visible";
        abilityIcons[i].children[0].src = "/image/lockIcon";
        abilityIcons[i].children[1].innerText = "Level " + ability.game[i].level;
        abilityIcons[i].onclick = function() {};
        setCursor(abilityIcons[i], "locked"); 
    } else {
        abilityIcons[i].children[0].style.visibility = "visible";
        abilityIcons[i].children[0].src = getSrc(ability.game[i]);
        abilityIcons[i].children[1].innerText = ability.gameKeys[i];
        abilityIcons[i].onclick = function() {
            equipAbility(ability.gameKeys[i], ability.game[i]);
        }
        setCursor(abilityIcons[i], ability.game[i].name);
    }
}

function setCursor(abilityIcon, abilityName) {
    if(viewingAbility == "none" && (abilityName == "locked" || abilityName == undefined)) {
        setCursorStyle(abilityIcon, "not-allowed");
    } else if(viewingAbility == "none") {
        setCursorStyle(abilityIcon, "pointer");
    } else {
        if(abilityName == viewingAbility.name) {
            setCursorStyle(abilityIcon, "not-allowed");
        } else if(abilityName == "locked"){
            setCursorStyle(abilityIcon, "not-allowed");
        } else {
            setCursorStyle(abilityIcon, "pointer");
        }
    }
  

}

function setCursorStyle(abilityIcon, cursor) {
    abilityIcon.style.cursor = cursor;
    abilityIcon.children[0].style.cursor = cursor;
    abilityIcon.children[1].style.cursor = cursor;
}

function setAllGameAbilityCursors(abilityName) {
    let ability = troop[abilityName];
    let abilityIcons = document.getElementsByClassName("gameAbilities");
    for(var i = 0; i < ability.maxAbilities; i ++) {
        if(ability.game[i] == undefined) {
            setCursor(abilityIcons[i], undefined);
        } else {
            setCursor(abilityIcons[i], ability.game[i].name);
        }
    }
}

function createNewGameAbilityIcon() {
    let abilityGameIcon = document.createElement("DIV");
    abilityGameIcon.classList.add("gameAbilities");
    abilityGameIcon.appendChild(document.createElement("IMG"))
    abilityGameIcon.appendChild(document.createElement("SPAN"))
    document.getElementById("abilityGameIconHolder").appendChild(abilityGameIcon);
}

function setAbilityPageDescriptionLocation(option) {
    let location = option.offsetLeft + option.offsetWidth / 2;
    if(location <= sizeUnits * 50) {
        document.getElementById("abilityDescription").style.left = ""; 
        document.getElementById("abilityDescription").style.right = "0px"
    } else {
        document.getElementById("abilityDescription").style.right = ""; 
        document.getElementById("abilityDescription").style.left = "0px"
    }
}

function setUnlockButton(ability, option, icon, color, allPrequisites) {
    let lockType;
    if(allPrequisites && troop.resources.skillPoints >= ability.unlockCost && troop.resources.credits >= ability.creditCost) {
        lockType = "unlockIcon"
        document.getElementById("unlockButton").style.color = "#ffffff";
        document.getElementById("unlockButton").style.cursor = "pointer";
        document.getElementById("unlockButton").onclick = function() {
            addResources(-ability.creditCost, 0, Math.floor(ability.creditCost / 1000) + ability.unlockCost * 20, -ability.unlockCost)
            troop[ability.abilityType].abilities.push(ability);
            saveTraitToServer("resources", [ability.abilityType, "abilities", troop[ability.abilityType].abilities.length - 1]);
            option.classList.add("unlocked");
            if(option.classList.contains("preRequisitesMet")){
                option.classList.remove("preRequisitesMet");
                apilityPulses[i].classList.add('preRequisitesNeeded');
            }
            setAbilities(ability, option, icon, color, true);
            updateResources();
        }
    } else {
        lockType = "lockIcon" ;
        document.getElementById("unlockButton").style.color = "#777777";
        document.getElementById("unlockButton").style.cursor = "default";
        document.getElementById("unlockButton").onclick = function() {
            if(allPrequisites) {
                if(troop.resources.skillPoints < ability.unlockCost) {
                    purchaseSkillPoints();
                    tell(6, "Necessary Skill Points Unavailable", "You do not have the Skill Points necessary to make this transaction. Purchase more Skill Points first.");
                } else if(troop.resources.credits < ability.creditCost) {
                    purchaseCredits();
                    tell(14, "Necessary Credits Unavailable", "You do not have the Credits necessary to make this transaction. Purchase more Credits first.");
                }
            } else {
                tell(7, "Lacking Prequisites", "Before unlocking this skill, you must first unlock all of the prerequisite skills.");
            }
        }
    }
    document.getElementById("unlockButton").innerHTML = "<img style = \" position:absolute; left: 1.5vmin;\" class = unlockIcon src = \"/image/" + lockType +  " \"><span class = unlockIcon style = \"font-size:3vmin; margin-left:0.5vmin\">" + ability.unlockCost + "</span><img style = \"margin-left: 0.5vmin; margin-right: .5vmin \" class = unlockIcon src = /image/skillPointsIcon><span class = unlockIcon style = \"font-size:3vmin; margin-left:1vmin\">" + simplifyNumber(ability.creditCost) + "</span><img style = \"margin-left: 0.5vmin; margin-right: -2.5vmin \" class = unlockIcon src = /image/creditsIcon >";
    document.getElementById("unlockButton").style.visibility = "visible";
}

function resetAbilityIcons(colorEl, ability) {
    let abilityColors = document.getElementsByClassName("abilityPageColor");
    let apilityPulses = document.getElementsByClassName("abilityPulse");
    let abilities = staminaAbilities.concat(thaumaturgyAbilities);
    drawAbilitySvg();
    for(var i = 0; i < abilityColors.length; i ++) {
        if((colorEl == undefined || abilityColors[i] != colorEl) && abilityColors[i].classList.contains('clickedOption')) {
            abilityColors[i].style.opacity = window.getComputedStyle(abilityColors[i]).opacity;
            abilityColors[i].classList.remove("clickedOption");
            abilityColors[i].classList.add("unClickedOption");
            abilityColors[i].style.transitionDuration = 3 * abilityColors[i].style.opacity + "s";
        }
        if( hasPrerequisites(abilities[i])){
            apilityPulses[i].classList.remove("preRequisitesNeeded");
            apilityPulses[i].classList.add("preRequisitesMet");
        } else {
            apilityPulses[i].classList.remove("preRequisitesMet");
            apilityPulses[i].classList.add('preRequisitesNeeded');
        }
    }
}
function resizeAbilityPage() {
    setStatsList(document.getElementById("statsTable"));
    drawAbilitySvg();
}
function drawAbilitySvg() {
    let abilityOptions, abilities, svg, optionsBonus = 0;;
    abilityOptions = document.getElementsByClassName("abilityPageOption");
    if(abilityProperty == "stamina") {
        abilities = staminaAbilities;
    } else {
        abilities = thaumaturgyAbilities;
        optionsBonus = staminaAbilities.length;
    }
    abilities = abilityProperty == "stamina" ? staminaAbilities : thaumaturgyAbilities;
    svg = document.getElementById("prerequisiteLines");
    svg.parentNode.replaceChild(svg.cloneNode(false), svg);
    svg = document.getElementById("prerequisiteLines");
    for(var i = 0; i < abilities.length; i ++) {
        drawLines(svg, abilities[i], abilityOptions[i + optionsBonus]);
    }
}

function drawLines(svg, ability, option) {
    for(var i = 0; i < ability.prerequisites.length; i ++) {
        let found = unlockedPrerequisiteAbility(ability, i);
        let color = found ? "#ffffff" : "#777777";
        let prereq = document.getElementById(getPageOptionName(ability.prerequisites[i]));
        let newLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        newLine.setAttribute('x1', option.offsetLeft + option.offsetWidth / 2);
        newLine.setAttribute('y1', option.offsetTop + option.offsetHeight / 2);
        newLine.setAttribute('x2', prereq.offsetLeft + prereq.offsetWidth / 2);
        newLine.setAttribute('y2', prereq.offsetTop + prereq.offsetHeight / 2);
        newLine.setAttribute('stroke', color);
        newLine.setAttribute('stroke-width', "0.25vmin");
        svg.append(newLine);
    }
}

function hasPrerequisites(ability) {
    if(!(troop.resources.skillPoints >= ability.unlockCost && troop.resources.credits >= ability.creditCost) || unlocked(ability)) {
        return false;
    }
    for(var i = 0; i < ability.prerequisites.length; i ++) {
        if(unlockedPrerequisiteAbility(ability, i) == false ) {
            return false
        }
    }
    return true;
}

function unlockedPrerequisiteAbility(ability, i) {
    for(var e = 0; e < troop[ability.abilityType].abilities.length; e ++) {
        if(ability.prerequisites[i] == troop[ability.abilityType].abilities[e].name) {
            return true;
        }
    }
    return false;
}

function showAbilityPage(abilityProp) {
    if(onPage == "classScreen") return;
    hideHomeScreen();
    onPage = "abilityPage";
    setAbilityPage(abilityProp);
    document.getElementById("abilityPage").style.visibility = "visible";
    hideAbilityDescription();
}

function setAbilityPage(abilityProp) {
    let ability = troop[abilityProp];
    abilityProperty = abilityProp;
    document.getElementById("unlockButton").style.visibility = "hidden";
    if(ability.name == "Stamina") {
        setAbilityPageBaseDescription(ability, "force");
    } else {
        setAbilityPageBaseDescription(ability, "stamina");
    }
}

function getRefrence(name) {
    if(name.toLowerCase() == 'stamina') return 'stamina';
    return 'force';
}

function setAbilityPageBaseDescription(ability, otherAbility) {
    let abilityName = ability.name.toLowerCase();
    let otherAbilityName = troop[otherAbility].name.toLowerCase();
    stopViewingAbility(ability);
    document.getElementById("abilityDescription").style.visibility = "visible";
    document.getElementById("abilityTitle").innerHTML = '<img id = abilityTitleIcon src = "/image/' + abilityName + "Icon" + '" > '+ ability.name
    document.getElementById("abilityText").innerHTML = ability.description;
    document.getElementById("abilitySwap").innerHTML = '<img class = abilitySwapIcon src = "/image/' + otherAbilityName + 'Icon"><img class = abilitySwapIcon style = "top: 0.5vmin; height: 1.5vmin;" src = "/image/flipIcon"></span>'
    document.getElementById(abilityName + "Abilities").style.visibility = "visible";
    document.getElementById("abilityTypeIcon").src = "/image/" + abilityName + "Icon";
    document.getElementById("abilityTypeIcon").style.visibility = "hidden";
    document.getElementById(otherAbilityName + "Abilities").style.visibility = "hidden";
    resetAbilityIcons(undefined, ability);
    document.getElementById("abilitySwap").onclick = function() {
        setAbilityPage(otherAbility);
    }
    setAbilityInstructionsText(ability, "View")
    setGameAbilities(abilityName);
    resetGameAbilityInstructions(ability);
}

function getAbilityDescription(ability, style = false) {
    let trait = modifySkill(copyObject(ability));
    let description = replaceText(ability.description, ability, style);
    return description;
}

function replaceText(description, ability, style)  {
    while(true) {
        let start, end, snip, snipStyle;
        start = description.search("<prop>");
        if(start == -1) break;
        end = description.search("</prop>");
        snip = description.substring(start + 6, end);
        snipStyle = style ? "<span style=color:#aa4eff>" + simplifyTableNumber(ability[snip]) + "</span>" : simplifyTableNumber(ability[snip]);
        description = description.substring(0, start) + "" + snipStyle + "" + description.substring(end + 7);
    }
    return description;
}

function resetGameAbilityInstructions(ability) {
    let found = false;
    for(var i = 0; i < ability.game.length; i ++) {
        if(ability.game[i] != undefined && ability.game[i].name != "locked") {
            found = true;
            break;
        }
    }
    if(found == true) {
//        document.getElementById("abilityGameInstructions").innerHTML = "<img class = abilityInstructionsIcon src = '/image/cursurIcon>'' View";
        document.getElementById("abilityGameInstructions").style.color = "#ffffff";
    } else {
        document.getElementById("abilityGameInstructions").innerText = "Select an unlocked ability before equipping it";
        document.getElementById("abilityGameInstructions").style.color = "#777777";
    }
}

function hideAbilityPage(ability) {
    hideAbilityDescription(true);
    document.getElementById("abilityPage").style.visibility = "hidden";
    document.getElementById("staminaAbilities").style.visibility = "hidden";
    document.getElementById("thaumaturgyAbilities").style.visibility = "hidden";
    document.getElementById("abilityTypeIcon").style.visibility = "hidden";
    document.getElementById("unlockButton").style.visibility = "hidden";
}

function stopViewingAbility(ability) {
    viewingAbility = 'none';
    document.getElementById("abilityInfoIcon").onclick = () => showStats(ability);
}

//shows the weapon screen
function showWeaponScreen(equipment, equipmentArray, modArray) {
    hideHomeScreen();
    equipmentForModifications = equipment;
    selectedEquipment = equipment;
    equipmentArrayForModifications = equipmentArray;
    fullEquipmentArray = equipmentArray;
    selectedEquipmentArray = getFirstValues(12, 0);
    onPage = "weaponPage";
    document.getElementById("weaponPage").style.visibility = "visible";
    document.getElementById('weaponPageWeapon').style.visibility = 'visible';
    setWeaponPageWeapon();
    setWeaponScreenText();
    setDescriptionIcon(selectedEquipment, weaponIcon);
    setWeaponScreen(true);
    if(modsShowing == false) {
        tell(0, "Entering Equipment Screen", "Once you have unlocked equipment, click on a equipment icon to equip it. Press backspace over it to delete it. Click on the large equipment image for your unlocked upgrades to appear. Click on them to equip or press backspace over them to delete.");
    }
    if(selectedEquipmentArray.length == 0) {
        if(modsShowing == true) {
            tell(1, "No Upgrades Available", "You have not unlocked any modifications of the selected type.");
        } else {
            tell(2, "No Equipment Available", "You have not unlocked any equipment of the selected type.");
        }
    }
}

function getFirstValues(valueCount, firstValue) {
    var shortArray = [];
    var length;
    if(firstValue < 0) {
        firstValue = fullEquipmentArray.length + firstValue;
    }
    if(fullEquipmentArray.length < valueCount) {
        length = fullEquipmentArray.length + firstValue;
    } else {
        length = valueCount + firstValue
    }
    for(var i = firstValue; i < length; i ++) {
        shortArray.push(fullEquipmentArray[i % fullEquipmentArray.length]);
    }
    return shortArray;
}

//hides home screen elements
function hideHomeScreen() {
    let modCounter = document.getElementsByClassName('smallCounter');
    document.getElementById("settingsIcon").style.visibility = "hidden";
    document.getElementById("playerName").style.visibility = "hidden";
    document.getElementById("affiliationIcon").style.visibility = "hidden";
    document.getElementById("characterScreen").style.visibility = "hidden";
    document.getElementById("gameModeSelectionBackground").style.visibility = "hidden";
    document.getElementById("gameModeSelectionTab").style.top = (100 * sizeUnits) + "px";
    document.getElementsByClassName("abilityImageDisplay")[0].style.visibility = "hidden";
    for(var i = 0; i < modCounter.length; i ++) {
        modCounter[i].style.visibility = 'hidden';
    }


}

//checks if a new mod is available to install and installs it
function checkModAvailability(equipment) {
    var availableMods = [];
    var modsArray;
    var trueIndexArray = [];
    var found = false;
    equipment = equipment || selectedEquipment;
    if(equipment.mods.available[1] != undefined) {
        modsArray = window[equipment.mods.available[0]].slice(0).concat(window[equipment.mods.available[1]].slice(0));
    } else {
        modsArray = window[equipment.mods.available[0]].slice(0);
    }
    for(var e = 0; e < troop.unlockedMods.length; e ++) {
        found = false;
        for(var i = 0; i < modsArray.length; i ++) {
            if(found == false && troop.unlockedMods[e].type == modsArray[i].type) {
                found = true;
                availableMods.push(troop.unlockedMods[e]);
                trueIndexArray.push(e);
            }
        }
    }
    return [availableMods, trueIndexArray];
}

//equips an unlocked mod
function equipMod(index) {
    var reset = false;
    var selectedMod = selectedEquipmentArray[index];
    var equipmentIndex = 0;
    if(selectedMod.rarityIncrease <= selectedEquipment.rarityIncrease) {
        if(selectedEquipment.mods.equipped.length < selectedEquipment.mods.slotCount ) {
            selectedEquipment.mods.equipped.push(selectedMod);
            for(var i = 0; i < troop.unlockedMods.length; i ++) {
                if(troop.unlockedMods[i] == selectedEquipmentArray[index]) {
                    equipmentIndex = i;
                    break;
                }
            }
            troop.unlockedMods.splice(equipmentIndex, 1);
            setMods();
            fullEquipmentArray = checkModAvailability()[0];
            setSelectedEquipmentArray();
            if(selectedEquipmentArray.length <= 8 || selectedEquipmentArray.length == 11) {
                reset = true;
            }
            setWeaponScreen(reset);
            hideWeaponDescription();
        } else {
            tell(5, "No Room", "There is no more room on this equipment for more modifications. Unequip a mod to free up more space.");
        }
    } else {
        tell(3, "Upgrade Incompattible", "A piece of equipment is unable to handle an upgrade of a greater rarity than it's own rarity.");
    }
}

//sets the position images of mods
function setMods() {
    setModImages();
    setModBackgrounds();
    hideOrShowModSelection()
}

function setModBackgrounds() {
    for(var i = 0; i < selectedEquipment.mods.equipped.length; i ++) {
        if(document.getElementById("modImage" + i) != null) {
            document.getElementById("modImage" + i).src = "/image/" + selectedEquipment.mods.equipped[i].src;
            if(selectedEquipment.mods.equipped[i].rarity == "Insane") {
                document.getElementById("modImage" + i).style.filter = "invert(1) brightness(50%) sepia(100%) saturate(10000%) hue-rotate(0deg)";                        
            } else if(selectedEquipment.mods.equipped[i].rarity == "Legendary") {
                document.getElementById("modImage" + i).style.filter = "invert(1) brightness(100%) sepia(100%) saturate(1000000%) hue-rotate(320deg)";                        
            } else if(selectedEquipment.mods.equipped[i].rarity == "Epic") {
                document.getElementById("modImage" + i).style.filter = "invert(1) brightness(50%) sepia(100%) saturate(10000%) hue-rotate(280deg)";
            } else if(selectedEquipment.mods.equipped[i].rarity == "Rare") {                   
                document.getElementById("modImage" + i).style.filter = "invert(1) brightness(50%) sepia(100%) saturate(10000%) hue-rotate(200deg)";
            } else if(selectedEquipment.mods.equipped[i].rarity == "Uncommon") {
                document.getElementById("modImage" + i).style.filter = "invert(1) brightness(50%) sepia(100%) saturate(10000%) hue-rotate(120deg)";
            } else if(selectedEquipment.mods.equipped[i].rarity == "Common") {
                document.getElementById("modImage" + i).style.filter = "invert(1)";
            } else {
                document.getElementById("modImage" + i).style.filter = "none";
            }
        }
    }
}

//sets the text for the weapon screen
function setWeaponScreenText() {
    document.getElementById("weaponPageTitle").innerText = selectedEquipment.type;
    document.getElementById("weaponPageDescription").innerHTML = "<i style=color:"+getRarityColor(selectedEquipment.rarity) +"> "+ selectedEquipment.rarity + "</i>" + " Level " + selectedEquipment.level + " Power " + getPower(selectedEquipment)+ "\n" + selectedEquipment.description; 
    setWeaponStatsDisplay();
    setEquipmentCount();
}

function setEquipmentCount() {
    if(modsShowing == false) {
        document.getElementById('equipmentCount').innerText = `${getWeaponName()}s Unlocked: ${fullEquipmentArray.length}`;
    } else {
        document.getElementById('equipmentCount').innerText = `Modifiactions for ${getWeaponName()}s Unlocked: ${fullEquipmentArray.length}`;
    }
}

function setWeaponStatsDisplay() {
    document.getElementById("weaponStatsCanvas").width = 45 * sizeUnits * homePixelRatio;
    setDescriptionCanvas(ctx4, selectedEquipment, 3 * sizeUnits, 4.25);
    document.getElementById("weaponStatsCanvas").style.width = (45 * sizeUnits) + 'px';
    document.getElementById("infoButton").style.top = (document.getElementById("weaponStatsCanvas").offsetTop + sizeUnits * 0.5) + 'px';
    document.getElementById("infoButton").style.left = (document.getElementById("weaponStatsCanvas").offsetLeft + document.getElementById("weaponStatsCanvas").offsetWidth - sizeUnits * 3.25) + 'px';
}

//creates events for clicking equipment items
function createEvent(index, firstOne) {
    document.getElementById("weaponSelectionBackground" +  (index - firstOne)).onclick = function() { updateWeapon(index); };
    document.getElementById("weaponSelectionBackground" +  (index - firstOne)).onmouseover = function() { describeSelectionOption(index, firstOne); };
    document.getElementById("weaponSelectionBackground" +  (index - firstOne)).onmouseout = function() { hideWeaponDescription(); };
}

//desides whether to show the description of a mod or an equipment based on which is currently showing 
function describeSelectionOption(index, firstOne) {
    showWeaponDescription(document.getElementById("weaponSelectionBackground" +  (index - firstOne)), selectedEquipmentArray[index]);
}

//creates the events needed for a mod
function createModEvent(i) {
    document.getElementById("modBackground" + i).onclick = function(event) { displayOrHideModOptions(event, i); };
    document.getElementById("modBackground" + i).onmouseover = function(){describeMod(i)};
    document.getElementById("modBackground" + i).onmouseout = function(){hideWeaponDescription()};
}

//displays or hides mod options
function displayOrHideModOptions(event, index) {
    var reset = true;
    if(index != undefined && selectedEquipment.mods.equipped[index] != undefined) {
        let slot = getSlot(selectedEquipment);
        troop.unlockedMods.push(selectedEquipment.mods.equipped[index]);
        selectedEquipment.mods.equipped.splice(index, 1);
        if(slot.playerImage) {
            saveTraitToServer( ["playerImage", slot.equipment], "resources");
        } else {
            saveTraitToServer(slot.equipment, "unlockedMods");
        }
        showMods();
        reset = false;
        setSelectedEquipmentArray();
    } else if(modsShowing == false) {
        showMods();
        selectedEquipmentArray = getFirstValues(12, 0);
    } else if (modsShowing == true && (event.target.id == 'weaponModAvailableCounter' || event.target.id == 'weaponModEquippedCounter' || event.target.id == 'modHolder1' ||  event.target.id == 'modHolder2' || event.target.id == 'weaponPageWeaponBackground' || event.target.id == 'flipToModsIcon')) {
        showWeapons();
    }
    setWeaponScreen(reset);
}

function showMods() {
    fullEquipmentArray = checkModAvailability()[0];
    hideWeaponDescription();
    modsShowing = true;
    document.getElementById('weaponPageWeapon').style.visibility = 'hidden';
    hideOrShowModSelection();
}

function showWeapons() {
    fullEquipmentArray = equipmentArrayForModifications;
    modsShowing = false;
    selectedEquipmentArray = getFirstValues(12, 0);
    document.getElementById('weaponPageWeapon').style.visibility = 'visible';
    hidDescriptionMinors();
    hideOrShowModSelection();
}

//describes the mod selected
function describeMod(i) {
    if(selectedEquipment.mods.equipped[i] != undefined) {
        showWeaponDescription(document.getElementById("modBackground" + i), selectedEquipment.mods.equipped[i],'none');
    }
}

function setEquipmentBackgroundColor(equipment, image) {
    image.style.border = (sizeUnits / 4) + "px solid " + getRarityColor(equipment.rarity);
    image.style.backgroundColor = "#444464aa";
}

function getRarityColor(rarity) {
    if(rarity == "Insane") {
        return "#FF0000";
    } else if(rarity == "Legendary") {
        return "#FFCC43";
    } else if(rarity == "Epic") {
        return "#8F09F3";
    } else if(rarity == "Rare") {
        return "#005DAE";
    } else if(rarity == "Uncommon") {
        return "#007100";
    } else if(rarity == "Common"){
        return "#ffffff";
    } else {
        return "#000000";
    }
}

function setSelectedEquipment() {
    if(selectedEquipment.playerImage == true) {
        troop.playerImage[selectedEquipment.refrence] = selectedEquipment;
    } else {
        troop[selectedEquipment.refrence] = selectedEquipment;
    }
}

//updates the currently selected weapon
function updateWeapon(index) {
    var equipmentArray;
    var slot = getSlot(selectedEquipment);
    var array = slot.array;
    var equipment = slot.equipment;
    var playerImage = slot.playerImage;
    if(modsShowing == false) {
        selectedEquipment = selectedEquipmentArray[index];
        equipmentArray = troop[array];
        equipmentForModifications = selectedEquipment;
        equipmentArrayForModifications = equipmentArray;

        if(playerImage == false) {
            equipmentArray.push(copyObject(troop[equipment]));
            troop[equipment] = copyObject(selectedEquipment);
        } else {
            equipmentArray.push(copyObject(troop["playerImage"][equipment]));
            troop["playerImage"][equipment] = copyObject(selectedEquipment);
        }
        equipmentArray.splice(getOldIndexStart(selectedEquipment, equipmentArray), 1);
        setSelectedEquipmentArray();
        setWeaponScreen(false);
    } else if(modsShowing == true) {
        array = "unlockedMods";
        equipMod(index);
    }
    setSelectedEquipment();
    if(playerImage == false) {
        saveTraitToServer(equipment, array, "resources");
    } else {
        saveTraitToServer( ["playerImage", equipment], array, "resources");
    }
}

function getSlot(equipmentSlot) {
    var playerImage = true;
    var equipment;
    var array;
        if(equipmentSlot.slot == 'Ranged') {
            equipment = "rangedWeapon";
            playerImage = false;
            array = "unlockedRangedWeapons";
        } else if( equipmentSlot.slot == 'Melee') {
            equipment = "meleeWeapon";
            playerImage = false;
            array = "unlockedMeleeWeapons";
        } else if(equipmentSlot.slot == 'Left Arm') {
            equipment = "leftArm";
            array = "unlockedLeftArms";
        } else if(equipmentSlot.slot == 'Right Arm') {
            equipment = "rightArm";
            array = "unlockedRightArms";
        } else if(equipmentSlot.slot == 'Legs') {
            equipment = "legs";
            array = "unlockedLegs";
        } else if(equipmentSlot.slot == 'Torso') {
            equipment = "body";
            array = "unlockedBodies";
        } else if(equipmentSlot.slot == 'Helmet') {
            equipment = "head";
            array = "unlockedHelmets";
        } else {
            equipment = equipmentArrayForModifications;
            array = "unlockedMods";
            playerImage = equipmentForModifications.playerImage;
        }
        return {equipment: equipment, playerImage: playerImage, array: array};
}

function setSelectedEquipmentArray() {
    let selectedEquipmentArrayIndexStart = getOldIndexStart(selectedEquipmentArray[0], fullEquipmentArray);
    if( selectedEquipmentArray.length < 12 && selectedEquipmentArrayIndexStart == 12) { //+ 4 <= 0 && selectedEquipmentArrayIndexStart + 5 > 0 ) {
        selectedEquipmentArrayIndexStart = 0;
    }

    if( selectedEquipmentArray.length < 12 && selectedEquipmentArrayIndexStart == -4) { //+ 4 <= 0 && selectedEquipmentArrayIndexStart + 5 > 0 ) {
        selectedEquipmentArrayIndexStart = selectedEquipmentArray.length - (selectedEquipmentArray.length % 4);
    }
        selectedEquipmentArray = getFirstValues(12, selectedEquipmentArrayIndexStart);
}

function setWeaponScreenSelections(i, firstOne) {
    document.getElementById("weaponSelectionBackground" + (i - firstOne)).style.visibility = "visible";       
    setEquipmentBackgroundColor(selectedEquipmentArray[i], document.getElementById("weaponSelectionBackground" + (i - firstOne)));
    setModCounter(i - firstOne, selectedEquipmentArray[i], checkModAvailability()[0]);
    document.getElementById("weaponSelection" + (i - firstOne)).src = "/image/" + selectedEquipmentArray[i].src;
    createEvent(i, firstOne);
    displayImage(document.getElementById("weaponSelection" + (i - firstOne)), document.getElementById("weaponSelectionBackground" + i), selectedEquipmentArray[i]);
}

//updates the mod events
function updateModEvents() {
    for(var i = 0; i < selectedEquipment.mods.slotCount; i ++) {
        if(document.getElementById("modImage" + i) != null) {
            var element = document.getElementById("modImage" + i),
                elClone = element.cloneNode(true);
            element.parentNode.replaceChild(elClone, element);
            createModEvent(i);
        }
    }
}

function setModCounter(i, equipment, mods) {
    let modCounter = document.getElementsByClassName('modCounter')[i];
    let modsAvailable = document.getElementsByClassName('modsAvailable')[i];
    if(modsShowing != true) {
        setModcounterValue(equipment, mods, modCounter, modsAvailable);
    }
}

function setModcounterValue(equipment, mods, modCounter, modsAvailable) {
    let availableModCount = 0;
    if(equipment.mods.equipped.length != 0) {
        modCounter.style.visibility = 'visible';
        modCounter.innerText = equipment.mods.equipped.length;
        modCounter.style.backgroundColor = getRarityColor(equipment.rarity);
    } else {
        modCounter.style.visibility = 'hidden';
    }
    availableModCount = getAvailableMods(equipment, mods);
    if(availableModCount != 0) {
        modsAvailable.innerText = availableModCount;
        modsAvailable.style.visibility = 'visible'
    } else {
        modsAvailable.style.visibility = 'hidden'
    }
}

function getAvailableMods(equipment, mods) {
    let availableModCount = 0;
    if(equipment.mods.equipped.length == equipment.mods.slotCount) return 0;
    for(var i = 0; i < mods.length; i ++) {
        if(mods[i].rarityIncrease <= equipment.rarityIncrease) {
            availableModCount ++;
            if(availableModCount == equipment.mods.slotCount - equipment.mods.equipped.length) return availableModCount;
        }
    }
    return availableModCount;
}

//Changes the images being used to display different equipment
function setDisplayImageSrcs() {
    document.getElementById("legsImage").src = "/image/" + troop.playerImage.legs.src;
    document.getElementById("rightArmImage").src = "/image/" + troop.playerImage.rightArm.src;
    document.getElementById("leftArmImage").src = "/image/" + troop.playerImage.leftArm.src;
    document.getElementById("bodyImage").src = "/image/" + troop.playerImage.body.src;
    document.getElementById("helmetImage").src = "/image/" + troop.playerImage.head.src;
    document.getElementById("weaponImage").src = "/image/" + troop.rangedWeapon.src;
    document.getElementById("meleeImage").src = "/image/" + troop.meleeWeapon.src;
}

//finds the unit called 'sizeUnit', which is equal to 1/100 of the smallest demension of the screen, either the width or hight
function defineSizeUnits() {
    if(window.innerWidth < window.innerHeight) {
        sizeUnits = window.innerWidth / 100;
    } else {
        sizeUnits = window.innerHeight / 100;
    }
}

//crops an image
function displayImage(armorImage, armorBackground, playerArmour) {
    if(playerArmour.imageName.naturalHeight / armorBackground.clientHeight > playerArmour.imageName.naturalWidth / armorBackground.clientWidth ) {
        var sizeSmallenation = (playerArmour.imageName.naturalHeight) / armorBackground.clientHeight;
    } else {
        var sizeSmallenation = (playerArmour.imageName.naturalWidth) / armorBackground.clientWidth ;
    }
    sizeSmallenation = sizeSmallenation * 1.4;
    armorImage.width = playerArmour.imageName.naturalWidth / sizeSmallenation;
    armorImage.height = playerArmour.imageName.naturalHeight / sizeSmallenation;
    armorImage.style.top = ((armorBackground.clientHeight - armorImage.clientHeight) / 2) + "px";
    armorImage.style.left = ((armorBackground.clientWidth  - armorImage.clientWidth ) / 2) + "px";
}

//sets the background for the character iamge on the home screen
function setCharacterBackground() {
    document.getElementById("characterBackground").width = sizeUnits * 33 * homePixelRatio;
    document.getElementById("characterBackground").height = sizeUnits * 44 * homePixelRatio;
    document.getElementById("characterBackground").style.top = (sizeUnits * 20) + "px";
    document.getElementById("characterBackground").style.left = (sizeUnits * 33) + "px";
    drawFullCharacter(ctx2);  
    document.getElementById("characterBackground").style.width = (sizeUnits * 33) + "px";
    document.getElementById("characterBackground").style.height = (sizeUnits * 44) + "px";
}

function setShopScreen() {
    let width = 85 / 3 * sizeUnits;
    let height = 69 * sizeUnits;
    resizeShopCanvas(width, height);
    colorShopBackgrounds();
    if(shopDescription != "") {
        setEquipmentModBackgrounds(width, height);
    } else {
        setResourceBackgrounds(width, height);
    }
}

function setEquipmentModBackgrounds(width, height) {
    createModBackground(ctx5,"Common Purchase", shopNumber[0], "Common or Uncommon", 1, width, height, "#02ffc0", "#02ffc0", "#035403", "#00bd00");
    createModBackground(ctx6,"Rare Purchase", shopNumber[1], "Rare or Epic", 10, width, height, "#c002ff", "#c002ff", "#030354", "#0000bd");
    createModBackground(ctx7,"Legendary Purchase", shopNumber[2], "Legendary or Insane", 100, width, height, "#ffc002", "#ffc002", "#540303", "#bd0000");
    drawShopItems();
    createEquipmentModOverlay(ctx5, 1, 1)
    createEquipmentModOverlay(ctx6, 15, 10)
    createEquipmentModOverlay(ctx7, 25, 100)
    if(document.getElementById('rewardsScreen').style.visibility == 'visible') {
        showRewardsScreen();
    }
}
function resizeShopCanvas(width, height) {
    let canvises = document.getElementsByClassName("purchaseOptions");
    for(var i = 0; i < canvises.length; i ++) {
        canvises[i].width = width * homePixelRatio;
        canvises[i].height = height * homePixelRatio;
        canvises[i].style.width = width + 'px';
        canvises[i].style.height = height + 'px';
    }
}
function colorShopBackgrounds() {
    let stop1 = 0.75, stop2 = 0.75;
    createGradient(ctx5, "#02ffc0", "#02ffc0", "#035403", "#00bd00", stop1, stop2);
    createGradient(ctx6, "#c002ff", "#c002ff", "#030354", "#0000bd", stop1, stop2);
    createGradient(ctx7, "#ffc002", "#ffc002", "#540303", "#bd0000", stop1, stop2);
}
function setResourceBackgrounds(width, height) {
    setResourceBackground(ctx5, width, height, 0, "#02ffc0", "#02ffc0", "#035403", "#00bd00", "Small", "Best Starter Purchase!");
    setResourceBackground(ctx6, width, height, 1, "#c002ff", "#c002ff", "#030354", "#0000bd", "Regular", "Most Popular!");
    setResourceBackground(ctx7, width, height, 2, "#ffc002", "#ffc002", "#540303", "#bd0000", "Ultimate", "Best Value!");
}
function colorResourceOverlay() {
    createGradient(ctx6A, "#00000000", "#00000000", "#030354", "#0000bd", 0.75, 0.75);
    createGradient(ctx7A, "#00000000", "#00000000", "#540303", "#bd0000", 0.75, 0.75);
}
function setResourceBackground(canvas, width, height, i, gc1, gc2, gc3, gc4, desc, info, src1, src2, src3) {
    quickText(canvas, "center", canvas.canvas.width / 2, canvas.canvas.height / 10, canvas.canvas.width / 10, gc4, desc + " Purchase", shopNames, gc3, 0, canvas.canvas.height / 20, canvas.canvas.width / 12.5);
    quickText(canvas, "center", canvas.canvas.width / 2, canvas.canvas.height / 5, canvas.canvas.width / 18.5, gc3, "Instantly earn " + shopNumber[i] + " " + shopNames);
    quickText(canvas, "center", canvas.canvas.width / 2, canvas.canvas.height / 4.4, canvas.canvas.width / 18.5, gc3, info);
    quickImage(canvas, shopItems[i], 0, 0, canvas.canvas.width);
    createGradient(canvas, "#00000000", "#00000000", gc3, gc4, 0.75, 0.75);
    if(shopNames == "Crystals") {
        quickImage(canvas, "moneysIcon", canvas.canvas.width / 1.7, canvas.canvas.height / 1.112, 3 * sizeUnits * homePixelRatio);
    } else {
        quickImage(canvas, "crystalsIcon", canvas.canvas.width / 1.7, canvas.canvas.height / 1.132, 4.5 * sizeUnits * homePixelRatio);
        //quickImage(canvas, "creditsIcon", canvas.canvas.width / 2.05, canvas.canvas.height / 1.12, 3.5 * sizeUnits * homePixelRatio);

    }
    quickText(canvas, "end", canvas.canvas.width /1.775, canvas.canvas.height / 1.07, canvas.canvas.width / 10, gc1, simplifyNumber(shopCost.crystals[i]));
    if(shopNames != "Crystals" && troop.resources.crystals < shopCost.crystals[i]) {
        createGradient(canvas
        , "#000000a0", "#000000a0", "#00000000", "#00000000", 0.75, 0.75);
    }
}


//sets the home screen images after being resized and after initial loading
function setImages() {
    if(pageLoaded == true) {
        defineSizeUnits();
        if(onPage == "homeScreen") {
            setHomeScreen();
        } else if(onPage == "weaponPage") {
            setWeaponScreen(false);
        } else if(onPage == "shopScreen") {
            setShopScreen();
        } else if(onPage == "abilityPage") {
            resizeAbilityPage();
        } else if(onPage == "classScreen") {
            setClassScreen();
        }
        if(weaponHovering == true) {
            setDescriptionCanvas(ctx3, hoveredEquipment, 0);
        }
    }
}

//shows the images of the homescreen and sets their position
function setHomeScreen() {
    setHomeImageDisplays();
    setCharacterBackground();
    setPowerDisplay();
    setAbilityDisplays();
}

function setAbilityDisplays(){
    let traitAspects = document.getElementsByClassName('traitAspect');
    let aspects = ["stamina", "force", "hp", "physical"];
    let e = 0;
    for(var i = 0; i < aspects.length; i ++) {
        let trait = onPage == "classScreen" ? classModifyEquipment(copyObject(troop[aspects[i]])) :  modifyAbility(copyObject(troop[aspects[i]]));
        if(trait.max != undefined) {
            traitAspects[e].innerText = "Maximum: " + simplifyNumber(trait.max);
            e ++;
        }
        if(trait.regenPerSecond != undefined) {
            traitAspects[e].innerText = "Recovery: " + simplifyNumber(trait.regenPerSecond);
            e ++;
        }
        if(trait.damage != undefined) {
            traitAspects[e].innerText = "Damage: " + simplifyNumber(trait.damage);
            e ++;
        }
        if(trait.defense != undefined) {
            traitAspects[e].innerText = "Defense: " + simplifyNumber(trait.defense);
            e ++;
        }
    }
    setStatsList(document.getElementById("statsTable"));
}

function setPowerDisplay() {
    let totalPower = (getPower(troop.rangedWeapon) + getPower(troop.meleeWeapon) + getPower(troop.playerImage.head) + getPower(troop.playerImage.body) + getPower(troop.playerImage.legs) + getPower(troop.playerImage.leftArm) + getPower(troop.playerImage.rightArm)) * (1 + (troop.level * levelBonus));
    document.getElementById('totalPower').innerText = "Power: " + Math.round(totalPower);
}

function setHomeImageDisplays() {
    let types = ['weapon', 'melee', 'helmet', 'body', 'legs', 'leftArm', 'rightArm']
    let equipment;
    for(var i = 0; i < types.length; i ++) {
        if( i == 0) {
            equipment = troop.rangedWeapon;
        } else if (i == 1) {
            equipment = troop.meleeWeapon;
        } else if(i == 2) {
            equipment = troop.playerImage.head;
        } else {
            equipment = troop.playerImage[types[i]];
        }
        displayImage(document.getElementById(types[i] + "Image"), document.getElementById(types[i] + "ImageDisplay"), equipment);
        setModcounterValue(equipment, checkModAvailability(equipment)[0], document.getElementsByClassName('smallModCounter')[i], document.getElementsByClassName('smallModsAvailable')[i]);
        setEquipmentBackgroundColor(equipment,document.getElementById(types[i] + "ImageDisplay"));
    }
}

function createNewModImage(i) {
    var modBackground = document.createElement("DIV");
    var modImage;
    modBackground.id = "modBackground" + i;
    modBackground.className  = "modBackground"
    if(i < 3) {
        document.getElementById("modHolder1").appendChild(modBackground);
    } else {
        document.getElementById("modHolder2").appendChild(modBackground);
    }
    modImage = document.createElement("IMG");
    modImage.id = "modImage" + i;
    modBackground.appendChild(modImage);
    document.getElementById("modImage" + i).className = "modImageClass";
}

//sets the position and visibility of mod images
function setModImages() {
    var modsShown = selectedEquipment.mods.slotCount;
    for(var i = 0; i < selectedEquipment.mods.slotCount; i ++) {
        if(document.getElementById("modImage" + i) == null) {
            createNewModImage(i);
        }
        if(selectedEquipment.mods.equipped[i] != undefined) {
            document.getElementById("modImage" + i).width = document.getElementById("modBackground" + i).offsetWidth * 0.8;
            document.getElementById("modImage" + i).height = document.getElementById("modBackground" + i).offsetHeight * 0.8;
            document.getElementById("modImage" + i).style.left = ((document.getElementById("modBackground" + i).offsetWidth - document.getElementById("modImage" + i).width) / 2) + "px"; 
            document.getElementById("modImage" + i).style.top = ((document.getElementById("modBackground" + i).offsetHeight - document.getElementById("modImage" + i).height) / 2) + "px"; 
        } 
    }
    while (document.getElementById("modImage" + modsShown) != null) {
        document.getElementById("modImage" + modsShown).style.visibility = 'hidden';
        document.getElementById("modBackground" + modsShown).style.display = 'none';
        modsShown ++;
    }
}

//sets the main weapon image on the weapon page
function setWeaponPageWeapon() {
    document.getElementById("weaponPageWeapon").src = "/image/" + selectedEquipment.src;
    displayImage(document.getElementById("weaponPageWeapon"), document.getElementById("weaponPageWeaponBackground"), selectedEquipment);
    setModcounterValue(selectedEquipment, checkModAvailability(selectedEquipment)[0], document.getElementById('weaponModEquippedCounter'), document.getElementById('weaponModAvailableCounter'));
}

function minorlyModifyEquipment(stat, minorName, equipmentName, abilityName, abilityAddition = 0, decrease) {
    let allEquipment = [troop.rangedWeapon, troop.meleeWeapon, troop.playerImage.body, troop.playerImage.rightArm, troop.playerImage.leftArm, troop.playerImage.legs, troop.playerImage.head]
    let equipmentFoundCount = 0;
    let modFoundCount = 0;
    for(var i = 0; i < allEquipment.length; i ++) {
        //If it is an ability, then the bonus from each equipment will be added
        if(abilityName != undefined && allEquipment[i][abilityName] != undefined && allEquipment[i][abilityName][equipmentName] != undefined) {
            let newEequipmentFoundCount = allEquipment[i][abilityName][equipmentName];
            newEequipmentFoundCount = getModBonus(newEequipmentFoundCount, getModFoundCount(allEquipment[i], minorName, allEquipment[i].id), 0);
            if(decrease) newEequipmentFoundCount *= -1;
            equipmentFoundCount += newEequipmentFoundCount;
        }
        //if it is either an ability or equipment, the mod bonus gets added
        //if the mod bonus is specifc, then it is only added if the equipment is the sane as the mod source
        modFoundCount += getModFoundCount(allEquipment[i], minorName, equipmentName);
    }
    return getModBonus(stat, modFoundCount, abilityAddition) + equipmentFoundCount;
}
function getModFoundCount(equipment, minorName, equipmentName) {
    let modFoundCount = 0;
    for(var e = 0; e < equipment.mods.equipped.length; e ++) {
        let mod = equipment.mods.equipped[e];
        for(var a = 0; a < mod.minorModifications.length; a ++) {
            let minorMod = mod.minorModifications[a];
            if(minorMod.id == minorName && (!minorMod.specific || equipment.id == equipmentName)) {
                if(minorMod.negative) {
                    modFoundCount += -minorMod.increase || minorMod.decrease;
                } else {
                    modFoundCount += minorMod.increase || -minorMod.decrease;
                }
            }
        }
    }
    return modFoundCount;
}
function getModBonus(stat, modFoundCount, abilityAddition) {
    let multiplier = modFoundCount + abilityAddition / 100;
    if(multiplier >= 0) {
        return stat * (1 + multiplier)
    } else {
        return stat / (1 - multiplier);
    }
}
//calculates the modified statistic of equipment
function calculateModifiedStatistic(weapon, weaponStat, modName, abilityTrait, negative, decrease, uniform, foundOnly) {
    var modifiedStatistic = weaponStat;
    var foundCount = 0;
    for(var i = 0; i < weapon.mods.equipped.length; i ++) {
        if(weapon.mods.equipped[i].type == modName ) {
            let increase = 0;
            let newlyFound = 0;
            if(decrease == true) {
                increase = weapon.mods.equipped[i].decrease;
            } else {
                if(weapon.mods.equipped[i].increase != undefined) {
                    increase = weapon.mods.equipped[i].increase;
                } else {
                    increase = weapon.mods.equipped[i].decrease;
                }
            }
            if(uniform == "Lowest") {
                newlyFound = 1;
            } else if (uniform == "Highest"){
                newlyFound = weapon.rarityIncrease;
            } else if(uniform == 'accuratelyModified'){
                newlyFound = weapon.mods.equipped[i].rarityIncrease * (1 + (weapon.mods.equipped[i].level * levelBonus));
            } else {
                newlyFound = weapon.mods.equipped[i].rarityIncrease;
            }
            foundCount += newlyFound * increase;
        }
    }
    if(uniform == 'accuratelyModified' && abilityTrait != undefined) {
        foundCount += abilityTrait / 100;
    }
    if(negative == true) {
        if(foundOnly) return -foundCount;
        modifiedStatistic = modifiedStatistic / (1 + foundCount);
    } else {
        if(foundOnly) return foundCount;
        modifiedStatistic = modifiedStatistic * (1 + foundCount);
    }
    return modifiedStatistic;
}

function showAbilityDescription(imageDisplay, trait, src) {
    let text = `<img src = "/image/iIcon"> More Info`
    let abilityIcons = document.getElementsByClassName('abilityIcon');
    let abilityIconImages  = document.getElementsByClassName('abilityIconImage');
    hoveredEquipment = trait;
    weaponHovering = true;
    selectedItem = trait;
    hoveredDisplay = imageDisplay;
    document.getElementById('weaponDescriptionCategory').innerHTML = "Level " + trait.level;
    document.getElementById('weaponDescriptionTitle').innerText = trait.name;
    document.getElementById('weaponDescriptionText').innerText = trait.description;
    if(onPage != "classScreen" && (trait.name == "Stamina" || trait.name == "Thaumaturgy")) {
        text +=`          <img src = "/image/cursurIcon"> Select Abilities`;
    } 
    document.getElementById('weaponDescriptionInstructions').innerHTML = text;
    if(src != undefined) {
        weaponDescriptionImage.src = "/image/" + src;
    }
    if(trait.maxAbilities != undefined && onPage != "classScreen") {
        document.getElementById('abilityIconHolder').style.display = 'inline-flex';
        for(var i = 0; i < trait.maxAbilities; i ++) {
            if(abilityIcons[i] == null) {
                createNewAbilityIcon();
            }
            abilityIcons[i].style.display = 'flex';
            if(trait.game[i] == undefined) {
                abilityIconImages[i].style.visibility = "hidden";
            } else if(trait.game[i].name == "locked") {
                abilityIconImages[i].src = "/image/lockIcon";
                abilityIconImages[i].style.visibility = "visible";
            } else {
                abilityIconImages[i].src = getSrc(trait.game[i]);
                abilityIconImages[i].style.visibility = "visible";
            }
        }
    }
    setDescriptionBackgroundPosition(imageDisplay); // must be last call in function
    document.getElementById('descriptionBackground').style.visibility = 'visible';
}

function getSrc(ability) {
    return "/image/" + ability.refrence + "Ability";
}

function createNewAbilityIcon() {
    let abilityIcon = document.createElement('DIV');
    let abilityIconImage = document.createElement("IMG")
    abilityIcon.classList.add('abilityIcon');
    abilityIconImage.classList.add('abilityIconImage');
    document.getElementById('abilityIconHolder').appendChild(abilityIcon);
    abilityIcon.appendChild(abilityIconImage);
}

//show the description of an ability when the mouse is moved over it
function showWeaponDescription(imageDisplay, equipment) {
    if(equipment.slot == undefined) return showAbilityDescription(imageDisplay, equipment)
    hoveredEquipment = equipment;
    weaponHovering = true;
    hoveredDisplay = imageDisplay;
    setWeaponDescriptionText(document.getElementById('weaponDescriptionText'), document.getElementById('weaponDescriptionInstructions'), equipment);
    document.getElementById('weaponDescriptionCategory').innerHTML = equipment.slot +  "          <i style=color:"+getRarityColor(equipment.rarity) +">"+ equipment.rarity + "</i>" + "          Level " + equipment.level + "          Power " + getPower(equipment);
    document.getElementById('descriptionCanvas').width = 38 * sizeUnits * homePixelRatio;
    setDescriptionIcon(equipment, weaponDescriptionImage);
    setDescriptionMinors(equipment);
    ctx3.canvas.style.display = 'block';
    setDescriptionCanvas(ctx3, equipment, 0, 3);
    document.getElementById('descriptionCanvas').style.width = (38 * sizeUnits) + 'px';
    setWeaponDescriptionTitle(equipment);
    setDescriptionBackgroundPosition(imageDisplay); // must be last call in function
    document.getElementById('descriptionBackground').style.visibility = 'visible';
}

function hidDescriptionMinors() {
    let minorModifications = document.getElementsByClassName('minorModifications');
    for(var i = 0; i < minorModifications.length; i ++) {
        minorModifications[i].style.display = 'none';
    }
}

function setDescriptionMinors(mod) {
    let minorDisplay;
    let modSrc;
    let minorModifications = document.getElementsByClassName('minorModifications');
    let value;
    if(isMod(mod) == true) {
        for(var i = 0; i < mod.minorModifications.length; i ++) {
            let modColor = '#777777';
            let modSign = '+';
            if(minorModifications.length < i + 1) {
                minorDisplay = document.createElement('DIV');
                minorDisplay.classList.add('minorModifications');
                document.getElementById('descriptionBackgroundMinors').appendChild(minorDisplay);
            }
            value = mod.minorModifications[i].increase || mod.minorModifications[i].decrease;
            if(mod.minorModifications[i].specific) {
                modSrc = 'gearIcon';
            } else {
                modSrc = 'globalIcon';
            }
            if(mod.minorModifications[i].negative == true) {
                modSign = '-';
                modColor = '#d40000';
            }
            if(mod.minorModifications[i].decrease != undefined && modSign == '-') {
                modSign = '+';
            } else if(mod.minorModifications[i].decrease != undefined) {
                modSign = '-';
            }
            minorModifications[i].innerHTML = '<img style = \' vertical-align: middle; width: 2vmin; height: 2vmin \' src ="/image/' + modSrc + '"><span class = minorModificationSpace></span><span style = \'color:' + modColor + '\'><b>' + mod.minorModifications[i].id + '</b>:</span><span class = minorModificationSpace></span>' + modSign + (Math.round(value * 10000) / 100) + '%';
            minorModifications[i].style.display = 'inline-block';
        }
        for(var i = mod.minorModifications.length; i < minorModifications.length; i ++) {
            minorModifications[i].style.display = 'none';
        }
    }    
}


function setWeaponDescriptionTitle(equipment) {
    if(equipment.type == undefined) {
        document.getElementById('weaponDescriptionTitle').innerHTML = equipment.id;
    } else {
        document.getElementById('weaponDescriptionTitle').innerHTML = equipment.type;
        selectedItem = equipment;    
    }
}

function setDescriptionBackgroundPosition(imageDisplay) {
    let imageDisplayLeft = getPosition('offsetLeft', imageDisplay);
    let imageDisplayTop = getPosition('offsetTop', imageDisplay);
    let homeLeft = getPosition('offsetLeft', document.getElementById('homeScreen'));
    let homeTop = getPosition('offsetTop', document.getElementById('homeScreen'));
    let descriptionBackgroundWidth = document.getElementById('descriptionBackground').offsetWidth;
    let descriptionBackgroundHeight = document.getElementById('descriptionBackground').offsetHeight;
    let homeWidth = document.getElementById('homeScreen').offsetWidth;
    let homeHeight = document.getElementById('homeScreen').offsetHeight;
    let heightIssue = false;
    document.getElementById('descriptionBackground').style.top = (imageDisplayTop - descriptionBackgroundHeight - 1 * sizeUnits) + "px";
    document.getElementById('descriptionBackground').style.left  = (imageDisplayLeft - sizeUnits * 14) + "px";
    if(document.getElementById('descriptionBackground').offsetLeft < homeLeft + sizeUnits * 1) {
        document.getElementById('descriptionBackground').style.left = (homeLeft + sizeUnits * 1) + "px";
    }
    if(document.getElementById('descriptionBackground').offsetLeft +  descriptionBackgroundWidth > homeLeft + homeWidth - sizeUnits * 1) {
        document.getElementById('descriptionBackground').style.left = (homeLeft + homeWidth - descriptionBackgroundWidth - sizeUnits * 1) + "px";
    }
    if(document.getElementById('descriptionBackground').offsetTop < homeTop + document.getElementById("informationBar").offsetHeight + sizeUnits * 1) {
        heightIssue = true;
        document.getElementById('descriptionBackground').style.top = Math.max(imageDisplayTop + (imageDisplay.offsetHeight - descriptionBackgroundHeight) / 2, homeTop + sizeUnits * 1 ) + "px";
    }
    if(document.getElementById('descriptionBackground').offsetTop + descriptionBackgroundHeight > homeTop + homeHeight - sizeUnits * 1) {
        heightIssue = true;
        document.getElementById('descriptionBackground').style.top = Math.min(imageDisplayTop + (imageDisplay.offsetHeight - descriptionBackgroundHeight) / 2, homeTop + homeHeight - sizeUnits * 1 - descriptionBackgroundHeight) + "px";
    }
    if(heightIssue) {
        if(imageDisplayLeft < homeLeft + homeWidth / 2) {
            document.getElementById('descriptionBackground').style.left = (imageDisplayLeft + imageDisplay.offsetWidth + 1 * sizeUnits) + "px";
        } else {
            document.getElementById('descriptionBackground').style.left = (imageDisplayLeft - descriptionBackgroundWidth - 1 * sizeUnits) + "px";
        }
    }
}

function getPosition(position, elem) {
    var distance = 0;
    do {
        if( !isNaN(elem[position])) {
            distance += elem[position];
        }
    } while (elem = elem.offsetParent);
    return distance;
}

function setWeaponDescriptionText(textDisplay, instructions, equipment) {
    var text = getDescription(equipment.description, equipment.increase, equipment.decrease, equipment.rarityIncrease, false, isMod(equipment), equipment.level);
    var instructionsText = '';
    var equip = `<img src = "/image/cursurIcon"> Equip`;
    var deconstruct = `<img src = "/image/deleteIcon"> Deconstruct`;
    var scroll = `<img src = "/image/scrollIcon"> Scroll`;
    var info = `<img src = "/image/iIcon"> `;
    var fixErrors = false;
    var isEquipped = false;
    if(isMod(equipment) && moreInfo) {
        info += 'Less Info';
        text = '<b>Main</b>:<br><span class = minorModificationSpace></span>' + text;
        text += '<br><b>Minor</b>:';
        for(var i = 0; i < equipment.minorModifications.length; i ++) {
            text += '<span \'style = text-indent: -1vmin\'><br><span class = minorModificationSpace></span>' + getDescription(equipment.minorModifications[i].description, equipment.minorModifications[i].increase, equipment.minorModifications[i].decrease, undefined, equipment.minorModifications[i].negative) + '</span>';
        }
    } else {
        info += 'More Info';
    }
    if(fixErrors) {
        for(var i = 0; i < troop.unlockedRangedWeapons.length; i ++) {
            if(equipment.id == troop.unlockedRangedWeapons[i].id) {
                text = i + "-: " + text;
                break;
            }
        }
    }
    if(selectedEquipment != undefined) {
        for(var e = 0; e < selectedEquipment.mods.equipped.length; e ++) {
            if(equipment.id == selectedEquipment.mods.equipped[e].id) {
                isEquipped = true;
                if(fixErrors) text = e + "-: " + text;
            }
        }
        if(fixErrors) {
            for(var i = 0; i < selectedEquipmentArray.length; i ++) {
                if(equipment == selectedEquipmentArray[i]) {
                    text = i + ": " + text;
                    break;
                }
            }
        }
    }
    if(onPage == 'shopScreen') {
        instructionsText = `${info}`;
    } else if(onPage == "homeScreen") {
        instructionsText = `<img src = "/image/cursurIcon"> View          ${info}`
    } else if(isMod(equipment)) {
        if(fixErrors) {
            for(var a = 0; a < checkModAvailability()[0].length; a ++) {
                if(equipment == checkModAvailability()[0][a]) {
                    text = a + "-: " + text;
                    break;
                }
            }
        }
        if(isEquipped) {
            instructionsText = `<img src = "/image/cursurIcon"> Unequip          ${info}          ${deconstruct}`;
        } else {
            instructionsText = `${equip}          ${info}          ${deconstruct}          ${scroll}`;
        }
    } else {
        instructionsText = `${equip}          ${info}          ${deconstruct}          ${scroll}`;
    }
    textDisplay.innerHTML = text;
    instructions.innerHTML = instructionsText;
}

function getDescription(text, increase, decrease, rarityIncrease, negative, isMod, level) {
    let newText;
    if(isMod) {
        if(negative) {//1 + (weapon.mods.equipped[i].level * levelBonus
            increase = 1 - 1 /(1 + increase * (1 + (level * levelBonus)) * (rarityIncrease || 1));
            decrease = decrease * (1 + (level * levelBonus)) * (rarityIncrease || 1);
        } else {
            increase = increase * (1 + (level * levelBonus)) * (rarityIncrease || 1);
            decrease = 1 - 1 /(1 + decrease * (1 + (level * levelBonus)) * (rarityIncrease || 1));
        }
    } else {
        increase *= rarityIncrease || 1;
        decrease *= rarityIncrease || 1;
    }
    newText = text.replace(/DECREASE/g, (Math.round(decrease * 10000) / 100 + '%') || 'Not Available').replace(/INCREASE/g, (Math.round(increase * 10000) / 100 + '%') || 'Not Available');
    if(negative) {
        if(newText.includes('Increase')) {
            newText = newText.replace(/Increase/g, 'Decrease').replace(/increase/g, 'decrease');
        } else {
            newText = newText.replace(/Decrease/g, 'Increase').replace(/decrease/g, 'increase');
        }
    }
    return newText;
}

//sets the description icon for pieces of equipment
function setDescriptionIcon(equipment, image) {
        document.getElementById(image.id).style.visibility = "hidden";
        document.getElementById(image.id).onload = function() {
        document.getElementById(image.id).style.visibility = "visible";
    }
    if(equipment.slot == 'Helmet') {
        document.getElementById(image.id).src = "/image/helmetIcon";
    } else if(equipment.slot == 'Torso') {
        document.getElementById(image.id).src = "/image/torsoIcon";
    } else if(equipment.slot == 'Legs') {
        document.getElementById(image.id).src = "/image/legsIcon";
    } else if(equipment.slot == 'Left Arm') {
        document.getElementById(image.id).src = "/image/leftArmIcon";
    } else if(equipment.slot == 'Right Arm') {
        document.getElementById(image.id).src = "/image/rightArmIcon";
    } else  if(equipment.slot == 'Ranged') {
        document.getElementById(image.id).src = "/image/rangedIcon";
    } else if(equipment.slot == 'Melee') {
        document.getElementById(image.id).src = "/image/meleeIcon";
    } else if(equipment.slot == 'Ranged Mod') { 
        document.getElementById(image.id).src = "/image/weaponModIcon";
    } else if(equipment.slot == 'Melee Mod') {
        document.getElementById(image.id).src = "/image/weaponModIcon";
    } else if(equipment.slot == 'Weapon Mod') {
        document.getElementById(image.id).src = "/image/weaponModIcon";
    } else if(equipment.slot == 'Armour Mod') {
        document.getElementById(image.id).src = "/image/armourModIcon";
    } else {
        console.error('Innacurate Mod Name: ERROR CODE 872 643 - ', equipment.slot);
    }
}

//hies the description of an ability when the mouse is moved off of it
function hideWeaponDescription() {
    let abilityIcons = document.getElementsByClassName('abilityIcon');
    selectedItem = "none";
    ctx3.canvas.style.visibility = 'hidden';
    ctx3.canvas.style.display = 'none';
    document.getElementById('descriptionBackground').style.visibility = 'hidden';
    weaponHovering = false;
    for(var i = 0; i < abilityIcons.length; i ++) {
        abilityIcons[i].style.display = 'none';
    }
    document.getElementById(weaponDescriptionImage.id).onload = null;
    document.getElementById(weaponDescriptionImage.id).style.visibility = "hidden";
    document.getElementById('abilityIconHolder').style.display = 'none';
    hidDescriptionMinors();
}

        </script>
    </body>
</html>